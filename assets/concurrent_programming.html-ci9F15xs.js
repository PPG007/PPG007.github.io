import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as a,o as l}from"./app-rQI8KFp-.js";const n={};function o(r,e){return l(),i("div",null,e[0]||(e[0]=[a('<h1 id="并发编程" tabindex="-1"><a class="header-anchor" href="#并发编程"><span>并发编程</span></a></h1><h2 id="关于并发" tabindex="-1"><a class="header-anchor" href="#关于并发"><span>关于并发</span></a></h2><ul><li>并发会在性能和编写额外代码上增加一些开销。</li><li>正确的并发是复杂的，即便对于简单地问题也是如此。</li><li>并发缺陷并非总能重现，所以常被看作偶发事件而忽略。</li><li>并发常常需要对设计策略进行根本性修改。</li></ul><h2 id="并发防御原则" tabindex="-1"><a class="header-anchor" href="#并发防御原则"><span>并发防御原则</span></a></h2><ul><li>单一职权原则：分离并发相关代码与其他代码。 <ul><li>并发相关代码有自己的开发、修改和调优生命周期。</li><li>并发相关代码有自己要对付的挑战，和非并发相关代码不同，往往更加困难。</li><li>写的不好的并发代码可能的出错方式数量也足具挑战。</li></ul></li><li>限制数据作用域：严格限制共享数据的访问。</li><li>使用数据复本：？</li><li>线程尽可能独立：减少与其他线程共享数据的可能。</li></ul><h2 id="测试线程代码" tabindex="-1"><a class="header-anchor" href="#测试线程代码"><span>测试线程代码</span></a></h2><p>编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行，如果测试失败，跟踪错误。</p><ul><li>将伪失败看作可能的线程问题。</li><li>先使非线程代码可工作。</li><li>编写可插拔的线程代码（可在数个配置环境下运行的线程代码）。</li><li>编写可调整的线程代码（允许线程数量可调整和变动）。</li><li>运行多于处理器数量的线程（为了促使任务切换的发生）。</li><li>在不同平台上运行。</li><li>调整代码并强迫错误发生。</li><li>不要同时追踪非线程错误和线程错误。</li></ul>',8)]))}const m=t(n,[["render",o]]),s=JSON.parse('{"path":"/clean-code/docs/concurrent_programming.html","title":"并发编程","lang":"zh-CN","frontmatter":{"description":"并发编程 关于并发 并发会在性能和编写额外代码上增加一些开销。 正确的并发是复杂的，即便对于简单地问题也是如此。 并发缺陷并非总能重现，所以常被看作偶发事件而忽略。 并发常常需要对设计策略进行根本性修改。 并发防御原则 单一职权原则：分离并发相关代码与其他代码。 并发相关代码有自己的开发、修改和调优生命周期。 并发相关代码有自己要对付的挑战，和非并发相...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-13T01:18:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/clean-code/docs/concurrent_programming.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"并发编程"}],["meta",{"property":"og:description","content":"并发编程 关于并发 并发会在性能和编写额外代码上增加一些开销。 正确的并发是复杂的，即便对于简单地问题也是如此。 并发缺陷并非总能重现，所以常被看作偶发事件而忽略。 并发常常需要对设计策略进行根本性修改。 并发防御原则 单一职权原则：分离并发相关代码与其他代码。 并发相关代码有自己的开发、修改和调优生命周期。 并发相关代码有自己要对付的挑战，和非并发相..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-13T01:18:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-13T01:18:18.000Z"}]]},"git":{"createdTime":1640525939000,"updatedTime":1747099098000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"},{"name":"Koston Zhuang","username":"","email":"koston.zhuang@maiscrm.com","commits":1}]},"readingTime":{"minutes":1.38,"words":415},"filePathRelative":"clean-code/docs/concurrent_programming.md","excerpt":"\\n<h2>关于并发</h2>\\n<ul>\\n<li>并发会在性能和编写额外代码上增加一些开销。</li>\\n<li>正确的并发是复杂的，即便对于简单地问题也是如此。</li>\\n<li>并发缺陷并非总能重现，所以常被看作偶发事件而忽略。</li>\\n<li>并发常常需要对设计策略进行根本性修改。</li>\\n</ul>","autoDesc":true}');export{m as comp,s as data};
