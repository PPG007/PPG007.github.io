import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as p,o as e}from"./app-UKhqlS50.js";const n={};function t(h,a){return e(),i("div",null,a[0]||(a[0]=[p(`<h1 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript"><span>JavaScript</span></a></h1><h2 id="引用" tabindex="-1"><a class="header-anchor" href="#引用"><span>引用</span></a></h2><p>所有的赋值都使用 const，如果一定要对参数重新赋值要使用 let 而不是 var。</p><h2 id="对象" tabindex="-1"><a class="header-anchor" href="#对象"><span>对象</span></a></h2><p>使用字面值创建对象而不是 new，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-dark:#abb2bf;--shiki-light:#000000;--shiki-dark-bg:#282c34;--shiki-light-bg:#FFFFFF;"><pre class="shiki shiki-themes one-dark-pro light-plus vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#0000FF;">const</span><span class="space"> </span><span style="--shiki-dark:#E5C07B;--shiki-light:#0070C1;">obj</span><span class="space"> </span><span style="--shiki-dark:#56B6C2;--shiki-light:#000000;">=</span><span class="space"> </span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">{};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用计算属性名创建动态属性名的对象而不是在对象定义外再创建：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-dark:#abb2bf;--shiki-light:#000000;--shiki-dark-bg:#282c34;--shiki-light-bg:#FFFFFF;"><pre class="shiki shiki-themes one-dark-pro light-plus vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#0000FF;">const</span><span class="space"> </span><span style="--shiki-dark:#E5C07B;--shiki-light:#0070C1;">obj</span><span class="space"> </span><span style="--shiki-dark:#56B6C2;--shiki-light:#000000;">=</span><span class="space"> </span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-dark:#ABB2BF;--shiki-light:#001080;">[</span><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">getKey</span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">()</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#001080;">]:</span><span class="space"> </span><span style="--shiki-dark:#D19A66;--shiki-light:#0000FF;">true</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span></span>
<span class="line"><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对象方法使用简写形式。</p><p>可以简写的属性名要简写，简写的属性要放前面。</p><p>属性名不必要加引号就不加。</p><p>不要直接调用 <code>Object.prototype</code> 上的方法，有的方法可能会被屏蔽，可以这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-dark:#abb2bf;--shiki-light:#000000;--shiki-dark-bg:#282c34;--shiki-light-bg:#FFFFFF;"><pre class="shiki shiki-themes one-dark-pro light-plus vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#267F99;">Object</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">prototype</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">hasOwnProperty</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">call</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">(</span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">obj</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span><span class="space"> </span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">key</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对象浅拷贝应该使用扩展运算符。</p><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h2><p>用字面量创建数组。</p><p>用 push 方法向数组中添加值。</p><p>用扩展运算符做浅拷贝。</p><p>用扩展运算符将可迭代对象转换成数组，用 <code>Array.from</code> 将一个类数组对象转成一个数组。</p><p>用 <code>Array.from</code> 做 map 遍历，对比扩展运算符可以避免创建一个临时数组。</p><p>如果一个数组有很多行，在数组的前后中括号进行换行。</p><p>除了 forEach 方法，其他方法如 map、reduce 等方法中要有 return。</p><h3 id="解构" tabindex="-1"><a class="header-anchor" href="#解构"><span>解构</span></a></h3><p>用对象的解构赋值来获取和使用对象某个或多个属性值。</p><p>多个返回值用对象的解构而不是数组解构。</p><h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串"><span>字符串</span></a></h3><p>字符串应该使用单引号。</p><p>长字符串不应该换行。</p><p>当需要动态字符串时，使用模板字符串而不是拼接。</p><p>永远不要使用 eval()。</p><p>不要使用不必要的转义字符。</p><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h3><p>使用命名函数表达式而不是函数声明，避免函数声明导致的提升。</p><p>把立即执行函数包裹在圆括号里。</p><p>不要在 if、while 等非函数块内声明函数。</p><p>不要使用 arguments 命名参数。</p><p>不要使用 arguments 变量，用 rest 替代。</p><p>在参数列表中指定默认值而不是在函数里进行判断再赋值。</p><p>避免默认参数值的副作用，默认值应当简洁直接。</p><p>默认参数赋值放在最后。</p><p>创建函数不要使用 Function 构造器。</p><p>函数定义部分要有空格。</p><p>不要修改传入的参数。</p><p>使用扩展运算符调用多参数的函数。</p><p>调用或者编写一个包含多个参数的函数，参数列表应该换行，每行只有一个参数和一个结尾的逗号。</p><p>不要传入不使用的参数。</p><h3 id="箭头函数" tabindex="-1"><a class="header-anchor" href="#箭头函数"><span>箭头函数</span></a></h3><p>当一定要使用函数表达式（回调函数）时，使用箭头函数，如果一个函数逻辑复杂，应该把它单独写入一个命名函数里。</p><p>如果函数体是一个没有副作用的表达式语句组成，就删除大括号和 return。</p><p>如果表达式包含多行就包裹在圆括号里面。</p><p>箭头函数的参数用圆括号包裹起来。</p><p>避免箭头函数和大于等于、小于等于号混淆。</p><h3 id="类与构造函数" tabindex="-1"><a class="header-anchor" href="#类与构造函数"><span>类与构造函数</span></a></h3><p>使用 class 语法，避免操作原型对象。</p><p>使用 extends 实现继承。</p><p>方法可以返回 this 实现链式调用。</p><p>空构造函数或只是代表父类的构造函数是不需要写的。</p><p>避免重复定义类成员。</p><p>除非外部库或框架需要使用特定的非静态方法，否则类方法应该使用 this 或被写成静态方法。</p><p>派生类需要调用 super。</p><p>构造器禁止 return。</p><h3 id="模块" tabindex="-1"><a class="header-anchor" href="#模块"><span>模块</span></a></h3><p>使用 export、import 导出、导入模块。</p><p>不要使用 import 通配符。</p><p>一个文件中的多个模块在一个 import 语句中引入。</p><p>不要导出可变的东西。</p><p>如果一个文件只导出一个模块，使用 default。</p><p>import 语句要放在所有语句之前。</p><p>多行的 import 应该缩进。</p><h3 id="迭代器与生成器" tabindex="-1"><a class="header-anchor" href="#迭代器与生成器"><span>迭代器与生成器</span></a></h3><p>不要用迭代器而是使用 <code>for-in</code>、<code>for-of</code>。</p><p>不使用生成器。因为无法很好的转为 ES5。</p><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性"><span>属性</span></a></h3><p>访问属性使用点符号，如果是变量获取属性使用方括号。</p><p>幂运算使用 <code>**</code> 运算符。</p><h3 id="变量" tabindex="-1"><a class="header-anchor" href="#变量"><span>变量</span></a></h3><p>使用 const 或 let 声明变量。</p><p>不要使用链式声明对象。</p><p>不要使用一元自增自减运算符。</p><p>赋值的时候避免在等号前后换行，如果等号右边太长可以用圆括号包裹起来。</p><p>变量如果不使用就不要声明。</p><h3 id="比较运算符与相等" tabindex="-1"><a class="header-anchor" href="#比较运算符与相等"><span>比较运算符与相等</span></a></h3><p>用严格相等和严格不等进行判断。</p><p>if 语句使用 ToBoolean 抽象方法来计算表达式，规则：</p><ul><li>Objects 计算成 true。</li><li>undefined 计算为 false。</li><li>null 计算为 false。</li><li>+0、-0、NaN 计算为 false。</li><li>空字符串（不包含纯空格字符串）计算为 false。</li></ul><h3 id="控制语句" tabindex="-1"><a class="header-anchor" href="#控制语句"><span>控制语句</span></a></h3><p>当控制语句中的条件太长时要换行，每个条件一行，逻辑运算符放在行首。</p><h3 id="注释" tabindex="-1"><a class="header-anchor" href="#注释"><span>注释</span></a></h3><p>单行注释放在被注释区域上面，如果注释不是在第一行，那么注释前面就空一行。</p><h3 id="空格" tabindex="-1"><a class="header-anchor" href="#空格"><span>空格</span></a></h3><p>链式调用过长换行时，点符号开头。</p><p>一个代码块后的下一条语句前空一行。</p><p>不要用空白行填充块。</p><p>圆括号、方括号前后不加空格。计算属性要有空格。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-dark:#abb2bf;--shiki-light:#000000;--shiki-dark-bg:#282c34;--shiki-light-bg:#FFFFFF;"><pre class="shiki shiki-themes one-dark-pro light-plus vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">[</span><span style="--shiki-dark:#D19A66;--shiki-light:#098658;">1</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span><span class="space"> </span><span style="--shiki-dark:#D19A66;--shiki-light:#098658;">2</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span><span class="space"> </span><span style="--shiki-dark:#D19A66;--shiki-light:#098658;">3</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>花括号内前后加空格。</p><p>调用函数时函数名和小括号之间不要空格。</p><p>在对象的字面量属性中，键值之间要空格。</p><h3 id="逗号" tabindex="-1"><a class="header-anchor" href="#逗号"><span>逗号</span></a></h3><p>不要前置逗号。</p><p>使用额外的结尾逗号。</p><h3 id="分号" tabindex="-1"><a class="header-anchor" href="#分号"><span>分号</span></a></h3><p>语句末尾加分号。</p><h3 id="类型转换与强制转换" tabindex="-1"><a class="header-anchor" href="#类型转换与强制转换"><span>类型转换与强制转换</span></a></h3><p>数字转换使用 Number，parseInt 转换应该带着基数。</p><p>布尔转换使用两个取反符号：<code>!!</code>。</p><h3 id="get-set-访问器" tabindex="-1"><a class="header-anchor" href="#get-set-访问器"><span>Get-Set 访问器</span></a></h3><p>不要使用属性的访问器函数，可以自定义。、</p><p>如果要使用访问器函数那么 get 和 set 要一起使用。</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3><p>Promise 构造器参数不能是 async。</p><p>if 语句等布尔表达式不能是常量。</p>`,112)]))}const d=s(n,[["render",t]]),c=JSON.parse('{"path":"/codingstyle/docs/javascript.html","title":"JavaScript","lang":"zh-CN","frontmatter":{"description":"JavaScript 引用 所有的赋值都使用 const，如果一定要对参数重新赋值要使用 let 而不是 var。 对象 使用字面值创建对象而不是 new，例如： 使用计算属性名创建动态属性名的对象而不是在对象定义外再创建： 对象方法使用简写形式。 可以简写的属性名要简写，简写的属性要放前面。 属性名不必要加引号就不加。 不要直接调用 Object.p...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-13T01:18:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/codingstyle/docs/javascript.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"JavaScript"}],["meta",{"property":"og:description","content":"JavaScript 引用 所有的赋值都使用 const，如果一定要对参数重新赋值要使用 let 而不是 var。 对象 使用字面值创建对象而不是 new，例如： 使用计算属性名创建动态属性名的对象而不是在对象定义外再创建： 对象方法使用简写形式。 可以简写的属性名要简写，简写的属性要放前面。 属性名不必要加引号就不加。 不要直接调用 Object.p..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-13T01:18:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-13T01:18:18.000Z"}]]},"git":{"createdTime":1640575858000,"updatedTime":1747099098000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"},{"name":"Koston Zhuang","username":"","email":"koston.zhuang@maiscrm.com","commits":1}]},"readingTime":{"minutes":5.04,"words":1512},"filePathRelative":"codingstyle/docs/javascript.md","excerpt":"\\n<h2>引用</h2>\\n<p>所有的赋值都使用 const，如果一定要对参数重新赋值要使用 let 而不是 var。</p>","autoDesc":true}');export{d as comp,c as data};
