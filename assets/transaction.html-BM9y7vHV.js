import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as i,o as l}from"./app-UKhqlS50.js";const o={};function n(r,e){return l(),a("div",null,e[0]||(e[0]=[i('<h1 id="事务的基本特性及隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的基本特性及隔离级别"><span>事务的基本特性及隔离级别</span></a></h1><h2 id="acid" tabindex="-1"><a class="header-anchor" href="#acid"><span>ACID</span></a></h2><ul><li>原子性</li><li>一致性：数据库总是从一个一致性状态转换到另外一个一致性的状态</li><li>隔离性：一个事务在最终提交前对其他事务不可见</li><li>持久性：事务一旦提交，所做的修改会永久的保存到数据库中</li></ul><h2 id="四个隔离级别" tabindex="-1"><a class="header-anchor" href="#四个隔离级别"><span>四个隔离级别</span></a></h2><ul><li>读未提交：</li></ul><p>可能会读到其他事务未提交的数据，也叫<strong>脏读</strong>。</p><ul><li>读已提交：</li></ul><p>两次读取结果不同，叫做<strong>不可重复读</strong>。</p><p>不可重复读解决了脏读的问题，只会读取已经提交的事务</p><ul><li>可重复读：</li></ul><p>MySQL 默认级别，每次读取结果都一样，但有可能产生幻读。</p><ul><li>串行：</li></ul><p>一般不使用，会给每一行读取的数据加锁，导致大量超时和锁竞争问题。</p><h2 id="acid-由何保证" tabindex="-1"><a class="header-anchor" href="#acid-由何保证"><span>ACID 由何保证</span></a></h2><ul><li>原子性：由 undo log 保证，记录了要回滚的日志信息，事务回滚是撤销已经执行成功的 SQL。</li><li>一致性：由其他三大特性保证、程序代码要保证业务上的一致性。</li><li>隔离性：由 MVCC 来保证。</li><li>持久性：由内存+redo log 来保证，MySQL 修改数据同时要在内存和 redo log 记录这次操作，宕机时可以从 redo log 恢复。</li></ul><h2 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc"><span>MVCC</span></a></h2><p><strong>多版本并发控制</strong>：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务会话会看到自己特定版本的数据。</p><p>MVCC 只在读已提交和可重复读两个隔离级别下工作。</p><p>开始事务时创建 readview，readview 维护当前活动的事务 ID，即未提交的事务 ID，排序生成一个数组，访问数据，获取数据中的事务 ID，获取的是事务ID最大的记录，对比 readview：</p><ul><li>如果在 readview 左边，说明该事务已提交，可以访问。</li><li>如果在 readview 右边或者就在 readview 中间，说明该事务未提交，不可以访问，根据 roll_pointer 取上一版本重新对比。</li></ul><p>读已提交级别下的事务在每次查询的开始都会生成一个独立的 ReadView，而可重复读级别则在第一次读的时候生成一个 ReadView，之后读都复用之前的 ReadView。</p>',21)]))}const d=t(o,[["render",n]]),s=JSON.parse('{"path":"/javaknowledge/docs/transaction.html","title":"事务的基本特性及隔离级别","lang":"zh-CN","frontmatter":{"description":"事务的基本特性及隔离级别 ACID 原子性 一致性：数据库总是从一个一致性状态转换到另外一个一致性的状态 隔离性：一个事务在最终提交前对其他事务不可见 持久性：事务一旦提交，所做的修改会永久的保存到数据库中 四个隔离级别 读未提交： 可能会读到其他事务未提交的数据，也叫脏读。 读已提交： 两次读取结果不同，叫做不可重复读。 不可重复读解决了脏读的问题，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事务的基本特性及隔离级别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-12-28T13:51:24.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/javaknowledge/docs/transaction.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"事务的基本特性及隔离级别"}],["meta",{"property":"og:description","content":"事务的基本特性及隔离级别 ACID 原子性 一致性：数据库总是从一个一致性状态转换到另外一个一致性的状态 隔离性：一个事务在最终提交前对其他事务不可见 持久性：事务一旦提交，所做的修改会永久的保存到数据库中 四个隔离级别 读未提交： 可能会读到其他事务未提交的数据，也叫脏读。 读已提交： 两次读取结果不同，叫做不可重复读。 不可重复读解决了脏读的问题，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2021-12-28T13:51:24.000Z"}],["meta",{"property":"article:modified_time","content":"2021-12-28T13:51:24.000Z"}]]},"git":{"createdTime":1640699484000,"updatedTime":1640699484000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"}]},"readingTime":{"minutes":1.98,"words":595},"filePathRelative":"javaknowledge/docs/transaction.md","excerpt":"\\n<h2>ACID</h2>\\n<ul>\\n<li>原子性</li>\\n<li>一致性：数据库总是从一个一致性状态转换到另外一个一致性的状态</li>\\n<li>隔离性：一个事务在最终提交前对其他事务不可见</li>\\n<li>持久性：事务一旦提交，所做的修改会永久的保存到数据库中</li>\\n</ul>","autoDesc":true}');export{d as comp,s as data};
