import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as i,o as l}from"./app-rQI8KFp-.js";const n={};function r(o,a){return l(),t("div",null,a[0]||(a[0]=[i('<h1 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h1><h2 id="短小" tabindex="-1"><a class="header-anchor" href="#短小"><span>短小</span></a></h2><ul><li>函数不应该大到足以容纳嵌套结构。</li><li>函数的缩进层级不该多于一层或两层。</li></ul><h2 id="只做一件事" tabindex="-1"><a class="header-anchor" href="#只做一件事"><span>只做一件事</span></a></h2><ul><li>要判断函数是否不止做了一件事，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现。</li><li>只做一件事的函数无法被合理地切分为多个区段。</li></ul><h2 id="每个函数一个抽象层级" tabindex="-1"><a class="header-anchor" href="#每个函数一个抽象层级"><span>每个函数一个抽象层级</span></a></h2><ul><li>保证同一个函数中的方法抽象程度的相近，从高度抽象慢慢向下到具体实现，这样就能实现代码自顶向下阅读。</li></ul><h2 id="使用描述性的名称" tabindex="-1"><a class="header-anchor" href="#使用描述性的名称"><span>使用描述性的名称</span></a></h2><ul><li>名称不必担心太长，要使名称中的多个单词容易读。</li><li>函数名应当是动词名词的形式，解释函数的作用。</li><li>命名方式要保持一致，近义词选定一个就不应再使用其它。</li></ul><h2 id="函数参数" tabindex="-1"><a class="header-anchor" href="#函数参数"><span>函数参数</span></a></h2><ul><li>参数列表不宜过长。</li><li>参数越多测试越复杂。</li><li>如果一个函数的逻辑收到参数中某个标志的影响，那么应当拆分这个函数，去掉这个标记。</li><li>多元函数要注意参数的顺序，或者想方法变回一元函数。</li><li>当函数的参数过多时，应当考虑将参数封装成对象。</li></ul><h2 id="无副作用" tabindex="-1"><a class="header-anchor" href="#无副作用"><span>无副作用</span></a></h2><ul><li>函数的实际行为应当与名字描述的一致，不应当有其他行为。</li><li>如果一个函数必须要改变一下东西，那么就修改它所拥有的属性即可。</li></ul><h2 id="分隔指令与询问" tabindex="-1"><a class="header-anchor" href="#分隔指令与询问"><span>分隔指令与询问</span></a></h2><p>一个函数要么做什么事，要么回答什么事，不要既回答（返回值）又去做事（修改），这回导致歧义。</p><h2 id="使用异常替代返回错误码" tabindex="-1"><a class="header-anchor" href="#使用异常替代返回错误码"><span>使用异常替代返回错误码</span></a></h2><ul><li>当遇到错误时，不应当立即在逻辑中处理，抛出异常在异常处理中集中处理，将错误处理代码从主路径代码中抽离出来。</li><li>try、catch代码块可以从一个函数中提取出来单独组成一个函数。</li><li>使用异常可以避免使用错误枚举类，在扩展时只要扩展异常类即可。</li></ul><h2 id="别重复自己" tabindex="-1"><a class="header-anchor" href="#别重复自己"><span>别重复自己</span></a></h2><ul><li>当一个算法在多个方法中都被使用时，如果需要修改算法就需要修改多个方法，应当将重复的部分抽离出来。</li></ul><h2 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span>其它</span></a></h2><ul><li>goto只有在大函数中才有意义，小函数避免使用。</li><li>不必试图在最开始就将所有代码设计的完美无缺，编写完后再仔细打磨。</li></ul>',21)]))}const h=e(n,[["render",r]]),p=JSON.parse('{"path":"/clean-code/docs/function.html","title":"函数","lang":"zh-CN","frontmatter":{"description":"函数 短小 函数不应该大到足以容纳嵌套结构。 函数的缩进层级不该多于一层或两层。 只做一件事 要判断函数是否不止做了一件事，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现。 只做一件事的函数无法被合理地切分为多个区段。 每个函数一个抽象层级 保证同一个函数中的方法抽象程度的相近，从高度抽象慢慢向下到具体实现，这样就能实现代码自顶向下阅读...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-12-26T13:38:59.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/clean-code/docs/function.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"函数"}],["meta",{"property":"og:description","content":"函数 短小 函数不应该大到足以容纳嵌套结构。 函数的缩进层级不该多于一层或两层。 只做一件事 要判断函数是否不止做了一件事，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现。 只做一件事的函数无法被合理地切分为多个区段。 每个函数一个抽象层级 保证同一个函数中的方法抽象程度的相近，从高度抽象慢慢向下到具体实现，这样就能实现代码自顶向下阅读..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2021-12-26T13:38:59.000Z"}],["meta",{"property":"article:modified_time","content":"2021-12-26T13:38:59.000Z"}]]},"git":{"createdTime":1640525939000,"updatedTime":1640525939000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"}]},"readingTime":{"minutes":2.17,"words":652},"filePathRelative":"clean-code/docs/function.md","excerpt":"\\n<h2>短小</h2>\\n<ul>\\n<li>函数不应该大到足以容纳嵌套结构。</li>\\n<li>函数的缩进层级不该多于一层或两层。</li>\\n</ul>","autoDesc":true}');export{h as comp,p as data};
