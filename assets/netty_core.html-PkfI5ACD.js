import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as a,o as t}from"./app-rQI8KFp-.js";const s="/assets/image-20210814150823204-D76wFM8v.png",l="/assets/image-20210814151859777-C_DI31CK.png",h={};function p(r,e){return t(),i("div",null,e[0]||(e[0]=[a(`<h1 id="netty核心模块" tabindex="-1"><a class="header-anchor" href="#netty核心模块"><span>Netty核心模块</span></a></h1><h2 id="bootstrap、serverbootstrap" tabindex="-1"><a class="header-anchor" href="#bootstrap、serverbootstrap"><span>Bootstrap、ServerBootstrap</span></a></h2><p>Bootstrap 是<em>客户端</em>的启动引导类，ServerBootstrap 是<em>服务端</em>的启动引导类。</p><p>常用方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-dark:#abb2bf;--shiki-light:#000000;--shiki-dark-bg:#282c34;--shiki-light-bg:#FFFFFF;"><pre class="shiki shiki-themes one-dark-pro light-plus vp-code"><code class="language-java"><span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">group</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">(bossGroup</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">workerGroup)</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//用于服务端指定两个EventLoopGroup</span></span>
<span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">group</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">(eventGroup)</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//用于客户端设置一个EventLoopGroup</span></span>
<span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">channel</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">(</span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">NioServerSocketChannel</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">class</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">)</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//用于服务端指定服务端channel或客户端指定客户端channel类型</span></span>
<span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">option</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">(</span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">ChannelOption</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">SO_BACKLOG</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span><span style="--shiki-dark:#D19A66;--shiki-light:#098658;">128</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">)</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//给自己的channel添加配置</span></span>
<span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">childOption</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">(</span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">ChannelOption</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">SO_KEEPALIVE</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span><span style="--shiki-dark:#D19A66;--shiki-light:#0000FF;">true</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">)</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//给接收到的channel添加配置</span></span>
<span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">childHandler</span><span style="--shiki-dark:#E06C75;--shiki-light:#000000;">()</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//添加自定义handler</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">serverBootstrap</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">bind</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">()</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//用于服务端，绑定监听端口号</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">bootstrap</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">connect</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">()</span><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#008000;--shiki-light-font-style:inherit;">//用于客户端连接服务端</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="future、channelfuture" tabindex="-1"><a class="header-anchor" href="#future、channelfuture"><span>Future、ChannelFuture</span></a></h2><p>Netty 中 I/O 操作都是异步的，不能立刻得知消息是否正确处理，通过 Future、ChannelFuture 注册监听回调获取执行结果。</p><h2 id="channel" tabindex="-1"><a class="header-anchor" href="#channel"><span>Channel</span></a></h2><p>支持关联 I/O 操作与对应的处理程序。</p><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 与之对应，常用的 Channel 类型：</p><ul><li>NioSocketChannel：异步的客户端 TCP Socket 连接。</li><li>NioServerSocketChannel：异步的服务端 TCP Socket 连接。</li><li>NioDatagramChannel：异步的 UDP 连接。</li><li>NioSctpChannel：异步的客户端 Sctp 连接。</li><li>NioSctpServerChannel：异步的服务端 Sctp 连接。</li></ul><h2 id="selector" tabindex="-1"><a class="header-anchor" href="#selector"><span>Selector</span></a></h2><p>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</p><p>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select)这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel。</p><h2 id="channelhandler-及其实现类" tabindex="-1"><a class="header-anchor" href="#channelhandler-及其实现类"><span>ChannelHandler 及其实现类</span></a></h2><p>ChannelHandler 是一个接口，处理 I/О 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</p><p>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类。</p><p><img src="`+s+'" alt="image-20210814150823204"></p><ul><li>ChannelInboundHandler：处理入站 I/O 事件。</li><li>ChannelOutboundHandler：处理出站 I/O 操作。</li><li>ChannelInboundHandlerAdapter：处理入站 I/O 事件。</li><li>ChannelOutboundHandlerAdapter：处理出站 I/O 操作。</li><li>ChannelDuplexHandler：用于处理入站和出站事件。</li></ul><h2 id="pipeline-和-channelpipeline" tabindex="-1"><a class="header-anchor" href="#pipeline-和-channelpipeline"><span>Pipeline 和 ChannelPipeline</span></a></h2><p>ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链(也可以这样理解:ChannelPipeline 是保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作)。</p><p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。</p><p><img src="'+l+'" alt="image-20210814151859777"></p><p>一个 Channel 包含了一个ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 channelHandlerContext 中又关联着一个 channelHandler 入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler,出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p><h2 id="channelhandlercontext" tabindex="-1"><a class="header-anchor" href="#channelhandlercontext"><span>ChannelHandlerContext</span></a></h2><p>保存 Channel 相关所有上下文信息，同时关联一个 ChannelHandler 对象。</p><p>即 ChannelHandlerContext 中包含了一个具体的事件处理器 ChannelHandler 同时 ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 信息。</p><h2 id="channeloption" tabindex="-1"><a class="header-anchor" href="#channeloption"><span>ChannelOption</span></a></h2><p>SO_BACKLOG：</p><p>对应 TCP/IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小，多个请求到来时，服务端一次处理一个，把暂时没处理的放入队列。</p><p>SO_KEETALIVE：</p><p>一直保持连接活动状态，布尔值。</p><h2 id="eventloopgroup-及其实现类-nioeventloopgroup" tabindex="-1"><a class="header-anchor" href="#eventloopgroup-及其实现类-nioeventloopgroup"><span>EventLoopGroup 及其实现类 NioEventLoopGroup</span></a></h2><p>EventLoopGroup 是一组 EventLoop 的抽象,Netty 为了更好的利用多核 CPU 资源一般会有多个 EventLoop 同时工作,每个 EventLoop 维护着一个 Selector 实例。</p><p>EventLoopGroup 提供 next 接口,可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。在 Netty 服务器端编程中,我们一般都需要提供两个 EventLoopGroup,例如: BossEventLoopGroup 和 WorkerEventLoopGroup。</p><p>通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个 EventLoop 线程。 BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 I/O 处理。</p><p>BossEventLoopGroup 通常是一个单线程的 EventLoop, EventLoop 维护着一个注册了 ServerSocketChannel 的 Selector 实例 BossEventLoop 不断轮询 Selector 将连接事件分离出来。</p><p>通常是 OP_ACCEPT 事件,然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup。</p><p>WorkerGroup 会由 next 选择其中一个 EventLoop 来将这个 SocketChannel 注册到其维护的 Selector 并对其后续的 I/O 事件进行处理。</p><h2 id="unpooled-类" tabindex="-1"><a class="header-anchor" href="#unpooled-类"><span>Unpooled 类</span></a></h2><p>Netty 提供的一个专门用来操作缓冲区的工具类，用来将字符串、整数等值转化为 Netty 中的 <code>ByteBuf</code>。</p>',41)]))}const d=n(h,[["render",p]]),c=JSON.parse('{"path":"/netty/docs/netty_core.html","title":"Netty核心模块","lang":"zh-CN","frontmatter":{"description":"Netty核心模块 Bootstrap、ServerBootstrap Bootstrap 是客户端的启动引导类，ServerBootstrap 是服务端的启动引导类。 常用方法： Future、ChannelFuture Netty 中 I/O 操作都是异步的，不能立刻得知消息是否正确处理，通过 Future、ChannelFuture 注册监听回调...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Netty核心模块\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-13T01:18:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/netty/docs/netty_core.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"Netty核心模块"}],["meta",{"property":"og:description","content":"Netty核心模块 Bootstrap、ServerBootstrap Bootstrap 是客户端的启动引导类，ServerBootstrap 是服务端的启动引导类。 常用方法： Future、ChannelFuture Netty 中 I/O 操作都是异步的，不能立刻得知消息是否正确处理，通过 Future、ChannelFuture 注册监听回调..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-13T01:18:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-13T01:18:18.000Z"}]]},"git":{"createdTime":1640859910000,"updatedTime":1747099098000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"},{"name":"Koston Zhuang","username":"","email":"koston.zhuang@maiscrm.com","commits":2}]},"readingTime":{"minutes":3.93,"words":1178},"filePathRelative":"netty/docs/netty_core.md","excerpt":"\\n<h2>Bootstrap、ServerBootstrap</h2>","autoDesc":true}');export{d as comp,c as data};
