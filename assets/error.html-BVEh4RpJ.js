import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as r,o as n}from"./app-UKhqlS50.js";const c={};function p(h,a){return n(),t("div",null,a[0]||(a[0]=[r('<h1 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理"><span>错误处理</span></a></h1><h2 id="使用异常而非返回码" tabindex="-1"><a class="header-anchor" href="#使用异常而非返回码"><span>使用异常而非返回码</span></a></h2><p>如果使用返回码供检查错误，它们会扰乱调用者的代码，调用者必须在调用之后立刻检查错误，所以遇到错误时，最好抛出一个异常，调用者的代码不会被扰乱。</p><h2 id="先写-try-catch-finally-语句" tabindex="-1"><a class="header-anchor" href="#先写-try-catch-finally-语句"><span>先写 Try-Catch-Finally 语句</span></a></h2><p>try 代码块表明是可以随时取消执行的，并在 catch 语句中接续。try 代码块就像是事务。catch 代码块将程序维持在一种持续状态，无论 try 代码块中发生了什么，这能定义代码的用户应该期待什么。</p><h2 id="使用不可控异常" tabindex="-1"><a class="header-anchor" href="#使用不可控异常"><span>使用不可控异常</span></a></h2><p>可控异常：每个方法的签名都列出它可能传递给调用者的异常。</p><p>可控异常违背了开放-封闭原则，如果在一个方法中抛出了可控异常，将影响到较高层级的方法签名，修改好的模块必须重新构建。</p><p>如果是编写一套关键代码库，则可控异常有时也会有用：必须捕获异常。但对于一般的应用开发，其依赖成本要高于收益。</p><h2 id="给出异常发生的环境说明" tabindex="-1"><a class="header-anchor" href="#给出异常发生的环境说明"><span>给出异常发生的环境说明</span></a></h2><p>抛出的每个异常都应当提供足够的环境说明，以便判断错误的来源和出处。</p><h2 id="依调用者需要定义异常类" tabindex="-1"><a class="header-anchor" href="#依调用者需要定义异常类"><span>依调用者需要定义异常类</span></a></h2><p>处理异常时可能出现很多重复代码，需要对每个异常单独处理，可以对所有的异常进行打包成一个类，根据异常的信息区分不同的错误，如果是将第三方API打包，可以降低与这个代码库的耦合度。</p><h2 id="定义常规流程" tabindex="-1"><a class="header-anchor" href="#定义常规流程"><span>定义常规流程</span></a></h2><p>异常如果打断了业务逻辑，可以使用<em>特例模式</em>，创建一个类或配置一个对象用来处理特例，异常行为被封装到特例对象中。</p><h2 id="别返回-null-值" tabindex="-1"><a class="header-anchor" href="#别返回-null-值"><span>别返回 null 值</span></a></h2><p>如果返回了 null 值，在调用这个方法的时候必须时刻注意 null 值的判断，一旦忘记进行捕获，可能造成影响。在没有必要返回 null 值的时候，可以返回值为空的对象。</p><h2 id="别传递-null-值" tabindex="-1"><a class="header-anchor" href="#别传递-null-值"><span>别传递 null 值</span></a></h2><p>除非 API 要求向它传递 null 值，否则就要尽量避免传递 null 值。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>整洁代码是可读的，但也要强固。可读与强固并不冲突。如果将错误处理隔离看待，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它，也极大地提升了代码的可维护性。</p>',21)]))}const l=e(c,[["render",p]]),i=JSON.parse('{"path":"/clean-code/docs/error.html","title":"错误处理","lang":"zh-CN","frontmatter":{"description":"错误处理 使用异常而非返回码 如果使用返回码供检查错误，它们会扰乱调用者的代码，调用者必须在调用之后立刻检查错误，所以遇到错误时，最好抛出一个异常，调用者的代码不会被扰乱。 先写 Try-Catch-Finally 语句 try 代码块表明是可以随时取消执行的，并在 catch 语句中接续。try 代码块就像是事务。catch 代码块将程序维持在一种持...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"错误处理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-12-26T13:38:59.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/clean-code/docs/error.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"错误处理"}],["meta",{"property":"og:description","content":"错误处理 使用异常而非返回码 如果使用返回码供检查错误，它们会扰乱调用者的代码，调用者必须在调用之后立刻检查错误，所以遇到错误时，最好抛出一个异常，调用者的代码不会被扰乱。 先写 Try-Catch-Finally 语句 try 代码块表明是可以随时取消执行的，并在 catch 语句中接续。try 代码块就像是事务。catch 代码块将程序维持在一种持..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2021-12-26T13:38:59.000Z"}],["meta",{"property":"article:modified_time","content":"2021-12-26T13:38:59.000Z"}]]},"git":{"createdTime":1640525939000,"updatedTime":1640525939000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"}]},"readingTime":{"minutes":2.22,"words":666},"filePathRelative":"clean-code/docs/error.md","excerpt":"\\n<h2>使用异常而非返回码</h2>\\n<p>如果使用返回码供检查错误，它们会扰乱调用者的代码，调用者必须在调用之后立刻检查错误，所以遇到错误时，最好抛出一个异常，调用者的代码不会被扰乱。</p>","autoDesc":true}');export{l as comp,i as data};
