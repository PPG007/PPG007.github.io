import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as e,o as t}from"./app-rQI8KFp-.js";const n={};function p(l,i){return t(),a("div",null,i[0]||(i[0]=[e(`<h1 id="面向对象编程" tabindex="-1"><a class="header-anchor" href="#面向对象编程"><span>面向对象编程</span></a></h1><h2 id="实例对象与-new-命令" tabindex="-1"><a class="header-anchor" href="#实例对象与-new-命令"><span>实例对象与 new 命令</span></a></h2><p>new 命令的工作流程：</p><ul><li>创建一个空对象，作为要返回的对象实例。</li><li>将这个空对象的原型指向构造函数的 prototype 属性。</li><li>将这个空对象赋值给函数内部的 this 关键字。</li><li>开始执行构造函数内部的代码。</li></ul><p>如果构造函数内部存在 return 语句，而且返回的是一个对象，new 命令会返回 return 指定的对象，否则就会不管 return 语句而返回 this。</p><p>函数内部可以使用 <code>new.target</code> 属性，如果当前函数是 new 命令调用，这个属性会指向当前函数，否则返回 undefined。</p><p>如果希望从现有对象作为模板创建新的实例对象可以使用 <code>Object.create()</code> 方法。</p><h2 id="this-关键字" tabindex="-1"><a class="header-anchor" href="#this-关键字"><span>this 关键字</span></a></h2><p>this 就是属性或方法“当前”所在的对象。</p><p>内层的 this 不指向外部，而是指向顶层对象。</p><p>this 的几个使用场合：</p><ul><li>全局环境，指向顶层对象 window。</li><li>构造函数，指的是实例对象。</li><li>对象的方法，指的是方法运行时所在的对象</li></ul><p>注意点：</p><ul><li>避免多层 this，使用一个变量固定 this 的值然后内层函数调用这个变量。</li><li>避免数组处理方法中的 this。</li><li>避免回调函数中的 this。</li></ul><p>绑定 this 的方法：</p><ul><li>函数实例 call 方法，传入一个对象做参数，如果参数为空、null 或 undefined，则默认传入全局对象；如果参数是一个原始值则会转成包装对象，然后再传入 call 方法。call 方法可以接受多个参数，第一个参数做 this，后面的参数是函数调用时的参数。</li><li>函数实例 apply 方法，第一个参数是 this 的指向，如果设为 null 或 undefined 等同于全局对象；第二个参数是一个数组，该数组的成员依次传入原函数。</li><li>函数实例的 bind 方法，将函数体内的 this 绑定到某个对象然后返回一个新函数，参数就是所要绑定 this 的对象，可以接受更多参数绑定原函数的参数。</li></ul><h2 id="对象的继承" tabindex="-1"><a class="header-anchor" href="#对象的继承"><span>对象的继承</span></a></h2><p>原型对象 prototype：</p><p>每个原型对象都有一个 prototype 属性，指向一个对象，对于构造函数，生成实例的时候，该属性会自动成为实例对象的原型。</p><p>原型对象的作用就是定义所有实例对象共享的属性和方法，实例对象可以看作从原型对象衍生出来的子对象。</p><p>修改原型对象时一般要同时修改 constructor 属性的指向，指向原来的构造函数。</p><p>继承的步骤：</p><ul><li><p>在子类构造函数中调用父类的构造函数。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-dark:#abb2bf;--shiki-light:#000000;--shiki-dark-bg:#282c34;--shiki-light-bg:#FFFFFF;"><pre class="shiki shiki-themes one-dark-pro light-plus vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#0000FF;">function</span><span class="space"> </span><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">Dog</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">(</span><span style="--shiki-dark:#E06C75;--shiki-dark-font-style:italic;--shiki-light:#001080;--shiki-light-font-style:inherit;">name</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">)</span><span class="space"> </span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">Animal</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">call</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">(</span><span style="--shiki-dark:#E5C07B;--shiki-light:#0000FF;">this</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">,</span><span class="space"> </span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">name</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">);</span></span>
<span class="line"><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>让子类的原型指向父类的原型</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-dark:#abb2bf;--shiki-light:#000000;--shiki-dark-bg:#282c34;--shiki-light-bg:#FFFFFF;"><pre class="shiki shiki-themes one-dark-pro light-plus vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#267F99;">Dog</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">prototype</span><span class="space"> </span><span style="--shiki-dark:#56B6C2;--shiki-light:#000000;">=</span><span class="space"> </span><span style="--shiki-dark:#E5C07B;--shiki-light:#001080;">Object</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#61AFEF;--shiki-light:#795E26;">create</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">(</span><span style="--shiki-dark:#E5C07B;--shiki-light:#267F99;">Animal</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">prototype</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">);</span></span>
<span class="line"><span style="--shiki-dark:#E5C07B;--shiki-light:#267F99;">Dog</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">prototype</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">.</span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">constructor</span><span class="space"> </span><span style="--shiki-dark:#56B6C2;--shiki-light:#000000;">=</span><span class="space"> </span><span style="--shiki-dark:#E06C75;--shiki-light:#001080;">Dog</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#000000;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>或者直接将子类的原型对象指向一个父类实例。</p><h2 id="object-对象的相关方法" tabindex="-1"><a class="header-anchor" href="#object-对象的相关方法"><span>Object 对象的相关方法</span></a></h2><ul><li>Object.getPrototypeOf()：返回参数对象的原型。</li><li>Object.setPrototypeOf()：为参数对象设置原型，返回该参数对象，接受两个参数，第一个是现有对象，第二个是原型对象。</li><li>Object.create()：通过一个现有的实例对象生成另一个实例对象。</li><li>isPrototypeOf()：判断一个对象是否是参数对象的原型。</li><li><code>__proto__</code>：返回一个对象的原型，可读可写。</li><li>getOwnPropertyNames()：返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的键名。</li><li>hasOwnProperty()：返回一个布尔值，用于判断某个属性定义在对象自身还是定义在原型链上。</li></ul>`,26)]))}const o=s(n,[["render",p]]),c=JSON.parse('{"path":"/javascript/docs/oop.html","title":"面向对象编程","lang":"zh-CN","frontmatter":{"description":"面向对象编程 实例对象与 new 命令 new 命令的工作流程： 创建一个空对象，作为要返回的对象实例。 将这个空对象的原型指向构造函数的 prototype 属性。 将这个空对象赋值给函数内部的 this 关键字。 开始执行构造函数内部的代码。 如果构造函数内部存在 return 语句，而且返回的是一个对象，new 命令会返回 return 指定的对...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-13T01:18:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/javascript/docs/oop.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"面向对象编程"}],["meta",{"property":"og:description","content":"面向对象编程 实例对象与 new 命令 new 命令的工作流程： 创建一个空对象，作为要返回的对象实例。 将这个空对象的原型指向构造函数的 prototype 属性。 将这个空对象赋值给函数内部的 this 关键字。 开始执行构造函数内部的代码。 如果构造函数内部存在 return 语句，而且返回的是一个对象，new 命令会返回 return 指定的对..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-13T01:18:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-13T01:18:18.000Z"}]]},"git":{"createdTime":1640441337000,"updatedTime":1747099098000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"},{"name":"Koston Zhuang","username":"","email":"koston.zhuang@maiscrm.com","commits":1}]},"readingTime":{"minutes":3.08,"words":923},"filePathRelative":"javascript/docs/oop.md","excerpt":"\\n<h2>实例对象与 new 命令</h2>\\n<p>new 命令的工作流程：</p>","autoDesc":true}');export{o as comp,c as data};
