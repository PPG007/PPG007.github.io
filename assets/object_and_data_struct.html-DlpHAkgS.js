import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as o,o as n}from"./app-UKhqlS50.js";const r={};function i(c,t){return n(),a("div",null,t[0]||(t[0]=[o('<h1 id="对象和数据结构" tabindex="-1"><a class="header-anchor" href="#对象和数据结构"><span>对象和数据结构</span></a></h1><h2 id="数据抽象" tabindex="-1"><a class="header-anchor" href="#数据抽象"><span>数据抽象</span></a></h2><p>代码不应当暴露实现，通过提供更加抽象的形态表述数据。</p><h2 id="数据、对象的反对称性" tabindex="-1"><a class="header-anchor" href="#数据、对象的反对称性"><span>数据、对象的反对称性</span></a></h2><ul><li>过程式代码难以添加新的数据结构，因为需要修改所有函数。</li><li>面向对象代码难以添加新函数，因为必须修改所有类。</li></ul><h2 id="迪米特法则" tabindex="-1"><a class="header-anchor" href="#迪米特法则"><span>迪米特法则</span></a></h2><ul><li>迪米特法则：模块不应了解它所操作对象的内部情形。</li><li>对象不应通过存取器暴露内部结构。</li><li>如果是数据结构，那么其中的变量自然会暴露内部结构，迪米特法则也就不适用了。</li></ul><h2 id="数据传送对象-只有公共变量、没有函数的类dto" tabindex="-1"><a class="header-anchor" href="#数据传送对象-只有公共变量、没有函数的类dto"><span>数据传送对象：只有公共变量、没有函数的类DTO</span></a></h2><p>这类数据结构不应该被塞入业务规则方法。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。</li><li>数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。</li><li>在任何系统中，我们有时会希望能够灵活地添加新数据类型，所以更喜欢在这部分使用对象。</li><li>另外一些时候，我们希望能灵活地添加新行为，这时我们更喜欢使用数据类型和过程。</li></ul>',11)]))}const s=e(r,[["render",i]]),l=JSON.parse('{"path":"/clean-code/docs/object_and_data_struct.html","title":"对象和数据结构","lang":"zh-CN","frontmatter":{"description":"对象和数据结构 数据抽象 代码不应当暴露实现，通过提供更加抽象的形态表述数据。 数据、对象的反对称性 过程式代码难以添加新的数据结构，因为需要修改所有函数。 面向对象代码难以添加新函数，因为必须修改所有类。 迪米特法则 迪米特法则：模块不应了解它所操作对象的内部情形。 对象不应通过存取器暴露内部结构。 如果是数据结构，那么其中的变量自然会暴露内部结构，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"对象和数据结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-12-26T13:38:59.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/clean-code/docs/object_and_data_struct.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"对象和数据结构"}],["meta",{"property":"og:description","content":"对象和数据结构 数据抽象 代码不应当暴露实现，通过提供更加抽象的形态表述数据。 数据、对象的反对称性 过程式代码难以添加新的数据结构，因为需要修改所有函数。 面向对象代码难以添加新函数，因为必须修改所有类。 迪米特法则 迪米特法则：模块不应了解它所操作对象的内部情形。 对象不应通过存取器暴露内部结构。 如果是数据结构，那么其中的变量自然会暴露内部结构，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2021-12-26T13:38:59.000Z"}],["meta",{"property":"article:modified_time","content":"2021-12-26T13:38:59.000Z"}]]},"git":{"createdTime":1640525939000,"updatedTime":1640525939000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"}]},"readingTime":{"minutes":1.23,"words":369},"filePathRelative":"clean-code/docs/object_and_data_struct.md","excerpt":"\\n<h2>数据抽象</h2>\\n<p>代码不应当暴露实现，通过提供更加抽象的形态表述数据。</p>","autoDesc":true}');export{s as comp,l as data};
