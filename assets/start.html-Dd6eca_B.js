import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as s,o as i}from"./app-UKhqlS50.js";const n="/assets/v2-c38c2609bee9a1f9a638a38ef503d604_1440w-DJKhCkD4.jpg",r="/assets/v2-7dfb814e3963cb9cdfdada13f64c703a_1440w-A5_T_fAg.jpg",c="/assets/v2-b05d98e0c85c49fe366ff7f159f6fa91_1440w-CUtwWMj8.jpg",o="/assets/v2-f9793a436f5983c7bac2c9cc7d7abfdb_1440w-Bu0JCBwJ.jpg",p="/assets/v2-b0b81fcf533970cd71d23a85ec266e5b_1440w-CFwWNXjm.jpg",m={};function h(l,a){return i(),e("div",null,a[0]||(a[0]=[s('<h1 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h1><h2 id="什么是-mq" tabindex="-1"><a class="header-anchor" href="#什么是-mq"><span>什么是 MQ</span></a></h2><p>消息队列就是一个转发器，且实现了异步非阻塞与解耦合，消费者不再需要直接面对生产者，也就是说，消息队列解决的还是生产者、消费者的通信问题。</p><p><img src="'+n+'" alt="img"></p><h2 id="消息队列模型的演化" tabindex="-1"><a class="header-anchor" href="#消息队列模型的演化"><span>消息队列模型的演化</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>架构从来不是设计出来的，而是演进而来的。</p></div><h3 id="队列模型" tabindex="-1"><a class="header-anchor" href="#队列模型"><span>队列模型</span></a></h3><p><img src="'+r+'" alt="img"></p><p>这便是队列模型：它允许多个生产者往同一个队列发送消息。但是，如果有多个消费者，实际上是竞争的关系，也就是一条消息只能被其中一个消费者接收到，读完即被删除。</p><h3 id="发布-订阅模型" tabindex="-1"><a class="header-anchor" href="#发布-订阅模型"><span>发布-订阅模型</span></a></h3><p><img src="'+c+'" alt="img"></p><p>在发布-订阅模型中，存放消息的容器变成了 “主题”，订阅者在接收消息之前需要先 “订阅主题”。最终，每个订阅者都可以收到同一个主题的全量消息。生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：一份消息数据是否可以被多次消费。</p><h2 id="mq-的应用场景" tabindex="-1"><a class="header-anchor" href="#mq-的应用场景"><span>MQ 的应用场景</span></a></h2><h3 id="mq-与-rpc" tabindex="-1"><a class="header-anchor" href="#mq-与-rpc"><span>MQ 与 RPC</span></a></h3><p><img src="'+o+'" alt="img"></p><ul><li>引入 MQ 后，由之前的一次 RPC 变成了现在的两次 RPC，而且生产者只跟队列耦合，它根本无需知道消费者的存在。</li><li>多了一个中间节点<em>队列</em>进行消息转储，相当于将同步变成了<strong>异步</strong>。</li></ul><h3 id="举例-订单支付场景" tabindex="-1"><a class="header-anchor" href="#举例-订单支付场景"><span>举例：订单支付场景</span></a></h3><p><img src="'+p+'" alt="img"></p><p>未引入消息队列前，订单支付需要一步一步的调用其他系统完成处理，引入MQ后，只需要聚焦于更新订单状态这一个流程即可，其他事务由MQ通知其他系统，这就完成了<strong>解耦</strong>，而且后续对业务再进行拓展也不涉及订单系统。</p><h2 id="mq-的三大目标" tabindex="-1"><a class="header-anchor" href="#mq-的三大目标"><span>MQ 的三大目标</span></a></h2><ul><li><strong>系统解耦</strong>：当新模块加入时，可以做到代码改动最小</li><li><strong>削峰</strong>：让后端系统按照自身吞吐能力进行消费，不被冲垮</li><li><strong>异步</strong>：将非关键调用链路的操作异步化并提升系统吞吐能力</li></ul><h2 id="mq-的关注点" tabindex="-1"><a class="header-anchor" href="#mq-的关注点"><span>MQ 的关注点</span></a></h2><ul><li>发送和接收。</li><li>高可用。</li><li>集群和容错。</li><li>持久化。</li><li>延时发送/定时投递。</li><li>签收机制。</li></ul>',23)]))}const f=t(m,[["render",h]]),_=JSON.parse('{"path":"/activemq/docs/start.html","title":"基本概念","lang":"zh-CN","frontmatter":{"prev":{"text":"首页","link":"/activemq"},"description":"基本概念 什么是 MQ 消息队列就是一个转发器，且实现了异步非阻塞与解耦合，消费者不再需要直接面对生产者，也就是说，消息队列解决的还是生产者、消费者的通信问题。 img 消息队列模型的演化 提示 架构从来不是设计出来的，而是演进而来的。 队列模型 img 这便是队列模型：它允许多个生产者往同一个队列发送消息。但是，如果有多个消费者，实际上是竞争的关系，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基本概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-08-15T09:32:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://ppg007.github.io/activemq/docs/start.html"}],["meta",{"property":"og:site_name","content":"PPG007 的文档"}],["meta",{"property":"og:title","content":"基本概念"}],["meta",{"property":"og:description","content":"基本概念 什么是 MQ 消息队列就是一个转发器，且实现了异步非阻塞与解耦合，消费者不再需要直接面对生产者，也就是说，消息队列解决的还是生产者、消费者的通信问题。 img 消息队列模型的演化 提示 架构从来不是设计出来的，而是演进而来的。 队列模型 img 这便是队列模型：它允许多个生产者往同一个队列发送消息。但是，如果有多个消费者，实际上是竞争的关系，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-08-15T09:32:39.000Z"}],["meta",{"property":"article:modified_time","content":"2022-08-15T09:32:39.000Z"}]]},"git":{"createdTime":1640575858000,"updatedTime":1660555959000,"contributors":[{"name":"PPG007","username":"PPG007","email":"1658272229@com请求","commits":1,"url":"https://github.com/PPG007"},{"name":"Koston Zhuang","username":"","email":"koston.zhuang@maiscrm.com","commits":1}]},"readingTime":{"minutes":1.99,"words":596},"filePathRelative":"activemq/docs/start.md","excerpt":"\\n<h2>什么是 MQ</h2>\\n<p>消息队列就是一个转发器，且实现了异步非阻塞与解耦合，消费者不再需要直接面对生产者，也就是说，消息队列解决的还是生产者、消费者的通信问题。</p>","autoDesc":true}');export{f as comp,_ as data};
