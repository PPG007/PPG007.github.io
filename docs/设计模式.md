==模式是死的，人是活的，不要过度设计==

# 六大设计原则

### 单一职责原则

Single Responsibility Principle （SRP）

- 定义：**应该有且仅有一个原因引起类的变更**
- 面向接口编程，接口是单一职责的

优点：

1. 类的复杂性降低
2. 可读性提高
3. 可维护性提高
4. 变更引起的风险降低

**方法也要单一职责，例如修改用户名和密码应当是两个方法，而不是一个修改用户信息方法通过传参决定逻辑**

==接口一定要做到单一职责原则，类的设计尽量做到单一职责==

### 里氏替换原则

Liskov Substitution Principle （LSP）

##### 继承

- 继承的优点：
  - 代码共享，减少创建类的工作量
  - 提高代码重用性
  - 子类形似父类但又异于父类
  - 提高代码的可扩展性
  - 提高产品或项目的开放性
- 继承的缺点
  - 继承是侵入性的。只要继承就必须拥有父类所有的属性和方法
  - 降低代码的灵活性。子类必须拥有父类的属性和方法
  - 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改

**里氏替换原则：==所有使用父类的地方必须能够替换成子类且不会出现错误或异常==**

##### 里氏替换原则四层含义

1. 子类必须完全实现父类的方法，如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中发生畸变，建议断开父子继承关系，采用依赖、聚合、组合等关系替代继承
2. 子类可以有自己的个性
3. 覆盖或实现父类的方法时输入的参数可以被放大

父类代码如下：

```java
public class Father {
    public Collection process(HashMap map){
        System.out.println("父类被执行");
        return map.values();
    }
}
```

子类代码如下：

```java
public class Son extends Father{

    public Collection process(Map map){
        System.out.println("子类被执行");
        return map.values();
    }
}
```

子类完成了方法的重载而不是重写，且重载方法放大了参数范围，子类方法列表：

![image-20210831160159572](/设计模式/image-20210831160159572.png)

主函数：

```java
public class Client {
    public static void main(String[] args) {
        Father father = new Father();
        father.process(new HashMap());
        
        Son son = new Son();
        son.process(new HashMap());
    }
}
```

在主函数中的两个process方法都会输出`父类被执行`

如果调转过来，父类参数范围更大：即父类方法接收Map，子类方法接收HashMap，则子类的process方法将会替代继承到的方法被执行，此时方法仍然是重载而不是重写，输出`子类被执行`，这样虽然完成了子类替换，但是效果与父类不同，违背了里氏替换原则

**子类中方法的参数必须与超类中覆写的方法的参数相同或更宽松**

4. 覆写或实现父类的方法时输出的结果可以被缩小

### 依赖倒置原则

Dependence Inversion Principle （DIP）

- 三层含义
  - 高层模块不应该依赖底层模块，两者都应该依赖其抽象
  - 抽象不应依赖细节
  - 细节应该依赖抽象

==面向接口编程==

JMock工具：

```xml
<dependency>
    <groupId>org.jmock</groupId>
    <artifactId>jmock-junit4</artifactId>
    <version>2.12.0</version>
</dependency>
```

测试类：
```java
public class Client {

    JUnit4Mockery jUnit4Mockery = new JUnit4Mockery();

    @Test
    public void test(){
        ICar car = jUnit4Mockery.mock(ICar.class);
        DriverImpl driver = new DriverImpl();
        jUnit4Mockery.checking(new Expectations(){{
            oneOf(car).run();
        }});
        driver.drive(car);
    }
}
```

只需要ICar接口就可以对自己负责编写的Driver类进行单元测试

对象的依赖关系的三种传递方式：

1. 构造函数传递依赖对象
2. Setter方法传递依赖对象
3. 接口声明依赖对象

**依赖倒置原则本质：==通过抽象使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合**

规则：

- 每个类尽量都有接口或抽象类
- 变量的表面类型尽量是接口或抽象类型
- 任何类都不应该从具体类派生
- 尽量不要覆写基类的方法
- 结合里氏替换原则使用

### 接口隔离原则

- 客户端不应该依赖他不需要的接口
- 类间的依赖关系应该建立在最小的接口上

把一个臃肿的接口变更为两个独立的接口，预防未来变更的扩散，提高系统的灵活性和可维护性

##### 接口隔离原则四层含义

1. 接口要尽量小，但是不违背单一职责原则
2. 接口要高内聚，减少对外的交互
3. 定制服务，为指定的个体提供不同的接口
4. 接口的设计是有限度的

**接口和类尽量使用原子接口或原子类来组装**

原子划分规则：

- 一个接口只服务于一个子模块或业务逻辑
- 通过业务逻辑压缩接口中的public方法
- 已经被污染的接口尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理
- 了解环境，拒绝盲从

### 迪米特法则

Law of Demeter （LoD）也被称为最少知识原则（Least Knowledge Principle，LKP）

==一个对象应该对其他对象有最少的了解==

##### 只和朋友交流

出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类

##### 朋友间是有距离的

朋友类中的public方法不应在其他类中被多次调用，应该修改方法权限且将方法的组合封装为一个新方法

##### 是自己的就是自己的

如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中

##### 谨慎使用Serializable

### 开闭原则

==一个软件实体如类、模块和函数应该对扩展开放，对修改关闭==

##### 为什么要采用开闭原则

1. 开闭原则对测试的影响：只需要孤立测试就可以测试正确性
2. 开闭原则可以提高复用性
3. 开闭原则可以提高可维护性
4. 面向对象开发的要求：设计之初考虑所有可能变化的因素，留下接口

##### 如何使用开闭原则

1. 抽象约束
   1. 通过接口或抽象类约束扩展，对扩展进行边界限定
   2. 参数类型、引用对象尽量使用接口或者抽象类而不是实现类
   3. 抽象层尽量保持稳定，一旦确定即不允许修改
2. 元数据（metadata）控制模块行为：（控制反转IOC）
3. 指定项目章程
4. 封装变化
   1. 将相同的变化封装到一个接口或抽象类中
   2. 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中

# 23种设计模式

### 单例模式

##### 单例模式通用代码：

```java
public class Singleton {
    private static Singleton instance=null;
    
    private Singleton(){

    }
    public static Singleton getInstance(){
        if (instance==null){
            instance=new Singleton();
        }
        return instance;
    }
}
```

##### 单例模式优点

- 减少了内存开支，特别是需要频繁创建销毁的对象
- 减少了系统的性能开销
- 避免对资源的多重占用
- 可以在系统设置全局的访问点，优化和共享资源访问

##### 单例模式的缺点

- 单例模式一般没有接口，扩展困难
- 单例模式对测试不理。在并行开发中，单里没有完成前不能进行测试，没有接口也不能使用mock
- 单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑 ，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把`要单例`和业务逻辑融合在一个类中

##### 单例模式应用场景

- 要求生成唯一序列号的环境
- 在整个项目中需要一个共享访问点或共享数据
- 创建一个对象需要消耗的资源过多
- 需要定义大量的静态常量和静态方法的环境

##### 线程安全的单例模式

```java
public class Singleton {
    private static Singleton instance=null;
    private static final ReentrantLock lock = new ReentrantLock();
    private Singleton(){

    }
    public static Singleton getInstance(){
        if (instance == null) {//第一层判断
            try {
                lock.lock();//上锁
                if (instance == null) {//第二层判断
                    instance=new Singleton();
                }
            }finally {
                lock.unlock();
            }
        }

        return instance;
    }
}
```

##### 使用单例模式模拟Spring自动装配

###### 首先编写自定义注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Bean {
    String name() default "";
}
```

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Configuration {
}
```

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Import {
    Class<?>[] classes();
}
```

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Qualifier {
    String value() default "";
}
```

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Autowired {
    AutoWiredType type() default AutoWiredType.BY_TYPE;
}
```

```java
public enum AutoWiredType {
    /**
     * ByType自动装配
     */
    BY_TYPE,
    /**
     * ByName自动装配
     */
    BY_NAME
}
```

###### 自定义异常类

自定义异常类全部继承于Exception类

例如：

```java
public class NoSuchTypeBeanException extends Exception{
    public NoSuchTypeBeanException() {
    }

    public NoSuchTypeBeanException(String message) {
        super(message);
    }

    public NoSuchTypeBeanException(String message, Throwable cause) {
        super(message, cause);
    }

    public NoSuchTypeBeanException(Throwable cause) {
        super(cause);
    }

    public NoSuchTypeBeanException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

异常结构如下

![image-20210901094844452](/设计模式/image-20210901094844452.png)

###### 编写容器初始化类

首先需要一个静态变量做容器：

```java
private static HashMap<String, Object> container = null;
```

定义添加Bean到容器中的方法，此方法私有，仅用于初始化

```java
private synchronized void addBean(String name, Object o) throws BeanExistException {
    //不允许重复添加
    if (container.containsKey(name)) {
        throw new BeanExistException("already exist bean with name:'" + name + "'");
    }
    container.put(name, o);
}
```

定义初始化容器方法

```java
private synchronized void initContainer(String name) throws Exception {
    //        反射加载
    Class<?> aClass = Class.forName(name);
    //        判断所选类是否存在@Configuration注解
    if (aClass.isAnnotationPresent(Configuration.class)) {
        //            创建一个配置类对象
        Object config = aClass.newInstance();
        //            获取配置类中所有的方法
        Method[] declaredMethods = aClass.getDeclaredMethods();
        if (container == null) {
            container = new HashMap<>(declaredMethods.length);
        }
        //            遍历
        for (Method declaredMethod : declaredMethods) {
            //                判断此方法是否存在@Bean注解
            if (declaredMethod.isAnnotationPresent(Bean.class)) {
                //                    如果没有指定Bean的名字
                if ("".equals(declaredMethod.getAnnotation(Bean.class).name())) {
                    //                        就使用方法名作为bean的名字并执行这个方法初始化bean并注入到容器
                    addBean(declaredMethod.getName(), declaredMethod.invoke(config));
                } else {
                    //                        否则使用指定的名字初始化bean并注入到容器
                    addBean(declaredMethod.getAnnotation(Bean.class).name(), declaredMethod.invoke(config));
                }
            }
        }
    }
    if (aClass.isAnnotationPresent(Import.class)){
        Class<?>[] classes = aClass.getAnnotation(Import.class).classes();
        for (Class<?> aClass1 : classes) {
            initContainer(aClass1.getName());
        }
    }
}
```

定义构造函数并重载

```java
public Container(String name) throws Exception {
    initContainer(name);

}

public Container(Class<?> configClass) throws Exception {

    initContainer(configClass.getName());
}
```

定义获取Bean的方法并重载

```java
public Object getBean(String name) throws NoSuchNameBeanException {
    if (!container.containsKey(name)) {
        throw new NoSuchNameBeanException("there is no bean with name:" + name);
    }
    return container.get(name);
}

@SuppressWarnings("unchecked")
public <T> T getBean(Class<T> requiredType, String name) throws NoSuchTypeBeanException, NoQualifiedBeanException, MultipleQualifiedBeanException {
    Set<Map.Entry<String, Object>> entries = container.entrySet();
    boolean byType = false;
    T bean=null;
    for (Map.Entry<String, Object> entry : entries) {
        if (requiredType.isAssignableFrom(entry.getValue().getClass())) {
            byType = true;
            if (name == null || name.trim().isEmpty() || name.equals(entry.getKey())) {
                if (bean != null) {
                    throw new MultipleQualifiedBeanException("there is more than one qualified bean with type:"+requiredType.getName());
                }
                bean = ((T) entry.getValue());
            }
        }
    }
    if (bean!=null){
        return bean;
    }
    if (!byType) {
        throw new NoSuchTypeBeanException("there is no bean with type:" + requiredType.getName());
    } else {
        throw new NoQualifiedBeanException("there is no qualified bean with type:" + requiredType.getName() + ",and with name:" + name);
    }

}
```

定义自动装配初始化方法

```java
public synchronized Object autowiredInit(String name) throws Exception {
    //        加载这个要装配的类的class对象
    Class<?> aClass = Class.forName(name);
    return autowiredInit(aClass);
}

public synchronized <T> T autowiredInit(Class<T> clazz) throws Exception{
    //        构造这个类的实例对象
    T o = clazz.newInstance();
    //        获取这个类所有的声明的变量
    Field[] declaredFields = clazz.getDeclaredFields();
    //        遍历这些变量
    for (Field declaredField : declaredFields) {
        //            判断这个变量是否有@Autowired修饰
        if (declaredField.isAnnotationPresent(Autowired.class)) {
            //                修改访问权限，可以修改private的变量
            declaredField.setAccessible(true);
            AutoWiredType type = declaredField.getAnnotation(Autowired.class).type();
            if (type==AutoWiredType.BY_TYPE){
                if (declaredField.isAnnotationPresent(Qualifier.class)){
                    String qualifyName = declaredField.getAnnotation(Qualifier.class).value();
                    declaredField.set(o,this.getBean(declaredField.getType(),qualifyName));
                }else{
                    declaredField.set(o,this.getBean(declaredField.getType(),null));
                }
            }else {
                //                    获取变量的名字
                String name1 = declaredField.getName();
                //                获取对应的Bean
                Object bean = getBean(name1);
                //                设置值
                declaredField.set(o, bean);
            }
        }
    }
    //        返回这个被装配完毕的实例对象
    return o;
}
```

编写实体类、配置类、服务类

![image-20210901095526026](/设计模式/image-20210901095526026.png)

编写启动类

```java
public class Client {

    @Autowired
    private DataSource mysql;

    @Autowired
    private DataSourceTransactionManager transactionManager;

    @Autowired
    @Qualifier("iDemoService")
    private IDemoService service;

    public static void main(String[] args) throws Exception {
        //使用指定配置文件初始化容器
        Container container = new Container(Config.class);
//        进行自动装配
        Client client = container.autowiredInit(Client.class);
//        调用方法
        client.service.demo();
        System.out.println(client.mysql);
    }
}
```

### 工厂方法模式

定义：==定义一个用于创建对象的接口，让子类决定实例化哪一个类。==

**工厂方法使一个类的实例化延迟到其子类**

![image-20210901103841094](/设计模式/image-20210901103841094.png)

##### 工厂方法模式的优点

- 良好的封装性，代码结构清晰，调用者只要知道类名就可以生产
- 扩展性好，在增加产品类的情况下只要适当地修改具体工厂类或扩展一个工厂类即可
- 屏蔽产品类。只要接口不变，上层模块就不变
- 解耦

##### 工厂方法模式使用场景

- 所有需要生成对象的地方，但要注意是否需要这么做，避免增加复杂度
- 需要灵活、可扩展的框架（Spring）
- 异构项目，减少与外围系统的耦合
- 测试驱动开发的框架

##### 工厂方法模式的扩展

1. 缩小为简单工厂模式：工厂类不再需要抽象类，且将方法变为静态
2. 升级为多个工厂类：为每个产品定义一个创造者，每个创造者都对应一种产品
3. 替代单例模式：工厂持有一个未初始化的单例对象，此单例对象的构造器私有化，单例工厂通过反射生成一个此对象
4. 延迟初始化：一个对象被消费完毕后不立刻释放，工厂类通过Map等结构缓存，如果再次受到同类资源的请求直接从缓存中获取即可

### 抽象工厂模式

**为创建==一组==相关或相互依赖的对象提供一个接口**

举例：

每个电脑厂商都能生产键盘和鼠标，且这两件产品存在对应的关系

首先定义两个抽象类：键盘类和鼠标类，A厂商和B厂商分别创建一个鼠标类、一个键盘类继承自抽象类

定义一个工厂接口，包含创建键盘和鼠标的功能，A、B厂商工厂都实现这个接口，并各自重写方法生产自己的键盘和鼠标

这样在调用者看来，只要`工厂.创建的产品名`就能获得对应厂商的某个产品了

##### 抽象工厂模式的优点

- 封装性，上层模块只要关注产品的抽象即可，具体实现只要工厂知晓即可
- 抽象工厂模式中对象是有关系的，关系只在工厂中被约束，例如控制产品比例，这对上层模块是隐藏的

##### 抽象工厂模式的缺点

- 产品族（纵向扩展）扩展非常困难，违反开闭原则

##### 抽象工厂模式的使用场景

- 一组有着相同约束的对象。例如比例关系、对应关系等

##### 注意事项

抽象工厂==横向扩展==容易，==纵向扩展==困难，例如电脑工厂还要生产音响，这就属于纵向扩展，要修改工厂接口、接口的实现、还要编写抽象类和一系列实现类；如果增加一个厂商，则只要通过继承和实现即可完成扩展，符合开闭原则

### 模板方法模式

定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

**一般模板方法都加上final关键字防止覆写**

```java
public abstract class AbstractClass {
    /**
     * 定义一个抽象行为，由子类实现
     */
    protected abstract void operation1();

    /**
     * 定义一个抽象行为
     */
    protected abstract void operation2();

    /**
     * 不变的行为，去除子类中的重复代码
     */
    public void templateMethod(){
        operation1();
        operation2();
        System.out.println("模板方法");
    }
}
```

##### 模板方法模式的优点：

- 封装不变部分、扩展可变部分
- 提取公共部分代码，便于维护
- 行为由父类控制，子类实现

##### 模板方法模式的缺点

抽象类定义了部分方法，子类的覆写会影响父类方法的结果，在复杂项目中阅读性下降

##### 模板方法模式使用场景

- 多个子类有共有的方法并且逻辑基本相同
- 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节由各个子类实现
- 重构时，把相同的代码抽取到父类中，通过钩子函数约束其行为

##### 模板方法模式的扩展

钩子函数：

定义一个带返回类型的函数，父类要将其实现且要设置默认返回值，子类在需要的时候进行覆写，控制这个钩子函数的返回值，公共代码中通过这个返回值判断哪些语句要执行，哪些不要执行，这样就能够实现子类的公共部分执行结果不同

父类：

```java
public abstract class AbstractClass {
    /**
     * 定义一个抽象行为，由子类实现
     */
    protected abstract void operation1();

    /**
     * 定义一个抽象行为
     */
    protected abstract void operation2();

    /**
     * 不变的行为，去除子类中的重复代码
     */
    public void templateMethod(){
        operation1();
        if (isOperation2()){
            operation2();
        }
        System.out.println("模板方法");
    }

    protected boolean isOperation2(){
        return true;
    }
}
```

子类：

```java
public class ConcreteClass extends AbstractClass{

    private boolean flag=true;

    public void setFlag(boolean flag) {
        this.flag = flag;
    }

    @Override
    protected boolean isOperation2() {
        return flag;
    }


    @Override
    protected void operation1() {
        System.out.println("具体类A实现方法1");
    }

    @Override
    protected void operation2() {
        System.out.println("具体类A实现方法2");
    }
}
```

### 建造者模式

**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示**

##### 四个角色

- Product产品类
  - 通常是实现了模板方法模式
- Builder抽象建造者
  - 规范产品的组建，一般由子类实现
- ConcreteBuilder具体建造者
  - 实现抽象类定义的所有方法，并且返回一个组建好的对象
- Director导演类：
  - 负责安排已有模块的顺序，告诉Builder开始建造

示例：构造一个HTTP请求，URL、参数、请求头顺序可以随意设置

首先编写一个基类，包含请求的基本信息

编写一个子类继承这个基类

编写建造者基类

```java
public abstract class AbstractBuilder {

    protected AbstractRequest request;

    protected abstract void setPart(String filedName,Object value);

    public AbstractBuilder() {
        this.request=new Request();
    }

    protected abstract AbstractRequest getRequest();
}
```

编写建造者的实现类

```java
public class Builder extends AbstractBuilder{
    @Override
    protected void setPart(String filedName,Object value) {
        if ("url".equals(filedName)){
            this.request.setUrl((String) value);
        }else if ("header".equals(filedName)){
            this.request.setHeader(((String) value));
        }else {

            this.request.setParams((HashMap<String, String>) value);
        }
    }

    @Override
    protected AbstractRequest getRequest() {
        return this.request;
    }

    public Builder setUrl(String url){
        this.setPart("url",url);
        return this;
    }

    public Builder setHeader(String header){
        this.setPart("header",header);
        return this;
    }

    public Builder setParams(HashMap<String, String> params){
        this.setPart("params",params);
        return this;
    }
}
```

最后编写导演类，此处我们将启动类作为导演类

```java
public class Client {
    public static void main(String[] args) {
        Builder builder = new Builder();
        AbstractRequest request = builder.setHeader("header")
                .setUrl("url")
                .setParams(new HashMap<>(1))
                .getRequest();

        System.out.println(request);
    }
}
```

##### 建造者模式的优点

- 封装性
  - 客户端不必知道产品内部组成的细节
- 建造者独立，易于扩展
  - 上例中，构建HTTPS请求只要编写HTTPS类和HTTPS的建造者即可，且所有的建造者没有直接关系
- 便于控制细节风险
  - 建造者是独立的，可以对构造过程精细化而不对其他模块产生影响

##### 建造者模式使用场景

- 相同的方法，不同的执行顺序，产生不同的事件结果，例如构建HTTP、HTTPS
- 多个零部件都可以装配到一个对象中，但产生的运行结果又不相同
- 产品类非常复杂，或者产品类中调用顺序不同会产生不同的效能
- 在对象创建过程中会使用到系统中的一些其他对象，且这些对象不易获取

##### 注意事项

建造者模式关注的是==零件类型、装配工艺（顺序）==，这是与工厂方法模式最大的不同

### 代理模式

为其他对象提供一种代理以控制对这个对象的访问

##### 三个角色

- Subject抽象主题角色，抽象类或者是接口
- RealSubject真实角色，具体业务逻辑的执行者，被代理
- Proxy代理主题角色，应用真实角色，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后进行处理工作

静态代理示例：

```java
public class Proxy implements Subject{
    private Subject subject=null;

    public Proxy(Class<? extends Subject> clazz) throws InstantiationException, IllegalAccessException {
        Arrays.stream(clazz.getConstructors()).forEach(constructor -> constructor.setAccessible(true));
        this.subject=clazz.newInstance();
    }

    @Override
    public void request() {
        System.out.println("I'm Proxy,I'm invoking...");
        this.subject.request();
    }
}
```

##### 代理模式的优点

- 职责清晰：真实角色只需要考虑实际业务逻辑，其他事务由代理完成
- 高扩展性：如上述示例，只要真实角色实现了接口，则代理类可以不做任何修改
- 智能化：动态代理、Mybatis映射

##### 代理模式的扩展

###### 普通代理

要求客户端只能访问代理角色，不能访问真实角色

 示例：

接口：

```java
public interface IPlayer {

    void login(String username,String password);

    void fight();

    void upgrade();
}
```

实现类：通过构造器私有禁止创建真实对象

```java
public class Player implements IPlayer{
    @Override
    public void login(String username, String password) {
        System.out.println("正在登录");
        System.out.println("用户名："+username);
        System.out.println("密码："+password);
    }

    @Override
    public void fight() {
        System.out.println("fight");
    }

    @Override
    public void upgrade() {
        System.out.println("upgrade");
    }

    private Player() {
    }
}
```

代理类：实现接口，通过反射调用真实对象构造器

```java
public class PlayerProxy implements IPlayer{

    private IPlayer player;

    @Override
    public void login(String username, String password) {
        this.player.login(username,password);
    }

    @Override
    public void fight() {
        this.player.fight();
    }

    @Override
    public void upgrade() {
        this.player.upgrade();
    }

    public PlayerProxy(Class<? extends IPlayer> playerImpl) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Constructor<? extends IPlayer> declaredConstructor = playerImpl.getDeclaredConstructor();
        declaredConstructor.setAccessible(true);
        this.player=declaredConstructor.newInstance();
    }
}
```

启动类：

```java
public class Client {
    public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        PlayerProxy playerProxy = new PlayerProxy(Player.class);
        playerProxy.login("ppg","123");
        playerProxy.fight();
        playerProxy.upgrade();
    }
}
```

###### 强制代理

客户端只有通过真实对象指定的代理类才能访问，即真实角色管理了代理角色

接口：

```java
public interface IPlayer {

    void login(String username,String password);

    void fight();

    void upgrade();

    IPlayer getProxy();
}
```

实现类：

```java
public class Player implements IPlayer{

    private IPlayer proxy=null;

    @Override
    public void login(String username, String password) {
        System.out.println("请使用代理类访问");
    }

    @Override
    public void fight() {
        System.out.println("请使用代理类访问");
    }

    @Override
    public void upgrade() {
        System.out.println("请使用代理类访问");
    }

    @Override
    public IPlayer getProxy(){
        try {
            proxy = new PlayerProxy(Player.class,this);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) {
            e.printStackTrace();
        }
        return proxy;
    }

    private class RealPlayer implements IPlayer{

        @Override
        public void login(String username, String password) {
            System.out.println("正在登录");
            System.out.println("用户名："+username);
            System.out.println("密码："+password);
        }

        @Override
        public void fight() {
            System.out.println("fight");
        }

        @Override
        public void upgrade() {
            System.out.println("upgrade");
        }

        @Override
        public IPlayer getProxy() {
            return proxy;
        }
    }
}
```

通过内部类实现强制屏蔽，必须通过代理类访问对应的方法

代理类：

```java
public class PlayerProxy implements IPlayer{

    private IPlayer realPlayer;

    public PlayerProxy(Class<? extends IPlayer> outerPlayer,IPlayer outer) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Constructor<? extends IPlayer> declaredConstructor = outerPlayer.getDeclaredConstructor();

        Class<?>[] declaredClasses = outerPlayer.getDeclaredClasses();
        for (Class<?> declaredClass : declaredClasses) {
            if (IPlayer.class.isAssignableFrom(declaredClass)){
                Constructor<?> inner = declaredClass.getDeclaredConstructor(outerPlayer);
                inner.setAccessible(true);
                Object o = inner.newInstance(outer);
                realPlayer= ((IPlayer) o);
            }
        }
    }

    @Override
    public void login(String username, String password) {
        this.realPlayer.login(username,password);
    }

    @Override
    public void fight() {
        this.realPlayer.fight();
    }

    @Override
    public void upgrade() {
        this.realPlayer.upgrade();
    }

    @Override
    public IPlayer getProxy() {
        return null;
    }
}
```

代理类通过反射创建内部类实例并在相关方法中引用，注意内部类构造时，默认构造器接受一个外部类实例，需要传入

```java
public class Client {
    public static void main(String[] args) {
        Player player = new Player();
        IPlayer proxy = player.getProxy();
        player.fight();//请使用代理类访问
        proxy.fight();//fight
    }
}
```

###### 个性代理

代理类实现除代理接口以外的其他接口，在目标方法上完成增强

###### 动态代理

InvocationHandler接口

### 原型模式

##### 定义

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

实现Cloneable接口并重写Object类的clone方法

##### 原型模式的优点

- 性能优良：原型模式是在内存二进制流的拷贝（堆内存）
- 逃避构造函数的约束：既是优点也是缺点，直接在内存中拷贝，构造函数不会执行，减少了约束，缺点也是减少了约束

##### 使用场景

- 资源优化场景：类初始化需要消耗非常多的资源
- 性能和安全要求的场景：通过new创建对象需要非常繁琐的数据准备或访问权限
- 一个对象多个修改者的场景：一个对象需要提供给其他对象访问，各个调用者可能都需要修改其值，拷贝多个对象供使用

**通常与工厂方法模式一起使用**

##### 注意事项

- 构造函数不会被执行

- 深拷贝与浅拷贝

> 浅拷贝：
>
> Object类提供的clone方法只拷贝本对象，对象中的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，但是String会拷贝，此处应当视为基本类型
>
> 引用的成员变量不会被拷贝的条件：
>
> 1. 这个变量是类的成员变量而不是方法内变量
> 2. 必须是一个可变的引用对象而不是一个原始类型或不可变对象
>
> ==深拷贝不要和浅拷贝混合使用，要分开实现==

浅拷贝示例：

```java
protected Object clone() throws CloneNotSupportedException {
    //        浅拷贝
    return super.clone();
}
```

深拷贝示例：

```java
protected Object clone() throws CloneNotSupportedException {

    PrototypeClass prototype = null;
    try{
        prototype = (PrototypeClass) super.clone();
        prototype.strings = (ArrayList<String>)this.strings.clone();
    }catch(CloneNotSupportedException e){
        e.printStackTrace();
    }
    return prototype;
}
```

- clone与final

==要使用clone方法，类成员变量就不要使用final关键字==

### 中介者模式（调停者模式）

##### 定义

用一个中介对象封装一系列的对象交互，中介者使各对象不需要显式地相互作用，从而实现解耦合

##### 三部分

- Mediator抽象中介者角色
- Concrete Mediator具体中介者角色
- Colleague同事角色

##### 示例

抽象中介者：

```java
public abstract class AbstractMediator {

    protected final List<AbstractColleague> colleagueList=new LinkedList<>();

    public void addColleague(AbstractColleague colleague){
        this.colleagueList.add(colleague);
    }


    public List<AbstractColleague> getColleagueList() {
        return colleagueList;
    }

    protected abstract void process(Class<? extends AbstractColleague> colleague,Object ...args) throws Exception;

}
```

底层抽象同事类：

```java
public abstract class AbstractColleague {

    protected AbstractMediator mediator;

    public AbstractColleague(AbstractMediator mediator) {
        this.mediator = mediator;
    }
}
```

抽象同事类的两个抽象子类，分别具有完成一个功能的方法

```java
public abstract class AbstractInColleague extends AbstractColleague{

    public AbstractInColleague(AbstractMediator mediator) {
        super(mediator);
    }

    public abstract void in(int number);
}
```

```java
public abstract class AbstractOutColleague extends AbstractColleague{
    public AbstractOutColleague(AbstractMediator mediator) {
        super(mediator);
    }

    public abstract void out(int number);
}
```

实际中介者

```java
public class Mediator extends AbstractMediator{
    @Override
    protected void process(Class<? extends AbstractColleague> colleague,Object ...args) throws Exception {
        List<AbstractColleague> colleagueList = this.colleagueList;
        boolean success=false;
        for (AbstractColleague abstractColleague : colleagueList) {
            if (abstractColleague.getClass().getName().equals(colleague.getName())){
                if (AbstractInColleague.class.isAssignableFrom(colleague)){
                    ((AbstractInColleague) abstractColleague).in(((int) args[0]));
                    success=true;
                    break;
                }else if (AbstractOutColleague.class.isAssignableFrom(colleague)){
                    ((AbstractOutColleague) abstractColleague).out(((int) args[0]));
                    success=true;
                    break;
                }
            }
        }
        if (!success) {
            throw new Exception("调用失败");
        }

    }
}
```

实际同事类：

```java
public class Colleague1 extends AbstractInColleague{

    public Colleague1(AbstractMediator mediator) {
        super(mediator);
        this.mediator.addColleague(this);
    }

    @Override
    public void in(int number) {
        System.out.println("Colleague1正在处理自己的事务，库存增加:"+number);
    }

    public void depMethod(int number) throws Exception {
        System.out.println("Colleague1正在申请减少库存:"+number);

        this.mediator.process(Colleague2.class,number);
    }
}
```

```java
public class Colleague2 extends AbstractOutColleague{

    public Colleague2(AbstractMediator mediator) {
        super(mediator);
        this.mediator.addColleague(this);
    }

    @Override
    public void out(int number) {
        System.out.println("Colleague2正在处理自己的事务，库存减少:"+number);
    }

    public void depMethod(int number) throws Exception {
        System.out.println("Colleague2申请增加库存:"+number);
        this.mediator.process(Colleague1.class,number);
    }
}
```

启动类：

```java
public class Client {

    public static void main(String[] args) throws Exception {
        Mediator mediator = new Mediator();
        Colleague1 colleague1 = new Colleague1(mediator);
        Colleague2 colleague2 = new Colleague2(mediator);
        colleague1.depMethod(1);
        colleague2.depMethod(10);
    }
}
```

##### 中介模式的优点

减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，降低了耦合度

##### 中介模式的缺点

中介者可能会膨胀的很大，而且逻辑复杂，同事类越多，中介者就越复杂

##### 中介者模式的使用场景

==类间的依赖关系是必然存在的==

中介者模式适用于多个对象之间紧密耦合的情况，例如类图中出现了网状结构时，可以使用中介者模式进行解耦

### 命令模式

##### 定义

将一个请求封装为一个对象，从而使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能

##### 角色

- Receiver接收者：干活的角色，命令传递到此处被执行
- Command命令角色：需要执行的所有命令都在这里声明
- Invoker调用者角色：接收到命令并执行命令

##### 示例

抽象命令类：可以在这里将各接收者直接作为成员变量

```java
public abstract class AbstractCommand {
    public abstract void execute();
}
```

抽象接收者类：

```java
public abstract class AbstractReceiver {
    public abstract void process();
}
```

上述抽象类的实现类

```java
public class Command1 extends AbstractCommand{

    private final AbstractReceiver receiver;

    public Command1(AbstractReceiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        this.receiver.process();
    }
}
```

```java
public class Command2 extends AbstractCommand{

    private final AbstractReceiver receiver;

    public Command2(AbstractReceiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        this.receiver.process();
    }
}
```

```java
public class Receiver1 extends AbstractReceiver{
    @Override
    public void process() {
        System.out.println("买瓶水");
    }
}
```

```java
public class Receiver2 extends AbstractReceiver{
    @Override
    public void process() {
        System.out.println("买块肉");
    }
}
```

Invoker类：

```java
public class Invoker {
    private AbstractCommand command;

    public void setCommand(AbstractCommand command) {
        this.command = command;
    }

    public void execute(){
        this.command.execute();
    }
}
```

启动类：

```java
public class Client {
    public static void main(String[] args) {
        Invoker invoker = new Invoker();
        invoker.setCommand(new Command1(new Receiver1()));
        invoker.execute();
        invoker.setCommand(new Command2(new Receiver2()));
        invoker.execute();
    }
}
```

##### 命令模式的优点

- 类间解耦：调用者角色与接收者角色之间没有任何依赖关系
- 可扩展性：Command子类可以非常容易的扩展，调用者Invoker与Client不产生严重的耦合
- 命令模式结合其他模式会更优秀：结合责任链模式实现命令族解析任务；结合模板方法模式，可以减少Command子类的膨胀问题

##### 命令模式的缺点

命令数量和Command子类数量一对一，容易出现类爆炸

##### 命令模式使用场景

认为是命令的地方都可以

##### 命令模式的扩展

###### 增加需求

要增加一个命令的工作量，只要修改execute方法即可

###### 反悔问题

1. 结合备忘录模式还原最后状态，该方法适合接收者为状态的变更情况，而不适合事件处理
2. 增加新命令，实现事件的回滚

### 责任链模式

##### 定义

使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止

##### 主要角色

- 抽象处理器
- 具体处理器
- 责任链管理类（可选）

##### 示例

抽象处理器

```java
public abstract class AbstractHandler {

    protected AbstractHandler nextHandler;

    public AbstractHandler(Level handleAbleLevel) {
        this.handleAbleLevel = handleAbleLevel;
    }

    protected Level handleAbleLevel;

    public final void setNextHandler(AbstractHandler nextHandler){
        this.nextHandler=nextHandler;
    }

    public final AbstractHandler getNextHandler() {
        return nextHandler;
    }

    public final Level getHandleAbleLevel() {
        return handleAbleLevel;
    }

    public final void setHandleAbleLevel(Level handleAbleLevel) {
        this.handleAbleLevel = handleAbleLevel;
    }

    /**
     * 执行自己的处理逻辑
     * @param request 请求
     * @return 响应
     */
    protected abstract Response selfHandle(Request request);

    public final Response dispatchHandler(Request request) throws Exception {
        System.out.println("请求内容："+request.getMsg());
        System.out.println("请求级别："+request.getRequestLevel().getLevel());
        if (this.getHandleAbleLevel().getLevel()>=request.getRequestLevel().getLevel()){
            return this.selfHandle(request);
        }else {
            if (this.nextHandler == null) {
                throw new Exception("no handler available");
            }else {
                System.out.println("第 "+this.handleAbleLevel.getLevel()+" 级处理器放行");
                return this.nextHandler.dispatchHandler(request);
            }
        }
    }

}
```

结合模板方法模式，对于每个请求先判断级别与处理器的级别，不能处理则传给责任链中的下一个处理器

具体处理器

```java
public class Handler1 extends AbstractHandler{
    public Handler1(Level handleAbleLevel) {
        super(handleAbleLevel);
    }

    @Override
    protected Response selfHandle(Request request) {
        Response response = new Response();
        response.setResponseMsg("第 "+this.handleAbleLevel.getLevel()+" 级处理器处理完成");
        return response;
    }
}
```

请求级别枚举类

```java
public enum Level {
    /**
     * 最小
     */
    MIN(1),
    /**
     * 较小
     */
    SMALLER(3),
    /**
     * 中等
     */
    MID(5),
    /**
     * 较大
     */
    LARGER(7),
    /**
     * 最大
     */
    MAX(9);

    private final Integer level;

    Level(Integer level) {
        this.level = level;
    }

    public Integer getLevel() {
        return level;
    }
}
```

请求实体类

```java
public class Request {

    private String msg;

    private Level requestLevel;

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public Level getRequestLevel() {
        return requestLevel;
    }

    public void setRequestLevel(Level requestLevel) {
        this.requestLevel = requestLevel;
    }
}
```

响应实体类

```java
public class Response {

    private String responseMsg;

    public String getResponseMsg() {
        return responseMsg;
    }

    public void setResponseMsg(String responseMsg) {
        this.responseMsg = responseMsg;
    }
}
```

处理器注册中心类

```java
public class RegistryCenter {

    private final LinkedList<AbstractHandler> handlers=new LinkedList<>();

    public RegistryCenter registerHandler(AbstractHandler handler){
        boolean res = this.handlers.add(handler);
        if (res){
            this.sort();
        }
        return this;
    }

    public LinkedList<AbstractHandler> getHandlers() {
        return handlers;
    }

    public AbstractHandler getFirstHandler(){
        if (this.handlers.isEmpty()){
            return null;
        }else {
            return this.handlers.get(0);
        }
    }

    private void sort(){
        this.handlers.sort(Comparator.comparingInt(o -> o.getHandleAbleLevel().getLevel()));
        for (int i = 0; i < handlers.size(); i++) {
            if (i!=handlers.size()-1){
                this.handlers.get(i).setNextHandler(this.handlers.get(i+1));
            }
        }
    }
}
```

默认按照优先级从小到大指定每个处理器的下一个处理器

场景类

```java
public class Client {

    private static final AbstractHandler FIRST_HANDLER;

    static {
        Handler1 handler1 = new Handler1(Level.MIN);
        Handler2 handler2 = new Handler2(Level.SMALLER);
        Handler3 handler3 = new Handler3(Level.MID);
        Handler4 handler4 = new Handler4(Level.LARGER);
        Handler5 handler5 = new Handler5(Level.MAX);
        RegistryCenter registryCenter = new RegistryCenter();
        registryCenter.registerHandler(handler1)
                .registerHandler(handler2)
                .registerHandler(handler3)
                .registerHandler(handler4)
                .registerHandler(handler5);
        FIRST_HANDLER=registryCenter.getFirstHandler();
    }
    public static void main(String[] args) throws Exception {
        Request request = new Request();
        request.setRequestLevel(Level.MAX);
        request.setMsg("买房");
        Response response = FIRST_HANDLER.dispatchHandler(request);
        System.out.println(response.getResponseMsg());
    }
}
```

##### 责任链模式的优点

将请求和处理分开，请求者不需要知道是谁处理的，处理者也不需要知道请求的来源及其他信息，实现解耦

##### 责任链模式的缺点

- 性能问题
- 调试不方便

##### 责任链模式注意事项

责任链中的节点数量需要控制，避免超长链的情况，可以设置链的最大长度

### 装饰器模式

##### 定义

动态的给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更加灵活

##### 角色

- Component抽象构件：定义最原始的对象，未经装饰
- ConcreteComponent具体构件：最核心、最原始、最基本的接口或抽象类的实现，也就是被装饰对象
- Decorator装饰角色：一般是一个抽象类， 继承抽象构件，且持有一个抽象构件的对象引用
- 具体装饰角色：把具体构件进行装饰

##### 示例

抽象构件类

```java
public abstract class Component {

    /**
     * 操作
     */
    public abstract void operation();
}
```

具体构件类

```java
public class ConcreteComponent extends Component{
    @Override
    public void operation() {
        System.out.println("具体的操作");
    }
}
```

抽象装饰器类

```java
public abstract class Decorator extends Component{

    private Component component=null;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        if (component!=null){
            component.operation();
        }
    }
}
```

具体装饰器类

```java
public class ConcreteDecoratorA extends Decorator{
    public ConcreteDecoratorA(Component component) {
        super(component);
    }
    private void methodA(){
        System.out.println("methodA");
    }

    @Override
    public void operation() {
        this.methodA();
        super.operation();
    }
}
```

```java
public class ConcreteDecoratorB extends Decorator{
    public ConcreteDecoratorB(Component component) {
        super(component);
    }
    private void methodB(){
        System.out.println("methodB");
    }

    @Override
    public void operation() {
        super.operation();
        this.methodB();
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) {
        Component component=new ConcreteComponent();
        component=new ConcreteDecoratorA(component);
        component=new ConcreteDecoratorB(component);
        component.operation();
    }
}
```

首先创建了一个具体构件类对象，将此对象传入第一个装饰器的构造函数中，并将构件的引用指向构造器返回的第一个装饰器实例对象，此时component对象是经过一个装饰的装饰类对象，持有一个原生对象引用，再次将装饰后的对象传入第二个装饰器的构造器此时component指向的是经过两次装饰的装饰器对象，持有一个装饰器A（相当于套娃），最后执行第二个装饰器的operation方法，首先执行父类的operation方法，此时装饰器B中的component是装饰器A实例，所以又去执行装饰器A的operation方法，然后在A中执行父类的operation方法，装饰器A的component是原始构件，所以此时执行了原始构件的operation方法，此时再次回到装饰器B中，再执行B中的methodB方法

==执行顺序：methodA、原始构件的operation方法、methodB==

##### 装饰器模式的优点

- 装饰类和被装饰类可以独立发展，不会耦合
- 装饰模式是继承的替代方案
- 装饰模式可以动态的扩展一个实现类的功能

##### 装饰器模式的缺点

多层装饰比较复杂

##### 装饰器模式使用场景

- 需要扩展一个类的功能，或者给一个类增加附加功能
- 需要动态的给一个对象增加功能，这些功能可以动态的撤销
- 需要为一批的兄弟类进行改装或加装功能



### 策略模式

##### 定义

定义一组算法，将每个算法都封装起来，并且使它们之间可以互换

##### 三个角色

- Context封装角色：上下文角色，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化
- Strategy抽象策略角色：策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性
- ConcreteStrategy具体策略角色：实现抽象策略中的操作，含有具体的算法

##### 示例

抽象策略接口

```java
public abstract class Strategy {
    /**
     * 抽象算法
     */
    public abstract void algorithmInterface();
}
```

封装角色

```java
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    public void contextInterface(){
        strategy.algorithmInterface();
    }
}
```

具体策略角色

```java
public class ConcreteStrategyA extends Strategy{
    @Override
    public void algorithmInterface() {
        System.out.println("算法A实现");
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) {
        Context context;

        context=new Context(new ConcreteStrategyA());
        context.contextInterface();
    }
}
```

##### 策略模式的优点

- 算法可以自由切换：只要实现抽象策略接口，就可以进行封装对外提供策略
- 避免使用多重条件判断：其他模块决定使用何种策略
- 扩展性好：增加策略只需要多一个实现抽象策略接口的类

##### 策略模式的缺点

- 策略类数量增多：每一个策略都是一个类，复用性降低
- 所有的策略类都需要向外暴露：上层模块必须知道有哪些策略才能决定使用哪个策略，违背了迪米特法则，可以使用其他模式来修正这个问题，例如工厂方法模式、代理模式、享元模式等

##### 策略模式的使用场景

- 多个类只有在算法或行为上稍有不同的场景
- 算法需要自由切换的场景
- 需要屏蔽算法规则的场景

##### 策略模式注意事项

具体策略超过4个就需要考虑使用混合模式

#### 策略枚举

实现加减法，枚举类：

```java
public enum Calculator {
    /**
     * 加法
     */
    ADD("+"){
        @Override
        public int exec(int a, int b){
            return a+b;
        }
    },
    /**
     * 减法
     */
    SUB("-"){
        @Override
        public int exec(int a, int b){
            return a-b;
        }
    };
    String value;
    Calculator(String value){
        this.value=value;
    }
    public String getValue(){
        return this.value;
    }
    
    public abstract int exec(int a,int b);
}
```

启动类：

```java
public class Client {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        String operator = scanner.next();
        int b = scanner.nextInt();
        if (Calculator.ADD.getValue().equals(operator)){
            System.out.println(Calculator.ADD.exec(a, b));
        }else if (Calculator.SUB.getValue().equals(operator)){
            System.out.println(Calculator.SUB.exec(a, b));
        }else {
            System.out.println("error");
        }
        scanner.close();
    }
}
```

**注意：策略枚举受枚举类型约束，每个枚举项都是public、final、static的，扩展性较弱，适用于不经常发生变化的场景**

### 适配器模式（变压器模式、包装模式Wrapper）

##### 定义

将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法工作在一起的两个类能够在一起工作

##### 三个角色

- Target目标角色：该角色定义把其他类转换为何种接口，即期望接口
- Adaptee源角色：被转换的角色，是已经存在的、运行良好的类或对象
- Adapter适配器角色：将源角色转换为目标角色，通过继承或类关联的方式实现

##### 示例

目标角色

```java
public interface Target {

    /**
     * 所期待的方法
     */
    void request();
}
```

源角色

```java
public class Adaptee {

    public void specificRequest(){
        System.out.println("源角色");
    }
}
```

目标角色实现类

```java
public class ConcreteTarget implements Target{
    @Override
    public void request() {
        System.out.println("目标角色实现类");
    }
}
```

适配器角色

```java
public class Adapter extends Adaptee implements Target{
    @Override
    public void request() {
        super.specificRequest();
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) {
        
        //原有的业务逻辑
        new ConcreteTarget().request();
        
        //增加适配器后
        Target target=new Adapter();
        target.request();
    }
}
```

##### 适配器模式的优点

- 适配器模式可以让两个没有任何关系的类在一起运行
- 增加了类的透明性：访问的是Target目标角色，实际执行的是源角色
- 提高了类的复用度
- 灵活性好

##### 适配器模式的使用场景

- 有动机修改一个已经投入生产的接口时

##### 适配器模式的注意事项

不应当在详细设计阶段考虑适配器模式，适配器模式不应该解决开发阶段中的问题

##### 适配器模式的扩展

如果要适配的功能中接口不止一个可以修改适配器类，只实现目标角色接口，由上面的继承源角色改为持有要适配的多个接口的多个实现类对象，通过对象层次的关联实现，称为==对象适配器==，通过继承进行适配称为==类适配器==

**类适配器是==类间继承==，对象适配器是==对象的合成关系==**

### 迭代器模式

##### 定义

提供一种方法访问一个容器对象中各个元素而又不暴露该对象的内部细节

##### 角色

- Iterator抽象迭代器：定义访问和遍历元素的接口
- ConcreteIterator具体迭代器：实现迭代器接口完成遍历
- Aggregate抽象容器：提供创建具体迭代器角色的接口
- ConcreteAggregate具体容器：实现容器接口定义的方法

##### 示例

抽象迭代器：

```java
public interface Iterator<E> {
    /**
     * 获取下一个元素
     * @return 元素
     */
    E next();

    /**
     * 是否还有元素
     * @return 布尔值
     */
    boolean hasNext();

    /**
     * 删除元素
     * @return 删除是否成功
     */
    boolean remove();

    /**
     * 复位
     */
    void reset();
}
```

具体迭代器：

```java
public class ConcreteIterator<E> implements Iterator<E>{

    private final LinkedList<E> linkedList;
    /**
     * 游标
     */
    private int cursor=0;

    public ConcreteIterator(LinkedList<E> linkedList) {
        this.linkedList = linkedList;
    }

    @Override
    public E next() {
        if (this.hasNext()){
            return this.linkedList.get(this.cursor++);
        }
        return null;
    }

    @Override
    public boolean hasNext() {
        return this.cursor != this.linkedList.size();
    }

    /**
     * 调用next方法后，游标已滑到下一个位置，
     * 调用删除方法，应当删除next调用返回的元素，
     * 也就是此时游标的前一个位置的元素，如果不进行自减
     * 可能存在下标越界问题
     * @return 是否删除成功
     */
    @Override
    public boolean remove() {
        return this.linkedList.remove(--this.cursor) != null;
    }

    @Override
    public void reset() {
        this.cursor=0;
    }
}
```

抽象容器

```java
public interface Aggregate<T> {

    /**
     * 添加元素
     * @param t 元素
     */
    void add(T t);

    /**
     * 删除元素
     * @param t 要删除的对象
     */
    void remove(T t);

    /**
     * 获取迭代器对象
     * @return 迭代器对象
     */
    Iterator<T> iterator();
}
```

具体容器

```java
public class ConcreteAggregate<T> implements Aggregate<T>{

    public ConcreteAggregate() {
        this.linkedList = new LinkedList<>();
    }

    private final LinkedList<T> linkedList;


    @Override
    public void add(T t) {
        this.linkedList.add(t);
    }

    @Override
    public void remove(T t) {
        this.linkedList.remove(t);
    }

    @Override
    public Iterator<T> iterator() {
        return new ConcreteIterator<>(this.linkedList);
    }
}
```

启动类

```java
public class Client {

    public static void main(String[] args) {
        ConcreteAggregate<User> userConcreteAggregate = new ConcreteAggregate<>();
        Random random = new Random(System.currentTimeMillis());
        for (int i = 0; i < 10; i++) {
            userConcreteAggregate.add(
                    new User(
                            UUID.randomUUID().toString()
                            ,random.nextInt(30)
                            ,UUID.randomUUID().toString()
                            ,UUID.randomUUID().toString()
                    )
            );
        }
        Iterator<User> iterator = userConcreteAggregate.iterator();
        System.out.println("==========遍历==========");
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }

        iterator.reset();

        System.out.println("==========随机删除==========");
        while (iterator.hasNext()){
            User user = iterator.next();
            if (random.nextBoolean()){
                iterator.remove();
                System.out.println("删除了："+user);
            }
        }

        iterator.reset();

        System.out.println("==========遍历==========");
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }

    }
}
```

##### 迭代器模式应用场景

JDK中已经有很多类实现了Iterator与Iterable接口，现在已经不需要手动写迭代器模式了，也尽量不要去写，直接使用JDK提供的即可

### 组合模式（合成模式、部分-整体模式）

##### 定义

将对象组合成树形结构以表示`部分——整体`的层次结构，使得用户对单个对象和组合对象的使用具有一致性

##### 角色

- Component抽象构件角色：定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性
- Leaf叶子构件：遍历的最小单位
- Composite树枝构件：组合树枝节点和叶子节点形成一个树形结构

##### 示例

抽象构件角色（员工）

```java
public abstract class Corp {
    private final String name;

    private final String position;

    private final int salary;

    public Corp(String name, String position, int salary) {
        this.name = name;
        this.position = position;
        this.salary = salary;
    }

    public String getInfo(){
        return "姓名：" +
                this.name +
                "\t职位：" +
                this.position +
                "\t薪水" +
                this.salary;
    }
}
```

叶子构件：

```java
public class Leaf extends Corp{

    public Leaf(String name, String position, int salary) {
        super(name, position, salary);
    }
}
```

树枝构件：

```java
public class Composite extends Corp{
    public Composite(String name, String position, int salary) {
        super(name, position, salary);
    }
    private LinkedList<Corp> corps=new LinkedList<>();

    public void addCorp(Corp corp){
        this.corps.add(corp);
    }

    public LinkedList<Corp> getCorps() {
        return corps;
    }
}
```

启动类：

```java
public class Client {

    private static String getTreeInfo(Composite root){
        LinkedList<Corp> corps = root.getCorps();
        StringBuilder info= new StringBuilder();
        for (Corp corp : corps) {
            if (corp instanceof Composite){
                info.append(corp.getInfo()).append("\n").append(getTreeInfo(((Composite) corp)));
            }else {
                info.append(corp.getInfo()).append("\n");
            }
        }
        return info.toString();
    }
    public static void main(String[] args) {
        Composite ceo = new Composite("张三", "总经理", 50000);
        Composite deptA = new Composite("李四", "A部门经理", 30000);
        Composite deptB = new Composite("王五", "B部门经理", 30000);
        Composite devGroup = new Composite("二元", "开发组组长", 25000);
        Leaf a = new Leaf(UUID.randomUUID().toString().substring(0,5), "CEO秘书", 40000);
        ceo.addCorp(deptA);
        ceo.addCorp(deptB);
        ceo.addCorp(a);
        deptA.addCorp(devGroup);
        for (int i = 0; i < 10; i++) {
            devGroup.addCorp(new Leaf(UUID.randomUUID().toString().substring(0,5), "码农", 20000));
        }
        System.out.println(getTreeInfo(ceo));
    }
}
```

##### 组合模式的优点

- 高层模块调用简单：节点都是构件，高层模块不必关心处理的是单个对象还是组合结构
- 节点自由增加

##### 组合模式的缺点

- 就像上面启动类中的代码，违背了依赖倒置原则

##### 组合模式的使用场景

- 维护和展示部分-整体关系的场景，例如树形菜单、文件和文件夹管理
- 从一个整体中能够独立出部分模块或功能的场景

##### 组合模式的注意事项

**只要是树形结构就要考虑使用组合模式**

##### 组合模式的扩展

###### 真实的组合模式

使用数据库保存树形关系

###### 透明的组合模式

组合模式有两种不同的实现：==透明模式==、==安全模式==，上面的是安全模式

透明模式：把上面add、remove等用来组合的方法放到抽象类中，叶子节点继承抽象类后，将这些方法不做操作，直接丢出异常即可

###### 组合模式的遍历

为所有节点添加一个父节点对象，这样既能够从树根出发遍历，也能从叶子出发找到根

### 观察者模式（发布订阅模式）

##### 定义

定义对象间一种一对多的依赖关系，是的每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新

##### 角色

- Subject被观察者：定义被观察者必须实现的职责，必须能够动态的增加、取消观察者、通知观察者
- Observer观察者：观察者接收到消息后就进行更新操作
- ConcreteSubject具体的被观察者
- ConcreteObserver具体的观察者

##### 示例

公司监视汇率

抽象观察者（公司）

```java
public interface Company {
    /**
     * 做出的反应
     * @param number 变化率
     */
    void response(int number);
}
```

抽象被观察者（汇率）

```java
public abstract class Rate {
    protected List<Company> companies = new ArrayList<>();
    /**
     * 增加观察者方法
     */
    public void add(Company company) {
        companies.add(company);
    }

    /**
     * 删除观察者方法
     */
    public void remove(Company company) {
        companies.remove(company);
    }

    /**
     * 变化
     * @param number 变化率
     */
    public abstract void change(int number);
}
```

观察者的两个实现类：进口公司、出口公司

```java
class ExportCompany implements Company {
    @Override
    public void response(int number) {
        if (number > 0) {
            System.out.println("人民币汇率升值" + number + "个基点，降低了出口产品收入，降低了出口公司的销售利润率。");
        } else if (number < 0) {
            System.out.println("人民币汇率贬值" + (-number) + "个基点，提升了出口产品收入，提升了出口公司的销售利润率。");
        }
    }
}
```

```java
class ImportCompany implements Company {
    @Override
    public void response(int number) {
        if (number > 0) {
            System.out.println("人民币汇率升值" + number + "个基点，降低了进口产品成本，提升了进口公司利润率。");
        } else if (number < 0) {
            System.out.println("人民币汇率贬值" + (-number) + "个基点，提升了进口产品成本，降低了进口公司利润率。");
        }
    }
}
```

具体的被观察者：人民币汇率

```java
public class RmbRate extends Rate{
    @Override
    public void change(int number) {
        for (Company obs : companies) {
            ((Company) obs).response(number);
        }
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) {
        Rate rate = new RmbRate();
        Company watcher1 = new ImportCompany();
        Company watcher2 = new ExportCompany();
        rate.add(watcher1);
        rate.add(watcher2);
        rate.change(10);
        rate.change(-9);
    }
}
```

##### 观察者模式的优点

- 观察者和被观察者之间是抽象耦合
- 建立了一套触发机制，实现了触发链条

##### 观察者模式的缺点

需要考虑开发效率和运行效率的问题，同步执行时容易出现阻塞

##### 观察者模式的使用场景

- 关联行为场景。关联行为是可拆分的，不是组合关系
- 事件多级触发场景
- 跨系统的信息交换场景（消息队列）

##### 观察者模式的注意事项

- 广播链问题

一个对象既可以是观察者，也可以是被观察者，这样就出现了消息传递链，当双重身份的类变多后，逻辑较为复杂不易维护，要求一个观察者模式中最多出现一个双重身份的类

- 与责任链模式的区别

观察者广播链在传播过程中消息是随时更改的，相邻两个节点就能决定消息结构和内容，责任链模式消息一般不可变

- 异步处理问题

需要考虑线程安全和队列问题

##### 观察者模式的扩展

###### JDK中的观察者模式

JDK中提供了接口：`Observer`以及一个可扩展的父类：`Observable`

> 观察者可以是实现接口`Observer的`任何对象。  在可观察到的实例发生变化之后，调用`Observable`的`notifyObservers`方法的应用程序会使其所有观察者通过调用其`update`方法通知更改。

修改示例中的代码

汇率类

```java
public class RmbRate extends Observable {

    public void increase(int number) {
        System.out.println("人民币汇率提高:"+number+"个百分点");
        super.setChanged();
        HashMap<String, Object> args = new HashMap<>(2);
        args.put("method","increase");
        args.put("param",number);
        super.notifyObservers(args);
    }

    public void decrease(int number) {
        System.out.println("人民币汇率下降:"+number+"个百分点");
        super.setChanged();
        HashMap<String, Object> args = new HashMap<>(2);
        args.put("method","decrease");
        args.put("param",number);
        super.notifyObservers(args);
    }
}
```

公司抽象类

```java
public abstract class Company implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        if (arg instanceof HashMap){
            HashMap<?, ?> hashMap = (HashMap<?, ?>) arg;
            String method = (String) hashMap.get("method");
            if ("increase".equals(method)){
                int number = ((Integer) hashMap.get("param"));
                this.responseForIncrease(number);
            }else if ("decrease".equals(method)){
                int number = ((Integer) hashMap.get("param"));
                this.responseForDecrease(number);
            }
        }
    }

    protected abstract void responseForIncrease(int number);

    protected abstract void responseForDecrease(int number);
}
```

公司类

```java
class ImportCompany extends Company {


    @Override
    protected void responseForIncrease(int number) {
        System.out.println("人民币汇率升值" + number + "个百分点，降低了进口产品成本，提升了进口公司利润率。");
    }

    @Override
    protected void responseForDecrease(int number) {
        System.out.println("人民币汇率贬值" + number + "个百分点，提升了进口产品成本，降低了进口公司利润率。");
    }
}
```

```java
class ExportCompany extends Company {


    @Override
    protected void responseForIncrease(int number) {
        System.out.println("人民币汇率升值" + number + "个百分点，降低了出口产品收入，降低了出口公司的销售利润率。");
    }

    @Override
    protected void responseForDecrease(int number) {
        System.out.println("人民币汇率贬值" + number + "个百分点，提升了出口产品收入，提升了出口公司的销售利润率。");
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) throws NoSuchMethodException {
        ExportCompany exportCompany = new ExportCompany();
        ImportCompany importCompany = new ImportCompany();
        RmbRate rmbRate = new RmbRate();
        rmbRate.addObserver(exportCompany);
        rmbRate.addObserver(importCompany);
        rmbRate.increase(5);

        rmbRate.decrease(10);
    }
}
```

###### 真实的观察者模式

- 消息沟通一般使用约定的格式例如XML、JSON等
- 观察者的响应方式：提高响应速度：多线程、缓存
- 被观察者不一定要通知所有的变化

### 门面模式（外观模式）

##### 定义

要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用

##### 角色

- Facade门面角色：客户端调用此角色的方法，此角色没有实际的业务逻辑，只是一个委托类
- subsystem子系统角色：可以同时有一个或者多个子系统。每一个子系统都是一个类的集合

##### 示例

子系统：

```java
public class Light {
    public void on(){
        System.out.println("打开了灯....");
    }

    public void off(){
        System.out.println("关闭了灯....");
    }
}
```

```java
public class Television {
    public void on(){
        System.out.println("打开了电视....");
    }

    public void off(){
        System.out.println("关闭了电视....");
    }
}
```

```java
public class AirCondition {
    public void on(){
        System.out.println("打开了空调....");
    }

    public void off(){
        System.out.println("关闭了空调....");
    }
}
```

门面类：

```java
public class Facade{
      
    Light light;
    Television television;
    AirCondition aircondition;

    public Facade(Light light,Television television,AirCondition aircondition){
        this.light = light;  
        this.television  = television ;  
        this.aircondition =aircondition;  
    
    }
    public void on(){
        System.out.println("起床了");
        light.on();
        television.on(); 
        aircondition.on();
    }

    public void off(){
        System.out.println("睡觉了");
        light.off();
        television.off();
        aircondition.off();
    }

}
```

启动类

```java
public class Client {
    public static void main(String[] args) {

        Light light = new Light();
        Television television = new Television();
        AirCondition aircondition = new AirCondition();

        //传参
        Facade facade = new Facade(light,television,aircondition);

        //客户端直接与外观对象进行交互
        facade.on();
        
        facade.off();
        
    }
}
```

##### 门面模式的优点

- 减少系统的相互依赖：不暴露子系统
- 提高灵活性
- 提高访问安全性：只有门面上使用的方法才能被访问

##### 门面模式的缺点

- 不符合开闭原则

##### 门面模式的使用场景

- 为一个复杂的模块或子系统提供一个供外界访问的接口
- 子系统相对独立
- 预防低水平人员带来的风险扩散

##### 门面模式的注意事项

- 一个子系统可以有多个门面

  多门面情况：

	1. 门面过于庞大
	1. 子系统可以提供不同访问路径

- 门面不参与子系统内的业务逻辑

上述示例中，门面类中的方法完成了子系统方法的组合，必须通过门面才能完成开关动作，也就是子系统需要依赖门面，违背了单一职责原则

修改上述代码，增加封装类完成开关动作

```java
public class Home {

    Light light;
    Television television;
    AirCondition aircondition;

    public Home(Light light,Television television,AirCondition aircondition){
        this.light = light;
        this.television  = television ;
        this.aircondition =aircondition;

    }

    public void on(){
        System.out.println("起床了");
        light.on();
        television.on();
        aircondition.on();
    }

    public void off(){
        System.out.println("睡觉了");
        light.off();
        television.off();
        aircondition.off();
    }
}
```

然后门面类只负责委托这个封装类即可

**门面角色应该稳定、不经常变化，业务逻辑的变化封装在了子系统中，对外门面保持不变**

### 备忘录模式

##### 定义

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态

##### 角色

- Originator发起人角色：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据
- Memento备忘录角色：存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态
- Caretaker备忘录管理员角色：对备忘录进行管理、保存和提供

##### 示例

发起人角色：

```java
public class GameRole {
    /**
     * vit 生命值
     * atk 攻击力
     * def 防御力
     */
    private int vit;
    private int atk;
    private int def;

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    public void display(){
        System.out.println("====now state====");
        System.out.println("生命值==>"+this.vit);
        System.out.println("攻击力==>"+this.atk);
        System.out.println("防御力==>"+this.def);
    }

    public void getInitState(){
        this.vit=100;
        this.atk=100;
        this.def=100;
    }

    public void fight(){
        this.vit=0;
        this.atk=0;
        this.def=0;
    }

    public RoleStateMemento saveState(){
        return new RoleStateMemento(this.vit, this.atk, this.def);
    }

    public void recoveryState(RoleStateMemento stateMemento){
        this.vit=stateMemento.getVit();
        this.atk=stateMemento.getAtk();
        this.def=stateMemento.getDef();
    }
}
```

发起者具有三个属性，且能够保存状态、恢复状态

备忘录角色

```java
public class RoleStateMemento {
    /**
     * vit 生命值
     * atk 攻击力
     * def 防御力
     */
    private int vit;
    private int atk;
    private int def;

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    public RoleStateMemento(int vit, int atk, int def) {
        this.vit = vit;
        this.atk = atk;
        this.def = def;
    }
}
```

一个简单地JavaBean

备忘录管理员角色

```java
public class RoleStateCaretaker {
    private RoleStateMemento memento;

    public RoleStateMemento getMemento() {
        return memento;
    }

    public void setMemento(RoleStateMemento memento) {
        this.memento = memento;
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) {
        GameRole gameRole = new GameRole();
        gameRole.getInitState();
        gameRole.display();

        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setMemento(gameRole.saveState());

        gameRole.fight();
        gameRole.display();

        gameRole.recoveryState(roleStateCaretaker.getMemento());
        gameRole.display();
    }
}
```

##### 备忘录模式的使用场景

- 需要保存和恢复数据的相关状态场景
- 提供一个可回滚的操作
- 需要监控的副本场景中：备份一个主线程中的对象
- 数据库连接的事务管理

##### 备忘录模式的注意事项

- 备忘录的生命期

建立就要使用，不使用就立刻删除

- 备忘录的性能

不要在频繁建立备份的场景中使用备忘录模式（比如循环），原因如下：

1. 控制不了备忘录建立的对象数量
2. 大对象的建立消耗资源

#### 备忘录模式的扩展

###### clone方式的备忘录

发起人实现`Cloneable`接口并重写clone方法即可，且不再需要备忘录角色

发起人：

```java
public class GameRole implements Cloneable{
    /**
     * vit 生命值
     * atk 攻击力
     * def 防御力
     */
    private int vit;
    private int atk;
    private int def;

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getAtk() {
        return atk;
    }

    public void setAtk(int atk) {
        this.atk = atk;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    public void display(){
        System.out.println("====now state====");
        System.out.println("生命值==>"+this.vit);
        System.out.println("攻击力==>"+this.atk);
        System.out.println("防御力==>"+this.def);
    }

    public void getInitState(){
        this.vit=100;
        this.atk=100;
        this.def=100;
    }

    public void fight(){
        this.vit=0;
        this.atk=0;
        this.def=0;
    }

    public RoleStateCaretaker saveState(){
        return new RoleStateCaretaker(this.clone());
    }

    public void recoveryState(RoleStateCaretaker caretaker){
        GameRole gameRole = caretaker.getGameRole();
        this.atk=gameRole.getAtk();
        this.def=gameRole.getDef();
        this.vit=gameRole.getVit();
    }

    @Override
    public GameRole clone() {
        try {
            return (GameRole) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

备忘录管理员

```java
public class RoleStateCaretaker {

    private GameRole gameRole;

    public GameRole getGameRole() {
        return gameRole;
    }

    public void setGameRole(GameRole gameRole) {
        this.gameRole = gameRole;
    }

    public RoleStateCaretaker(GameRole gameRole) {
        this.gameRole = gameRole;
    }
}
```

启动类

```java
public class Client {

    public static void main(String[] args) {

        GameRole gameRole = new GameRole();
        gameRole.getInitState();

        RoleStateCaretaker roleStateCaretaker = gameRole.saveState();

        gameRole.display();
        gameRole.fight();
        gameRole.display();

        RoleStateCaretaker roleStateCaretaker1 = gameRole.saveState();

        gameRole.recoveryState(roleStateCaretaker);
        gameRole.display();

        gameRole.recoveryState(roleStateCaretaker1);
        gameRole.display();

    }
}
```

###### 多状态的备忘录

例如上面的例子中，发起人具有三个属性组成的状态，可以使用HashMap键值对的形式进行存储或者采用数据库等方案

###### 多备份的备忘录

即在不同的时间点对状态进行备份，可以将备忘录管理者中的状态改为HashMap类型进行存储，或者使用数据技术。

### 访问者模式

##### 定义

封装一些作用域某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作

##### 角色

- Visitor抽象访问者：抽象类或者接口，声明访问者可以访问那些元素
- ConcreteVisitor具体访问者
- Element抽象元素：接口或抽象类，声明接收哪一类访问者访问
- ConcreteElement具体元素：实现accept方法，接受一个访问者
- ObjectStruture结构对象：元素生产者，一般容纳在多个不同类、不同接口的容器，如List等，项目中一般很少抽象出这个角色

##### 示例

抽象访问者

```java
public interface IVisitor {

    void visit(ConcreteElementA elementA);

    void visit(ConcreteElementB elementB);

}
```

具体访问者

```java
public class Visitor implements IVisitor{
    @Override
    public void visit(ConcreteElementA elementA) {
        elementA.process();
    }

    @Override
    public void visit(ConcreteElementB elementB) {
        elementB.process();
    }
}
```

抽象元素

```java
public abstract class Element {

    private final String id;

    public abstract void process();

    public abstract void accept(IVisitor visitor);

    public Element(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}
```

具体元素

```java
public class ConcreteElementA extends Element{
    public ConcreteElementA(String id) {
        super(id);
    }

    @Override
    public void process() {
        System.out.println(this.getClass().getName());
        System.out.println(super.getId());
        System.out.println();
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}
```

```java
public class ConcreteElementB extends Element{
    public ConcreteElementB(String id) {
        super(id);
    }

    @Override
    public void process() {
        System.out.println(this.getClass().getName());
        System.out.println(super.getId());
        System.out.println();
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) {
        for (Element element : elements(9)) {
            element.accept(new Visitor());
        }
    }

    private static LinkedList<Element> elements(int n){
        LinkedList<Element> elements = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            elements.add(new ConcreteElementA(UUID.randomUUID().toString()));
            elements.add(new ConcreteElementB(UUID.randomUUID().toString()));
        }
        return elements;
    }
}
```

##### 访问者模式的优点

- 符合单一职责原则：元素角色负责数据加载，访问者角色负责数据的展示
- 扩展性好： 如果还要增加对数据的操作，直接在Visitor中添加一个方法
- 灵活性高：对不同的元素可以将不同的操作封装在Visitor中

##### 访问者模式的缺点

- 具体元素对访问者公布细节，违背了迪米特法则
- 具体元素变更比较困难：修改具体元素的成员变量
- 违背了依赖倒转原则

##### 访问者模式的使用场景

- 一个对象结构包含很多类对象，它们有不同的接口，需要为这些对象进行一些依赖具体类的操作，迭代器模式无法完成
- 需要对一个对象结构中的对象进行很多不同并且不相关的操作，且不想这些操作污染这些对象的类

**==业务要求要遍历多个不同的对象时考虑访问者模式==**

**访问者模式是对迭代器模式的扩充**

*访问者模式还能充当拦截器*

##### 访问者模式的扩展

###### 统计功能

在IVisitor接口中定义一个用于统计的方法，然后在实现类中的每个访问方法中将要统计的属性（例如求和）记录在一个成员变量中，这个统计的方法将这个成员变量返回，这样就可以统计不同对象、甚至可以使用不同的规则例如加权等统计方式

###### 多访问者

定义多个访问者，这些访问者可能存在不同的逻辑，这样我们可以为每个功能抽象一个接口，这些接口都继承IVisitor接口，这样通过访问不同的访问者就可以达到不同的目的

###### 双分派

> 单分派：
>
> ​	单分派语言处理一个操作是根据请求者的名称和接收到的参数决定的，在Java中有静态绑定和动态绑定，依据重载和重写实现
>
> 双分派：
>
> ​	得到执行的操作决定于请求的种类和两个接收者的类型，是多分派的一个特例，Java是支持双分派的单分派语言

场景：演员演戏

定义演员抽象类

```java
public abstract class AbstractActor {

    public void act(Role role){
        System.out.println("扮演任意角色");
    }

    public void act(KungFuRoleImpl role){
        System.out.println("功夫角色");
    }
}
```

定义年轻演员类

```java
public class YoungActor extends AbstractActor{
    @Override
    public void act(KungFuRoleImpl role) {
        System.out.println("年轻演员扮演功夫角色");
    }
}
```

定义角色接口及实现类

```java
public interface Role {

}
```

```java
public class KungFuRoleImpl implements Role{
}
```

启动类如下：

```java
public class Client {
    public static void main(String[] args) {
        AbstractActor actor = new YoungActor();
        Role role = new KungFuRoleImpl();
        actor.act(role);
        actor.act(new KungFuRoleImpl());
    }
}
```

输出为：

```shell
扮演任意角色
年轻演员扮演功夫角色
```

> 原因分析：
>
> ​	role表面类型是Role接口抽象类，编译时就由此决定了act调用的是哪个重载，，第二个act是由实际类型决定的，属于动态绑定

使用访问者模式来解决这个问题

修改角色接口，增加accept方法

```java
public interface Role {
    void accept(AbstractActor abstractActor);
}
```

实现这个方法

```java
public class KungFuRoleImpl implements Role {
    @Override
    public void accept(AbstractActor abstractActor) {
        abstractActor.act( this);
    }
}
```

启动类

```java
public class Client {
    public static void main(String[] args) {
        AbstractActor actor = new YoungActor();
        Role role = new KungFuRoleImpl();
        role.accept(actor);
        new KungFuRoleImpl().accept(actor);
    }
}
```

这样第一次调用就不会调用父类的方法

不管演员类和角色类怎么变化，都能找到期望的方法执行，就是双分派，

### 状态模式

##### 定义

当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类

核心是**封装**，状态的变更引起行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样

##### 角色

- State抽象状态角色：接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换
- ConcreteState具体状态角色：每一个具体状态必须完成两个职责，本状态的行为管理以及趋向状态处理，即本状态要做的事和如何过渡到其他状态
- Context环境角色：定义客户端需要的接口，并且负责具体状态的切换

##### 示例

抽象状态角色

```java
public abstract class State {

    protected Context context;

    public void setContext(Context context) {
        this.context = context;
    }

    /**
     * 行为1
     */
    public abstract void handle1();

    /**
     * 行为2
     */
    public abstract void handle2();
}
```

抽象环境角色

```java
public class Context{

    public final static State STATE_1=new ConcreteState1();

    public final static State STATE_2=new ConcreteState2();

    private State currentState;

    public State getCurrentState() {
        return currentState;
    }

    public void setCurrentState(State currentState) {
        this.currentState = currentState;
        //每个状态都绑定当前环境对象
        this.currentState.setContext(this);
    }

    public void handle1() {
        this.currentState.handle1();
    }

    public void handle2() {
        this.currentState.handle2();
    }
}
```

具体状态角色

```java
public class ConcreteState1 extends State{
    @Override
    public void handle1() {
        System.out.println(this.getClass().getName()+"is handling");
    }

    @Override
    public void handle2() {
        this.context.setCurrentState(Context.STATE_2);
        this.context.handle2();
    }
}
```



```java
public class ConcreteState2 extends State{
    @Override
    public void handle1() {
        this.context.setCurrentState(Context.STATE_1);
        this.context.handle1();
    }

    @Override
    public void handle2() {
        System.out.println(this.getClass().getName()+"is handling");
    }
}
```

在调用自己无法完成的方法时，进行状态切换并调用可用实现

启动类

```java
public class Client {
    public static void main(String[] args) {
        Context context = new Context();
        context.setCurrentState(new ConcreteState1());
        context.handle1();
        context.handle2();
    }
}
```

##### 状态模式的优点

- 结构清晰，避免了过多的分支语句
- 遵循设计原则，很好的体现了开闭原则和单一职责原则
- 封装性好，状态变换发生在类的内部

##### 状态模式的缺点

子类太多容易出现类膨胀

##### 状态模式的使用场景

- 行为随状态改变而改变的场景,例如权限设计
- 条件、分支判断语句的替代者

##### 状态模式注意事项

使用时对象的状态最好不要超过五个



### 解释器模式

##### 定义

给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子

##### 角色

- AbstractExpression抽象解释器
- TerminalExpression终结符表达式
- NonterminalExpression非终结符表达式
- Context环境角色

##### 示例

抽象解释器

```java
public abstract class Expression {

    /**
     * 解析公式和数据
     * @param var key为公式参数，value为具体的数字
     * @return 数字
     */
    public abstract int interpreter(HashMap<String, Integer> var);
}
```

变量解析器，非终结符表达式

```java
public class VarExpression extends Expression{

    private final String key;

    public VarExpression(String key) {
        this.key = key;
    }

    @Override
    public int interpreter(HashMap<String, Integer> var) {
        return var.get(this.key);
    }
}
```

抽象运算符号解析器

```java
public abstract class SymbolExpression extends Expression{

    protected Expression left;

    protected Expression right;

    public SymbolExpression(Expression left, Expression right){
        this.left = left;
        this.right = right;
    }
}
```

加法解析器

```java
public class AddExpression extends SymbolExpression{
    public AddExpression(Expression left, Expression right) {
        super(left, right);
    }

    @Override
    public int interpreter(HashMap<String, Integer> var) {
        return this.left.interpreter(var)+this.right.interpreter(var);
    }
}
```

减法解析器

```java
public class SubExpression extends SymbolExpression{
    public SubExpression(Expression left, Expression right) {
        super(left, right);
    }

    @Override
    public int interpreter(HashMap<String, Integer> var) {
        return this.left.interpreter(var) - this.right.interpreter(var);
    }
}
```

封装运算器类

```java
public class Calculator {

    private Expression expression;

    public Calculator(String expStr) {
        Stack<Expression> stack = new Stack<>();
        char[] chars = expStr.toCharArray();

        Expression left;

        Expression right;

        for (int i = 0; i < chars.length; i++) {
            switch (chars[i]){
                case '+':
                    left=stack.pop();
                    right=new VarExpression(String.valueOf(chars[++i]));
                    stack.push(new AddExpression(left,right));
                    break;
                case '-':
                    left=stack.pop();
                    right=new VarExpression(String.valueOf(chars[++i]));
                    stack.push(new SubExpression(left,right));
                    break;
                default:
                    stack.push(new VarExpression(String.valueOf(chars[i])));
            }
        }
        this.expression=stack.pop();
    }

    public int run(HashMap<String, Integer> var){
        return this.expression.interpreter(var);
    }
}
```

启动类

```java
public class Client {

    public static void main(String[] args) throws IOException {
        String expStr=getExpStr();
        HashMap<String, Integer> var=getValue(expStr);
        Calculator calculator = new Calculator(expStr);
        System.out.println("运算结果为："+calculator.run(var));
    }
	
    //获取公式中各变量的值
    private static HashMap<String, Integer> getValue(String expStr) throws IOException {
        HashMap<String, Integer> map = new HashMap<>();
        for (char c : expStr.toCharArray()) {
            if (c!='+'&&c!='-'){
                if (!map.containsKey(String.valueOf(c))){
                    String in=new BufferedReader(new InputStreamReader(System.in)).readLine();
                    map.put(String.valueOf(c),Integer.valueOf(in));
                }
            }
        }
        return map;
    }
	//获取公式
    private static String getExpStr() throws IOException {
        System.out.println("请输入表达式");
        return new BufferedReader(new InputStreamReader(System.in)).readLine();
    }

}
```

输入公式a+b-c，然后分别输入a、b、c的值，得出结果

过程解析：

1. 调用Calculator中的构造方法，因为表达式的最后一个运算符为减法，所以解析后的expression为SubExpression，这个减法表达式又由一个加法表达式和变量表达式组成：

   ![image-20210921222535749](/设计模式/image-20210921222535749.png)

2. 调用run方法开始执行运算，先是调用减法表达式的interpreter方法，然后又调用加法的interpreter方法和变量表达式的interpreter方法，层层向下，直到两端操作数都是变量表达式

3. 向上计算得出结果

##### 解释器模式的优点

扩展性好，若需要修改语法规则只需要修改相应的非终结符表达式即可；若扩展语法则只要增加非终结符类即可

##### 解释器模式的缺点

- 解释器模式会引起类膨胀：每个语法都要产生一个非终结符表达式
- 解释器模式采用递归调用方法：调试复杂
- 效率问题：使用了大量循环和递归

##### 解释器模式的使用场景

- 重复发生的问题可以使用解释器模式
- 一个简单语法需要解释的场景

##### 解释器模式的注意事项

尽量不要在重要模块中使用解释器模式，维护成本高



### 享元模式

##### 定义

使用共享对象可有效地支持大量的细粒度的对象

##### 角色

- Flyweight抽象享元角色：一个产品的抽象类，定义出对象的外部状态和内部状态
- ConcreteFlyweight具体享元角色：具体产品类，实现抽象业务，内部状态应该与环境无关，一个操作不应该同时修改了外部状态和内部状态
- unsharedConcreteFlyweight不可共享的享元角色：不存在外部状态或安全要求不能够使用共享技术的对象
- FlyweightFactory享元工厂：构造池容器，同时提供从池中获取对象的方法

