# 切片

- 切片是数组的一个引用，是引用类型。如果修改切片的某个元素，则原数组的对应元素会被修改。
- 切片的长度可以改变，切片是可变的数组。
- 使用 cap 可以得到切片最大扩张容量，不超过所引用的数组的大小。

创建切片：

```go
a := [...][2]int{{1, 2}, {3, 4}, {5, 6}}

var slice1 []int // 只声明
slice2 := []int{} // 指向空数组
var slice3 []int = make([]int, 0)
var slice4 []int = make([]int, 0, 0)
var slice5 []int = a[0][0:1] // 截取数组的一部分，前闭后开
```

现有这样一个数组 `a := [...]int{1, 2, 3, 4, 5, 6}`，为切片赋值：

```go
slice = a[:] // 包含数组 a 的所有元素。
slice = a[3:] // 包含从数组指定下标开始的后续所有元素，包含指定下标元素。
slice = a[:3] // 包含从数组第一个元素到指定下标的所有元素，不包含指定下标元素。
slice = a[0:5] // 包含数组指定区间的所有元素，左闭右开。
```

切片追加：

```go
a := []int{1, 2, 3, 4, 5, 6}
slice := append(a, a...) // 第二个参数是一个元素，如果要传入数组要使用三个点拆分数组。
fmt.Println(slice)
```

append 向切片尾部添加数据返回新的切片对象。

如果超出最大扩张容量，会重新分配底层数组，即使原数组没有填满，即切片指向了另一个数组，后续修改切片不会影响原数组。

切片复制：

```go
slice2 := make([]int, 10, 20)
slice3 := make([]int, 20)
copy(slice2, slice)
copy(slice3, slice)
```

copy 函数在两个切片之间复制，源切片是第二个参数，复制长度以长度小的为准，如果源切片长度超过了后面切片的长度，即使有扩张容量也不会复制超出部分。

## 字符串和切片

字符串底层是数组，因此也可以进行切片操作。

```go
str := string("这是一个字符串")
slice := []rune(str)[1:3]
fmt.Println(string(slice))
```
