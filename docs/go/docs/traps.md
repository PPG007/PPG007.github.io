# Golang Traps

- 可变参数是空接口类型时，传入空接口的切片要注意参数展开问题：

    ```go
    var a = []interface{}{1, 2, 3}
    fmt.Println(a)
    fmt.Println(a...)
    ```

- 数组是值传递，如果数组做函数参数那么在函数中的修改将不起作用，可以使用切片。

- map 的遍历顺序是不固定的，每次遍历顺序可能都不一样。

- recover 必须在 defer 语句中，且这个语句是一个函数的执行。

- 并发时注意主线程退出导致其他线程结束。

- 不同 goroutine 之间不满足顺序一致性内存模型。

- 闭包错误地引用同一个变量。

    ```go
    func main() {
      for i := 0; i < 5; i++ {
        defer func ()  {
          fmt.Println(i)// 全部是 5，可以通过每轮循环生成一个局部变量或者通过函数参数传入解决。
        }()
      }
    }
    ```

- defer 语句在函数退出时才会执行，如果在循环体中使用 defer 语句将会在循环结束后执行，如果希望每次循环后执行可以去掉 defer 并将语句放在循环体最后或者将 defer 后语句封装为一个函数。
