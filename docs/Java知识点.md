# 继承中代码的执行顺序

1. 父类静态对象，父类静态代码块
2. 子类静态对象，子类静态代码块
3. 父类非静态对象，父类非静态代码块
4. 父类构造函数
5. 子类费静态对象，子类非静态代码块
6. 子类构造函数

> 如果子类重写了父类中的某些方法，则创建子类时，父类的代码块、构造器中使用到被重写的方法都会被替换为重写后的方法

不会初始化子类的几种

- 调用的是父类的static方法或者字段
- 调用的是父类的final方法或者字段
- 通过数组来引用

# 引用传递与值传递

Java中处理8种基本的数据类型用的是值传递，其他所有类型都用的是引用传递

==按引用传递的实质是将地址值的副本作为实参代替方法中的形参==

例如下面的代码

```java
@Test
public void test1(){
    Integer integer = new Integer(11);
    System.out.println(integer.intValue());
    change(integer);
    System.out.println(integer.intValue());
}

public void change(Integer integer){
    integer=new Integer(123);
}
```

两次输出都是11，因为change方法中修改的是引用副本的指向，源引用不变，

> 如果对引用的内部成员进行操作，则会直接影响到原对象，但是如果直接把此引用指向了其他对象，这个引用从此以后，便与之前的对象没有任何关系，当前代表的仅仅是新指向的对象。

# 接口与抽象类

### 抽象类

在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：

- 抽象类不能被实例化只能被继承；

- 包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；

- JDK 1.8以前，抽象类的方法默认访问权限为protected

  JDK 1.8时，抽象类的方法默认访问权限变为default

- 一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；

- 抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。



### 接口

Java中接口使用interface关键字修饰，特点为:

- 接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；

- 接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；

- 一个类可以实现多个接口；

- JDK1.8中对接口增加了新的特性：

  - 默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；

  - 静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。

  - JDK 1.8以前，接口中的方法必须是public的

    JDK 1.8时，接口中的方法可以是public的，也可以是default的

    JDK 1.9时，接口中的方法可以是private的

​    注意：**jdk1.9是允许接口中出现private修饰的默认方法和静态方法**。

# is-a、has-a、like-a

强调继承关系，is-a，如果A is-a B，那么B就是A的父类；

代表组合关系，like-a，接口，如果A like a B，那么B就是A的接口。 ；

强调从属关系，has-a，如果A has a B，那么B就是A的组成部分。

# 三目运算符

### 三目运算符返回值类型规则

- 若两个操作数不可转换，则不做转换，返回值为Object类型
- 若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。
- 若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。
- 若两个操作数都是直接量数字，则返回值类型为范围较大者

```java
Object o1 = true? new Integer(1) : new Double(2.0);
```

上面的语句符合第四条，返回double

```java
byte b = 1;
char c = 1;
short s = 1;
int i = 1;

// 三目，一边为byte另一边为char，结果为int
// 其它情况结果为两边中范围大的。适用包装类型
i = true ? b : c; // int
b = true ? b : b; // byte
s = true ? b : s; // short

// 表达式，两边为byte,short,char，结果为int型
// 其它情况结果为两边中范围大的。适用包装类型
i = b + c; // int
i = b + b; // int
i = b + s; // int

// 当 a 为基本数据类型时，a += b，相当于 a = (a) (a + b)
// 当 a 为包装类型时， a += b 就是 a = a + b
b += s; // 没问题
c += i; // 没问题

// 常量任君搞，long以上不能越
b = (char) 1 + (short) 1 + (int) 1; // 没问题
// i = (long) 1 // 错误
```

# switch可选参数

switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。**String类型是java7开始支持。**

本质上支持的参数都是可以转换为int的，String起始比较的是hashcode

# ThreadLocal内存泄漏问题

### 引用类型

##### 强引用

Strong Reference，例如Object o=new Object();

只要对象有强引用指向且GC Roots可达，即使内存即将溢出也不会回收这个对象

##### 软引用

Soft Reference，强度弱于强引用

在即将OOM之前软引用指向的对象将被回收，一般用来缓存服务器中间计算结果以及不需要实时保存的用户行为等

##### 弱引用

Weak Reference，强度更弱，用来描述非必需对象

如果指向的对象只有弱引用，则下次YGC（新生代GC，频率比较高）将会回收，但是YGC时间上具有不确定性，弱引用何时被回收也具有不确定性。弱引用主要用于指向某个易消失的对象，在强引用断开后，此引用不会劫持对象，调用get可能返回null

##### 虚引用

Phantom Reference，强度最弱，定义完成后就无法通过该引用获取指向的对象。

为一个对象设置虚引用的唯一目的就是希望能在这个对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用，在GC时，如果发现存在虚引用，就会在回收前将这个虚引用加入到引用队列中

### 内存泄漏问题

每个Thread线程内部都有一个Map

Map里存储线程本地对象做key，线程变量副本做value

Map由ThreadLocal维护，ThreadLocal负责向map获取和设置线程的变量值

ThreadLocal的内部类ThreadLocalMap的内部类Entry的key是弱引用，value为强引用，ThreadLocal在没有外部对象的强引用时，发生GC会回收key，当线程没有结束，但ThreadLocal（key）被回收时，存在key为null的键值对，造成内存泄漏

### 解决方案

- 每次使用完ThreadLocal都调用remove

# JVM运行时数据区

![image-20210921165251872](/Java知识点/image-20210921165251872.png)

### 程序计数器

程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，**线程私有**

### Java虚拟机栈

Java虚拟机栈也是**线程私有的**，生命周期与线程相同。

虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个==栈帧==用于存储**局部变量表**、**操作数栈**、**动态连接**、**方法出口**等信息。每一个方法被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

### 本地方法栈

作用与虚拟机栈类似，区别在于虚拟机栈为执行==字节码==服务，本地方法栈为执行==本地native方法==服务

### Java堆

几乎所有对象实例都在这分配内存

新生代、老年代、永久代、Eden空间、From Survivor空间、To Survivor空间

### 方法区

用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 运行时常量池

==是方法区的一部分==，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有**常量池表**，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

### 直接内存

堆外内存，不受JVM管理，I/O性能好



# GC



# 索引设计原则

1. 适合索引的列是出现在 where子句中的列,或者连接子句中指定的列
2. 基数较小的表,索引效果较差,没有必要在此列建立索引
3. 使用短索引,如果对长字符串列进行索引,应该指定一个前缀长度,这样能够节省大量索引空间,如果搜索词超过索引前缀长度,则使用索引排除不匹配的行,然后检查其佘行是否可能匹配。
4. 不要过度索引。索引需要额外的磁盘空间,并降低写操作的性能。在修改表內容的时候,索引会进行更新甚至重构,索引列越多,这个时间就会越长。所以只保持需要的索引有利于查询即可。
5. 定义有外键的数据列一定要建立索引
6. 更新频繁字段不适合创建索引
7. 若是不能有效区分数据的列不适合做索引列(如性别,男女未知,最多也就三种,区分度实在太低)
8. 尽量的扩展索引,不要新建索引。比如表中已经有a的索引,现在要加(a,b)的索引,那么只需要修改原来的索引即可
9. 对于那些查询中很少涉及的列,重复值比较多的列不要建立索引
10. 对于定义为text、 Image和bit的数据类型的列不要建立索引。

# MySQL锁的分类

### 基于属性分类

- 共享锁

共享锁又称为读锁，简称S锁，当一个事务为数据加上读锁以后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能进行加写锁，读取数据时不允许修改防止重复读

- 排它锁

又称写锁，简称X锁，当一个事务为数据加上写锁时，其它请求不能再为数据加任何锁，避免了出现脏数据和脏读的问题

### 基于粒度分类

- 行级锁

上锁的时候锁定的是表的某一行或多行，其他事务访问时，只有这些行才不能访问

- 表级锁

表锁是指上锁时锁定的对象是整个表，当下一个事务访问该表的时候，必须等待前一个事务释放锁才能进行访问

- 页级锁

粒度介于行级锁和表级锁之间，一次锁定相邻的一组记录，会出现死锁

- 记录锁



- 间隙锁

属于行锁的一种，锁住的是表记录的某一段区间，边界遵循左开右闭，只会出现在重复读的事务级别中，防止幻读问题

- 临建锁

是行锁的一种，是INNODB的行锁默认算法，是间隙锁和记录锁的组合，临建锁会把查询出来的记录锁住，同时把查询范围内的所有间隙控件锁住，把相邻的下一个区间也锁住；触发条件：==范围查询并命中，查询命中了索引==，避免了脏读、重复读、幻读问题

### 基于状态分类

意向锁：让其他事务知道表中已经加锁

- 意向共享锁

当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁

- 意向排它锁

当一个事务试图对整个表加排它锁之前，首先需要获得这个表的意向排它锁

# 事务的基本特性及隔离级别

### ACID

- 原子性
- 一致性：数据库总是从一个一致性状态转换到另外一个一致性的状态
- 隔离性：一个事务在最终提交前对其他事务不可见
- 持久性：事务一旦提交，所做的修改会永久的保存到数据库中

### 四个隔离级别

- 读未提交

可能会读到其他事务未提交的数据，也叫==脏读==

- 读已提交

两次读取结果不同，叫做==不可重复读==

不可重复读解决了脏读的问题，只会读取已经提交的事务

- 可重复读

MySQL默认级别，每次读取结果都一样，但有可能产生幻读

- 串行

一般不使用，会给每一行读取的数据加锁，导致大量超时和锁竞争问题

### ACID由何保证

- 原子性：由undo log保证，记录了要回滚的日志信息，事务回滚是撤销已经执行成功的SQL
- 一致性：由其他三大特性保证、程序代码要保证业务上的一致性
- 隔离性：由MVCC来保证
- 持久性：由内存+redo log来保证，MySQL修改数据同时要在内存和redo log记录这次操作，宕机时可以从redo log恢复

### MVCC

**多版本并发控制**：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务会话会看到自己特定版本的数据

MVCC只在读已提交和可重复读两个隔离级别下工作

开始事务时创建readview，readview维护当前活动的事务id，即未提交的事务id，排序生成一个数组，访问数据，获取数据中的事务ID，获取的是事务ID最大的记录，对比readview

- 如果在readview左边，说明该事务已提交，可以访问
- 如果在readview右边或者就在readview中间，说明该事务未提交，不可以访问，根据roll_pointer取上一版本重新对比

读已提交级别下的事务在每次查询的开始都会生成一个独立的ReadView，而可重复读级别则在第一次读的时候生成一个ReadView，之后读都复用之前的ReadView

# MySQL索引的类型

- 普通索引：允许被索引的数据列包含重复的值
- 唯一索引：可以保证数据记录的唯一性
- 主键：是一种特殊的唯一索引
- 联合索引：索引可以覆盖多个数据列，最左优先
- 全文索引：通过建立倒排索引可以极大地提升检所效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术

> 索引可以极大地提高数据的查询速度
>
> 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
>
> 但是会降低插入、删除、更新表的速度
>
> 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有的非聚集索引都会跟着变

 
