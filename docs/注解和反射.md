# 1.内置注解
### 1.1 @Override
- 表示当前方法覆盖了父类的方法

>此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。如果方法利用此注释类型进行注解但没有重写超类方法，则编译器会生成一条错误消息
### 1.2 @Deprecated
- 表示方法已经过时,方法上有横线，使用时会有警告。
>此注释可用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。在使用不被赞成的程序元素或在不被赞成的代码中执行重写时，编译器会发出警告
### 1.3 @SuppressWarings
- 表示关闭一些警告信息(通知java编译器忽略特定的编译警告)
>用来抑制编译时的警告信息。与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数值都是已经定义好了的，我们选择性的使用就好了
- @SuppressWarings的可选参数
![@SuppressWarings的可选参数](/注解和反射/@SuppressWarings的可选参数.jpg)
例如：
```java
@SuppressWarnings(value={“unchecked”, “deprecation”})
```
# 2.元注解
元注解顾名思义我们可以理解为注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能。元注解分别有 **@Retention、 @Target、 @Document、 @Inherited和@Repeatable**（JDK1.8加入）五种。
### 2.1 @Retention
Retention英文意思有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）。在@Retention注解中使用**枚举RetentionPolicy**来表示注解保留时期
```java
/**
 * @author 16582
 */
@Retention(RetentionPolicy.CLASS)
@interface annotation1{
//    默认的保留策略，注解在class字节码文件中存在，但运行时无法获得
}

/**
 * @author 16582
 */
@Retention(RetentionPolicy.RUNTIME)
@interface annotation2{
//    注解会在class字节码文件中存在，在运行时可以通过反射获取到
}

/**
 * @author 16582
 */
@Retention(RetentionPolicy.SOURCE)
@interface annotation3{
    //注解只存在于源码中，class字节码文件中不包含
}
```
>如果我们是自定义注解，则通过前面分析，我们自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 @Retention(RetentionPolicy.RUNTIME)
### 2.2 @Target
Target的英文意思是目标，这也很容易理解，使用@Target元注解表示我们的注解作用的范围就比较具体了，可以是类，方法，方法参数变量等，同样也是通过**枚举类ElementType**表达作用类型
- 一般比较常用的是ElementType.TYPE类型
```java
@Target(ElementType.TYPE)
@interface annotation4{
//    作用接口、类、枚举、注解
}

@Target(ElementType.FIELD)
@interface annotation5{
//    作用属性字段、枚举的常量
}

@Target(ElementType.METHOD)
@interface annotation6{
//    作用方法
}

@Target(ElementType.PARAMETER)
@interface annotation7{
//    作用方法参数
}

@Target(ElementType.CONSTRUCTOR)
@interface annotation8{
//    作用构造函数
}

@Target(ElementType.LOCAL_VARIABLE)
@interface annotation9{
//    作用局部变量
}

@Target(ElementType.ANNOTATION_TYPE)
@interface annotation10{
//    作用于注解
//    @Retention注解中就使用该属性
}

@Target(ElementType.PACKAGE)
@interface annotation11{
//    作用于包
}

@Target(ElementType.TYPE_PARAMETER)
@interface annotation12{
//    作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8加入）
}

@Target(ElementType.TYPE_USE)
@interface annotation13{
//    可以用于标注任意类型除了 class （jdk1.8加入）
}
```
### 2.3 @Document
Document的英文意思是文档。它的作用是能够将注解中的元素包含到 Javadoc 中去。
### 2.4 @Inherited
Inherited的英文意思是继承，但是这个继承和我们平时理解的继承大同小异，一个被@Inherited注解了的注解修饰了一个父类，它的子类也会继承父类的注解。
```java
@Target(ElementType.TYPE)
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@interface InheritedTest{

}

@InheritedTest
class Father{

}

class Son extends Father{

}
public class MetaAnnotation {
    public static void main(String[] args) {
        Class<Son> sonClass = Son.class;
        Annotation[] annotations = sonClass.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation);
        }

    }
}
```
### 2.5 @Repeatable
Repeatable的英文意思是可重复的。顾名思义说明被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。
```java
/**
 * 一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，
 * 则我们需要定义一个人的注解，
 * 他属性代表喜欢玩游戏集合，
 * 一个游戏注解，游戏属性代表游戏名称
 * @author 16582*/
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface People {
    Game[] value() ;
}
/**游戏注解
 * @author 16582*/
@Repeatable(People.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Game {
    String value() default "";
}
/**玩游戏类*/
@Game(value = "LOL")
@Game(value = "PUBG")
@Game(value = "NFS")
@Game(value = "Dirt4")
class PlayGame {
}
```
# 3. 注解的属性
注解的属性其实和类中定义的变量有异曲同工之处，只是注解中的变量都是成员变量（属性），并且**注解中是没有方法**的，只有成员变量，变量名就是使用注解括号中对应的参数名，变量返回值注解括号中对应参数类型。相信这会你应该会对上面的例子有一个更深的认识。而@Repeatable注解中的变量则类型则是对应Annotation（接口）的泛型Class。
```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Repeatable {
    /**
     * Indicates the <em>containing annotation type</em> for the
     * repeatable annotation type.
     * @return the containing annotation type
     */
    Class<? extends Annotation> value();
}
```
# 4. 注解的本质
- 注解的本质就是一个Annotation接口
```java
/**Annotation接口源码*/
public interface Annotation {

    boolean equals(Object obj);

    int hashCode();

    Class<? extends Annotation> annotationType();
}
```
注解本身就是Annotation接口的子接口，也就是说注解中其实是可以有属性和方法，但是接口中的属性都是static final的，对于注解来说没什么意义，而我们定义接口的方法就相当于注解的属性，也就对应了前面说的为什么注解只有属性成员变量，其实他就是接口的方法，这就是为什么成员变量会有括号，不同于接口我们可以在注解的括号中给成员变量赋值。
# 5.注解属性类型
- 注解属性类型可以有以下列出的类型
1. 基本数据类型
2. String
3. 枚举类型
4. 注解类型
5. Class类型
6. 以上类型的一维数组类型
# 6.注解成员变量赋值
```java
@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyTestAnnotation {
    String name() default "mao";
    int age() default 18;
}

@MyTestAnnotation(name = "father",age = 50)
public class Father {
}
```
# 7.获取注解属性
- 通过反射获取注解的属性

基本方法：
```java
/**是否存在对应 Annotation 对象*/
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
    return GenericDeclaration.super.isAnnotationPresent(annotationClass);
}

/**获取 Annotation 对象*/
public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
    Objects.requireNonNull(annotationClass);

    return (A) annotationData().annotations.get(annotationClass);
}
/**获取所有 Annotation 对象数组*/   
public Annotation[] getAnnotations() {
    return AnnotationParser.toArray(annotationData().annotations);
}    
```
示例：
在获取之前我们自定义的注解必须使用元注解@Retention(RetentionPolicy.RUNTIME)
```java
public class GetValueTest {
    public static void main(String[] args) throws Exception {
        Class<?> aClass = Class.forName("annotation.Test");

        MyTestAnnotation myTestAnnotation = aClass.getAnnotation(MyTestAnnotation.class);
        System.out.println("annotation.name==>"+myTestAnnotation.name());
        System.out.println("annotation.sex==>"+myTestAnnotation.sex());

        Field test = aClass.getDeclaredField("test");
        test.setAccessible(true);
        Age age = test.getAnnotation(Age.class);
        System.out.println("age.value==>"+age.value());

        Method show = aClass.getDeclaredMethod("show", int.class);
        MethodAnnotation methodAnnotation = show.getAnnotation(MethodAnnotation.class);
        System.out.println("method name==>"+methodAnnotation.methodName());
        Parameter[] parameters = show.getParameters();
        for (Parameter parameter : parameters) {
            Param param = parameter.getAnnotation(Param.class);
            System.out.println(param.value());
        }

        java.lang.reflect.Constructor<?> declaredConstructor = aClass.getDeclaredConstructor();
        Constructor constructor = declaredConstructor.getAnnotation(Constructor.class);
        System.out.println(constructor.constructor());

    }
}

/**
 * @author 16582
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Age{
    int value();
}

/**
 * @author 16582
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface MyTestAnnotation{
    String name();
    String sex();
}

/**
 * @author 16582
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@interface MethodAnnotation{
    String methodName();
}

/**
 * @author 16582
 */
@Target(ElementType.CONSTRUCTOR)
@Retention(RetentionPolicy.RUNTIME)
@interface Constructor{
    String constructor();
}

/**
 * @author 16582
 */
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
@interface Param{
    String value();
}

@MyTestAnnotation(name = "ppg",sex = "man")
class Test{
    @Age(21)
    private String test;

    @MethodAnnotation(methodName = "show")
    public void show(@Param("show方法有一个a参数")int a){

    }

    @Constructor(constructor = "Test的构造函数")
    public Test() {
    }
}
```
# 8.使用注解进行参数配置
假设银行有个转账业务，转账的限额可能会根据汇率的变化而变化，我们可以利用注解灵活配置转账的限额，而不用每次都去修改我们的业务代码。
```java
/**定义限额注解
 * @author 16582*/
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface BankTransferMoney {
    double maxMoney() default 10000;
}
```
```java
/**转账处理业务类
 * @author 16582*/
public class BankService {
    /**
     * @param money 转账金额
     */
    @BankTransferMoney(maxMoney = 15000)
    public static void transferMoney(double money){
        System.out.println(processAnnotationMoney(money));

    }
    private static String processAnnotationMoney(double money) {
        try {
            Method transferMoney = BankService.class.getDeclaredMethod("transferMoney",double.class);
            boolean annotationPresent = transferMoney.isAnnotationPresent(BankTransferMoney.class);
            if(annotationPresent){
                BankTransferMoney annotation = transferMoney.getAnnotation(BankTransferMoney.class);
                double l = annotation.maxMoney();
                if(money>l){
                   return "转账金额大于限额，转账失败";
                }else {
                    return"转账金额为:"+money+"，转账成功";
                }
            }
        } catch ( NoSuchMethodException e) {
            e.printStackTrace();
        }
        return "转账处理失败";
    }
    public static void main(String[] args){
        transferMoney(10000);
    }
}
```
# 9.Class对象
```java
public class Test1 {
    public static void main(String[] args) throws ClassNotFoundException {
//        一个类在内存中只有一个Class对象
//        一个类被加载后，类的整个结构都会封装在Class对象中

//        方式一：通过对象.getClass()获得
        User user = new User();
        Class<? extends User> aClass1 = user.getClass();
        System.out.println(aClass1.hashCode());
//        方式二：forName,适用于运行时动态获取Class对象
        Class<?> aClass = Class.forName("reflection.entity.User");
        System.out.println(aClass.hashCode());
//        方式三：通过类名.Class
        Class<User> userClass = User.class;
        System.out.println(userClass.hashCode());
//        方式四：基本内置类型的包装类都有一个Type属性
        Class<Integer> type = Integer.TYPE;
        System.out.println(type.getName());
    }
}
```
# 10.反射常用方法
```java
//        含包名
System.out.println(testClass.getName());

//        不含包名
System.out.println(testClass.getSimpleName());

//        获取类修饰符
//        getModifiers返回一个int，使用Modifier类的方法可以进行判断
System.out.println(testClass.getModifiers());
System.out.println(Modifier.isPublic(testClass.getModifiers()));

//        获取包信息
System.out.println(testClass.getPackage());

//        获取父类的class对象
System.out.println(testClass.getSuperclass());

//        获取接口信息，不包含父类实现的接口
for (Class<?> anInterface : testClass.getInterfaces()) {
    System.out.println(anInterface);
}

//        获取构造函数,只能获取到public修饰的构造函数。需要捕获NoSuchMethodException异常。
for (Constructor<?> constructor : testClass.getConstructors()) {
    System.out.println(constructor);
}

//        通过无参构造器创建对象，没有无参构造器会报错
User user = (User) aClass.newInstance();
System.out.println(user);

// 有参构造器创建对象
Constructor<?> declaredConstructor = aClass.getDeclaredConstructor(String.class, int.class);
Object ppg = declaredConstructor.newInstance("ppg", 123);
System.out.println(ppg);

//        通过反射调用普通方法
//        通过反射获取一个方法
//        如果调用的是static方法，invoke()方法第一个参数就用null代替：
Method getName = aClass.getDeclaredMethod("getName");
Method getId = aClass.getMethod("getId");
Object invoke = getName.invoke(ppg);
Object invoke1 = getId.invoke(ppg);
System.out.println("ppg==>"+invoke+invoke1);

//        通过反射设置属性
Field id = aClass.getDeclaredField("id");
//        设置允许修改private属性
id.setAccessible(true);
// 对象名，值
id.set(ppg,1);
System.out.println("ppg==>"+ppg);

// 泛型
public void fx(Map<String, String> map, List<Boolean> booleans) {
        System.out.println("success");
}
Class<Fx> fxClass = Fx.class;
Method fx = fxClass.getMethod("fx", Map.class,List.class);
//        获得泛型的参数类型
Type[] genericParameterTypes = fx.getGenericParameterTypes();
for (Type genericParameterType : genericParameterTypes) {
    System.out.println("泛型的参数类型："+genericParameterType);
    //泛型的参数类型是否等于参数化类型
    if (genericParameterType instanceof ParameterizedType){
        //getActualTypeArguments获得真实的参数类型信息
        Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();
        for (Type actualTypeArgument : actualTypeArguments) {
            System.out.println(actualTypeArgument);
        }

    }
}
```
# 11.类加载器
```java
public class ClassLoaderTest {
    public static void main(String[] args) throws ClassNotFoundException {
//        获取系统类的加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);
//        获取系统类加载器的父类->扩展类加载器
        ClassLoader parent = systemClassLoader.getParent();
        System.out.println(parent);

//        获取扩展类加载器的父类->根加载器(C++编写，获取为null)
        ClassLoader parent1 = parent.getParent();
        System.out.println(parent1);

        Class<?> aClass = Class.forName("reflection.ClassLoaderTest");
        ClassLoader classLoader = aClass.getClassLoader();
        System.out.println(classLoader);

        Class<?> aClass1 = Class.forName("java.lang.Object");
        ClassLoader classLoader1 = aClass1.getClassLoader();
        System.out.println(classLoader1);

//        获取系统类加载器可以加载的路径
        String property = System.getProperty("java.class.path");
        System.out.println(property);
    }
}
```
