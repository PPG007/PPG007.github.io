# 1.实现多线程的基本方法

### 1.1 继承Thread类
- 继承Thread类，重写run()方法，调用start开启线程
```java
public class ThreadTest extends Thread{
    @Override
    public void run() {
//        不一定立即执行
        for (int i = 0; i < 10; i++) {
            System.out.println("run Thread===>"+i);
        }
    }

    public static void main(String[] args) {
//        创建一个线程对象
        ThreadTest threadTest = new ThreadTest();
//        调用start()方法开启线程
        threadTest.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("run main===>"+i);
        }

    }
}
```
### 1.2 实现Runnable接口
- 实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法
```java
public class Test implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("run Thread===>"+i);
        }
    }

    public static void main(String[] args) {
        Test test = new Test();
        Thread thread = new Thread(test);
        thread.start();
        for (int i = 0; i < 100; i++) {
            System.out.println("run main===>"+i);
        }
    }
}
```
### 1.3 实现Callable接口
- 实现Callable接口，重写call方法，通过线程池或FutureTask执行
```java
public class CallableDownload implements Callable<String> {
    private String url;
    private String name;

    public CallableDownload(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        Downloader downloader = new Downloader();
        downloader.download(url,name);
        System.out.println("From "+url+" download "+name);
        return "success";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableDownload downloadImage = new CallableDownload("http://112.126.61.130/download/src/2021.jpg","1283.jpg");
        CallableDownload downloadImage1 = new CallableDownload("http://112.126.61.130/download/src/1.jpg","1.jpg");
//        创建执行服务
        ExecutorService executorService = Executors.newFixedThreadPool(3);
//        提交执行
        Future<String> submit = executorService.submit(downloadImage);
        Future<String> submit1 = executorService.submit(downloadImage1);
//        获取结果
        String result = submit.get();
        String result2 = submit1.get();
//        关闭服务
        executorService.shutdown();
    }
}
class Downloader{
    public void download(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            System.out.println("thread.Downloader Error");
        }
    }
}
```
- FutureTask
```java
public class CallableDownload implements Callable<String> {
    private String url;
    private String name;

    public CallableDownload(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public String call() throws Exception {
        Downloader downloader = new Downloader();
        downloader.download(url,name);
        System.out.println("From "+url+" download "+name);
        return "success";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableDownload downloadImage = new CallableDownload("http://112.126.61.130/download/src/2222.jpg","1283.jpg");
        CallableDownload downloadImage1 = new CallableDownload("http://112.126.61.130/download/src/1.jpg","1.jpg");

        FutureTask<String> stringFutureTask = new FutureTask<String>(downloadImage);
        FutureTask<String> stringFutureTask1 = new FutureTask<String>(downloadImage1);
        new Thread(stringFutureTask).start();
        new Thread(stringFutureTask1).start();
    }
}
class Downloader{
    public void download(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            System.out.println("thread.Downloader Error");
        }
    }
}
```
# 2. 函数式接口
==任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口，可以使用lambda表达式==

### 2.1 示例
- 接口
```java
public interface MyInterface {
    /**
     * 抽象方法
     * @param a 参数
     */
    void show(int a);
}
```
- 运行
```java
public static void main(String[] args) {

    MyInterface myInterface = new MyInterface() {
        @Override
        public void show(int a) {
            System.out.println("匿名内部类，参数==> "+a);
        }
    };
    myInterface.show(1);

    MyInterface myInterface1= a -> System.out.println("lambda param is ==> "+a);
    myInterface1.show(2);
}
```
### 2.2 四大函数式接口
==java.util.function==
##### 2.2.1 Function
```java
@FunctionalInterface
// 传入T类型，返回R类型
public interface Function<T, R> {

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
```
简单使用
```java
Function<String, String> function=(s -> s+"??");
System.out.println(function.apply("test"));
```
##### 2.2.2 Predicate
==断言型接口，有一个输入参数，返回一个布尔值==
```java
@FunctionalInterface
public interface Predicate<T> {

    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
```
简单使用
```java
Predicate<Integer> integerPredicate=integer -> integer >100;
System.out.println(integerPredicate.test(21));
System.out.println(integerPredicate.test(210));
```
##### 2.2.3 Consumer
==消费型接口，接收一个参数，没有返回值==
```java
@FunctionalInterface
public interface Consumer<T> {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
```
简单使用
```java
Consumer<String> stringConsumer= System.out::println;
stringConsumer.accept("test");
```
##### 2.2.4 Supplier
==供给型接口，没有参数，只有返回值==
```java
@FunctionalInterface
public interface Supplier<T> {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```
简单使用
```java
Supplier<String> stringSupplier=()->{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("t").append("e").append("s").append("t");
    return stringBuilder.toString();
};
System.out.println(stringSupplier.get());
```
### 2.3 Stream流式计算
==stream接口==
简单使用
```java
users.stream()
        .sorted(Comparator.comparingInt(User::getAge))
//                过滤年龄大于等于10
        .filter(user -> user.getAge() >= 10)
//                过滤ID是偶数的
        .filter(user -> user.getId()%2==0)
        .map(user -> user.getName().toUpperCase())
        // 限制输出数量
        .limit(3)
        .forEach(System.out::println);
```
并行计算
```java
// DoubleStream IntStream ……
long reduce = LongStream.rangeClosed(0L, 100_0000_0000L)
                // 并行流
                .parallel()
                
                .reduce(0, Long::sum);
```
# 3.synchronized同步锁
### 3.1 修饰方法，此时锁的是调用方法的对象
```java
public class BuyTicket implements Runnable{

    private static Integer ticketNum=10;
    private boolean flag=true;
    @Override
    public void run() {
//        ticketNum：监视器
        while (flag){
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
//    锁方法或锁代码块
    private synchronized void buy() throws InterruptedException {
        if (ticketNum==0){
            flag=false;
            return ;
        }
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName()+"拿到"+ticketNum--);
    }

    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();

        new Thread(buyTicket,"user1").start();
        new Thread(buyTicket,"user2").start();
        new Thread(buyTicket,"user3").start();
    }
}
```
### 3.2 修饰变量
```java
public class BuyTicket2 implements Runnable{
    private static Integer num=10;
    private boolean flag=true;
    public static void main(String[] args) {
        BuyTicket2 buyTicket = new BuyTicket2();
        new Thread(buyTicket,"user1").start();
        new Thread(buyTicket,"user2").start();
        new Thread(buyTicket,"user3").start();
    }

    @Override
    public void run() {
        while (flag){
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void buy() throws InterruptedException {
        // 获取资源
        synchronized (num){
            if (num>0){
                System.out.println(Thread.currentThread().getName()+"拿到了"+num--);
            }else {
                flag=false;
            }
        }
    }
}
```
### 3.3 死锁
##### 3.3.1 出现死锁的情况
```java
public class DeadLock {
    public static void main(String[] args) {
        Consumer consumer1 = new Consumer();
        Consumer consumer2 = new Consumer();
        consumer1.setFlag(true);
        consumer2.setFlag(false);
        new Thread(consumer1,"consumer1").start();
        new Thread(consumer2,"consumer2").start();

    }
}
class SourceA{

}
class SourceB{

}
class Consumer implements Runnable{

    private final static SourceA sourceA=new SourceA();
    private final static SourceB sourceB=new SourceB();
    private boolean flag;
    @Override
    public void run() {
        try {
            test();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void test() throws InterruptedException {
        if (flag){
            // 已经拥有一个资源时，再请求其他资源容易出现死锁
            synchronized (sourceA){
                System.out.println(Thread.currentThread().getName()+"获得了资源A");
                Thread.sleep(1000);
                synchronized (sourceB){
                    System.out.println(Thread.currentThread().getName()+"获得了资源B");
                }
            }
        }
        else {
            synchronized (sourceB){
                System.out.println(Thread.currentThread().getName()+"获得了资源B");
                Thread.sleep(1000);
                synchronized (sourceA){
                    System.out.println(Thread.currentThread().getName()+"获得了资源A");
                }
            }
        }
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```
##### 3.3.2 死锁发现与解决
>使用Java bin文件夹中的jps工具：jps -l定位进程号

![jps-l](/多线程/jps-l.jpg)
>使用jstack [进程号]查看进程堆栈找到死锁问题

![jps-l](/多线程/jstack.jpg)
### 3.4 生产者消费者问题
##### 3.4.1 管程法
1. synchronized实现
- 管道
```java
public class Pool extends AbstractPool{
    private Product[] products=new Product[5];
    private int length=-1;
    @Override
    public void add(Product product){
        synchronized (products){
            // 等待总是应该出现在循环中，防止虚假唤醒
            while (length==4){
                try {
                    System.out.println("仓库已满");
                    products.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            ++length;
            products[length]=product;
            products.notifyAll();
        }


    }
    @Override
    public Product get(){
        synchronized (products){
            while (length==-1){
                try {
                    System.out.println("仓库为空");
                    products.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Product product = products[length];
            length--;
            products.notifyAll();
            return product;
        }

    }
}
```
- 生产者
```java
public class Provider extends Thread{
    private AbstractPool pool;

    public Provider(AbstractPool pool) {
        this.pool = pool;
    }
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            pool.add(new Product(i));
            System.out.println("生产了第"+i+"个产品");
        }
    }
}
```
- 消费者
```java
public class Consumer extends Thread{
    private AbstractPool pool;

    public Consumer(AbstractPool pool) {
        this.pool = pool;
    }

    @Override
    public void run() {
        while (true){
            System.out.println("消费了第"+pool.get().getId()+"个产品");
        }
    }
}
```
- wait方法
>该线程释放此监视器的所有权，并等待另一个线程通知等待==该对象==监视器的线程通过调用notify方法或notifyAll方法notifyAll 。 然后线程等待，直到它可以重新获得监视器的所有权并恢复执行。
2. 使用PV操作实现
```java
public class PoolC extends AbstractPool{

    private static LinkedList<Product> list=new LinkedList<>();
    private static ReentrantLock lock = new ReentrantLock();
    // 同步信号量
    private Condition empty = lock.newCondition();
    private Condition full = lock.newCondition();

    @Override
    public void add(Product product) {
        try {
            lock.lock();
            while (list.size()!=0){
                empty.await();
            }
            for (int i = 1; i <= 5; i++) {
                list.add(new Product(i));
                TimeUnit.SECONDS.sleep(1);
                System.out.println("生产了产品:"+i);
            }
            full.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    @Override
    public Product get() {
        try {
            lock.lock();
            while (list.size()!=5){
                full.await();
            }
            for (int i = 1; i <= 5; i++) {
                TimeUnit.SECONDS.sleep(1);
                System.out.println("消费了产品:"+list.pop().getId());
            }
            empty.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
        return null;
    }
}
```
##### 3.4.2 信号灯法
>来判断一个标志位flag，如果为true，就让他等待、如果为false，就让他去通知另外一个人、把两人衔接起来，就像咱们的信号灯红灯停，绿灯行，通过这样一个判断方式，只要来判断什么瑞后让他等待，什么时候将他唤醒就ok
```java
package com.macro.mall.bo;
//测试生产者消费者问题2：信号灯法，通过标志位解决

public class Test {
    public static void main(String[] args) {
        TV tv = new TV();
        new Player(tv).start();
        new Watcher(tv).start();
    }
}

//生产者-->演员
class Player extends Thread {
    TV tv;

    public Player(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (i % 2 == 0) {
                this.tv.play("什么是快乐星球");
            } else {
                this.tv.play("如果你想知道什么是快乐星球的话，那我就带你研究研究");
            }
        }
    }
}

//消费者-->观众
class Watcher extends Thread {
    TV tv;

    public Watcher(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}

//产品-->节目
class TV {
    //演员表演，观众等待 T
    //观众观看，演员等待 F
    String voice; // 表演的节目
    boolean flag = true;


    //表演
    public synchronized void play(String voice) {

        if (!flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("演员表演了：" + voice);
        //通知观众观看
        this.notifyAll();
        this.voice = voice;
        this.flag = !this.flag;
    }

    //观看
    public synchronized void watch() {
        if (flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("观看了：" + voice);
        //通知演员表演
        this.notifyAll();
        this.flag = !this.flag;
    }
}
```
### 4.线程操作
### 4.1 线程停止stop
1. 建议线程正常停止-->利用次数，不建议死循环
2. 建议使用标志位-->设置一个标志位
3. 不要使用stop或者destroy等过时的方法
```java
public class ThreadStop implements Runnable{

    private Boolean flag=true;

    @Override
    public void run() {
        int i=1;
        while (flag){
            System.out.println("Thread is running ==> "+i++);
        }
    }

    public void stop(){
        this.flag=false;
    }

    public static void main(String[] args) {
        ThreadStop threadStop = new ThreadStop();
        new Thread(threadStop).start();
        for (int i = 0; i < 90000; i++) {

        }
        threadStop.stop();
    }
}
```
### 4.2 线程休眠sleep
- 线程休眠存在异常InterruptedException，且睡眠过程中不会释放锁
```java
public class ThreadSleep{

    private int start=10000;
    public void show() throws InterruptedException {
        while (start>0){
            // 单位是毫秒
            Thread.sleep(1);
            System.out.println(start--);
        }
    }
    public static void main(String[] args) throws InterruptedException {
        new ThreadSleep().show();
    }
}
```
==sleep和wait的区别==
1. wait会释放锁，sleep不会
2. wait必须在同步代码块中，sleep可以在任何地方
3. wait不需要捕获异常
### 4.3 线程礼让yield
- 当前线程暂停但是不阻塞，线程由运行态转为就绪态，由CPU重新调度，不一定能礼让成功
```java
public class ThreadYield {
    public static void main(String[] args) {
        YieldTest yieldTest = new YieldTest();
        new Thread(yieldTest,"a").start();
        new Thread(yieldTest,"b").start();
    }
}
class YieldTest implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"线程开始执行");
        Thread.yield();
        System.out.println(Thread.currentThread().getName()+"线程结束执行");
    }
}
```
### 4.4 线程强制执行join
等待此线程执行完毕后，其他线程继续执行，期间其他线程阻塞
```java
public class ThreadJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("vip来了"+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ThreadJoin threadJoin = new ThreadJoin();
        Thread thread = new Thread(threadJoin);
        thread.start();
        for (int i = 0; i < 500; i++) {
            if (i==200){
                // main线程阻塞
                // 输出main200后，先输出所有的vip再输出剩下的main
                thread.join();
            }
            System.out.println("main"+i);
        }
    }
}
```
### 4.5 观测线程状态
- ==NEW== 线程尚未启动
- ==RUNNABLE== 线程正在执行
- ==TIMED_WAITING== 等待另一个线程执行指定动作达到指定等待时间Thread.sleep()
- ==TERMINATED== 结束的线程
- ==BLOCKED== 线程阻塞
- ==WAITING== 等待另一个线程执行特定动作
```java
public class ThreadState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread=new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("//////////");
        });

        System.out.println(thread.getState());

        thread.start();
        System.out.println(thread.getState());

        while (thread.getState()!= Thread.State.TERMINATED){
            Thread.sleep(100);
            System.out.println(thread.getState());
        }
    }
}
```
### 4.6 守护线程
```java
public class DaemonTest {
    public static void main(String[] args) {
        Daemon daemon = new Daemon();
        Thread thread = new Thread(daemon, "daemon");
        // 开启守护线程，默认为false
        thread.setDaemon(true);
        thread.start();
        BeenDaemon beenDaemon = new BeenDaemon();
        new Thread(beenDaemon).start();
    }
}
class Daemon implements Runnable{
    @Override
    public void run() {
        while (true){
            System.out.println("守护线程");
        }
    }
}
class BeenDaemon implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 36600; i++) {
            System.out.println("living");
        }
        System.out.println("ending");
    }
}
```
### 4.7 线程优先级
- JDK：
```java
// 优先级最小值
public final static int MIN_PRIORITY = 1;
// 优先级默认值
public final static int NORM_PRIORITY = 5;
// 优先级最大值
public final static int MAX_PRIORITY = 10;
```
- 设置优先级
优先级低只代表获取调度的概率低，优先级低的不一定会比优先级高的执行的慢或晚
```java
public class PriorityTest {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getPriority());
        MyPriority myPriority = new MyPriority();
        Thread thread = new Thread(myPriority, "t1");
        thread.setPriority(1);
        thread.start();
        Thread thread1 = new Thread(myPriority, "t2");
        thread1.setPriority(5);
        thread1.start();
        Thread thread2 = new Thread(myPriority, "t3");
        thread2.setPriority(10);
        thread2.start();
    }
}
class MyPriority implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 214748364; i++) {
            
        }
        System.out.println(Thread.currentThread().getName()+" ===> "+Thread.currentThread().getPriority());
    }
}
```
# 5.线程池
### 5.1 使用Executors创建
- Executors三大方法
1. 单个线程的线程池
```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
```
2. 固定大小的线程池
```java
// 参数为当前环境的CPU核心数
ExecutorService service = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
```
3. 可变线程池
```java
Executor executor = Executors.newCachedThreadPool();
```
- 使用示例
```java
public class PoolTest {
    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        service.execute(new Test());
        service.execute(new Test());
        service.execute(new Test());
        service.execute(new Test());
        service.execute(new Test());
        // 关闭线程池
        service.shutdown();
    }
}
class Test implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```
>FixedThreadPool和SingleThreadExecutor底层都是用LinkedBlockingQueue实现的，这个队列最大长度为Integer.MAX_VALUE，容易导致OOM。所以实际生产一般自己通过ThreadPoolExecutor的7个参数，自定义线程池
### 5.2 手动创建线程池
- JDK中创建线程池源码
```java
public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```
- 七大参数解释
    - corePoolSize线程池的基本大小
    >当新任务在方法 execute(java.lang.Runnable) 中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。
    - maximumPoolSize能容纳的最大线程数(池子的最大容量)，如果使用了无界的任务队列PriorityBlockingQueue这个参数就没什么效果，此值与CPU核心数和有关
    - keepAliveTime空闲线程存活时间，超时不用会释放
    >如果池中当前有多于 corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止
    - unit 存活的时间单位
    - workQueue 存放提交但未执行任务的队列，阻塞队列
    - threadFactory 创建线程的工厂类
    - handler 等待队列满后的拒绝策略

==最大并发：能容纳的最大线程数(池子的最大容量)+阻塞队列大小==
```java
public class PoolTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService threadPool=new ThreadPoolExecutor(2,5,
                1L, TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
        threadPool.submit(new Test()).get();
        threadPool.shutdown();
    }
}
class Test implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```
- 四大拒绝策略
```java
// 多余不处理，抛出异常
public static class AbortPolicy implements RejectedExecutionHandler
// 哪里来回哪去,交由原线程处理
public static class CallerRunsPolicy implements RejectedExecutionHandler
// 队列满了，去和最久的任务竞争，没有异常
public static class DiscardOldestPolicy implements RejectedExecutionHandler
// 丢掉任务，没有异常
public static class DiscardPolicy implements RejectedExecutionHandler
```
### 5.3 使用依赖包创建
```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>r09</version>
</dependency>
```
```java
public class ThreadPool {
    public static void main(String[] args) {
        //获取系统处理器个数，作为线程池数量
        int nThreads = Runtime.getRuntime().availableProcessors();
        // 不使用JDK提供的线程创建工厂
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat("demo-pool-%d").build();

//Common Thread Pool
        ExecutorService pool = new ThreadPoolExecutor(5, 200,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());

        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.execute(new MyThread());
        pool.shutdown();
    }
}
class MyThread implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName()+i);
        }
    }
}
```
# 6. Lock锁
### 6.1 Lock接口
>Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition 。
- 实现类
1. ReentrantLock 可重入锁
2. ReentrantReadWriteLock.ReadLock 读锁
3. ReentrantReadWriteLock.WriteLock 写锁
### 6.2 公平锁和非公平锁
- 公平锁：可以先来后到
- 非公平锁：可以插队
创建可重入锁对象时，可以通过构造器指定是公平锁还是非公平锁，无参构造器返回非公平锁
### 6.3 Demo
```java
public class LockTest {
    public static void main(String[] args) {
        TestLock testLock = new TestLock();
        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}
class TestLock implements Runnable{

    private static int num=10;
    // 创建Lock对象
    private final ReentrantLock lock=new ReentrantLock();
    @Override
    public void run() {
        for (;;){
            // 锁【lock.lock】必须紧跟try代码块，且unlock要放到finally第一行。
            try {
                // 加锁
                lock.lock();
                if (num>0){
                    System.out.println("ticket number==>"+num--);
                    Thread.sleep(1000);
                }else {
                    break;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 解锁
                lock.unlock();
            }


        }
    }
}
```
### 6.4 Lock和synchronized的区别
1. synchronized是Java关键字，Lock是一个接口
2. synchronized无法判断获取锁的状态，lock可以判断是否获取到了锁(isLocked())
3. synchronized会自动释放锁，Lock需要手动释放锁
4. synchronized会让其他线程一直等待，Lock不一定
5. synchronized可重入，不可中断，非公平。Lock可重入锁，可以判断锁，公平性可设置
6. synchronized适于少量代码同步问题，Lock适合大量代码
# 7. 集合不安全
### 7.1 List不安全
- 解决方案：
1. Vector
```java
Vector<String> strings = new Vector<>();
```
Vector的add方法安全的原因：
使用了synchronized关键字
```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
```
2. Collections.synchronizedList
```java
List<Object> objects = Collections.synchronizedList(new ArrayList<>());
```
3. CopyOnWriteArrayList写入时复制
```java
CopyOnWriteArrayList<String> strings = new CopyOnWriteArrayList<>();
```
### 7.2 Set不安全
- 解决方案
1. Collections.synchronizedSet
```java
Set<Object> objects = Collections.synchronizedSet(new HashSet<>());
```
2. CopyOnWriteArraySet
```java
CopyOnWriteArraySet<String> strings = new CopyOnWriteArraySet<>();
```
- HashSet底层原理
通过HashMap的键确保不会重复
```java
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```
### 7.3 Map不安全
##### 7.3.1 HashMap的扩容机制和加载因子
- 默认加载因子、默认初始容量、最大容量
```java
public class HashMap<K,V>extends AbstractMap<K,V>implements Map<K,V>, Cloneable, Serializable{
    //  默认的初始容量（容量为HashMap中桶的数目）是16，且实际容量必须是2的整数次幂。 
    static final int DEFAULT_INITIAL_CAPACITY = 16;
    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）
    static final int MAXIMUM_CAPACITY = 1 << 30;
    // 默认加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    //... 省略
}
```
>最大容量等于默认加载因子和初始容量的乘机；他的作用是用来预警的，如果HashMap中的容量超过这个阀值了，那就会执行扩容操作，低于则没事
- 加载因子
>加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。

==所以如果你心目中有明确的Map 大小，设定时一定要考虑加载因子的存在。==
扩容阈值就是初始桶大小(默认16)乘以加载因子
- HashMap含参构造器：
```java
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                            initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                            loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
```
# 8. 8锁问题
==8锁问题，即关于锁的8个问题==
### 8.1 标准情况
```java
public class EightLock {
    public static void main(String[] args) throws InterruptedException {
        先输出A再输出B
        Data data = new Data();
        new Thread(()->{
            data.a();
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            data.b();
        }).start();
    }
}
class Data {
    public synchronized void a(){
        System.out.println("A");
    }
    public synchronized void b(){
        System.out.println("B");
    }
}
```
### 8.2 a()方法延迟4秒
synchronized锁的是方法调用者，两个方法是同一个锁，谁先拿到谁执行
```java
class Data {
    public synchronized void a() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("A");
    }
    public synchronized void b(){
        System.out.println("B");
    }
}
```
### 8.3 增加一个普通方法
```java
public class EightLock {
    public static void main(String[] args) throws InterruptedException {
        // 输出：C A
        Data data = new Data();
        new Thread(()->{
            try {
                data.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            data.c();
        }).start();
    }
}
class Data {
    public synchronized void a() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("A");
    }
    public synchronized void b(){
        System.out.println("B");
    }
    // 非同步方法，不受锁的影响
    public void c(){
        System.out.println("C");
    }
}
```
### 8.4 两个对象，两个同步方法
```java
public class EightLock {
    public static void main(String[] args) throws InterruptedException {
        // 两个对象，两个调用者，两把锁
        // 输出：B A
        Data data = new Data();
        Data data1 = new Data();
        new Thread(()->{
            try {
                data.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            data1.b();
        }).start();
    }
}
class Data {
    public synchronized void a() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("A");
    }
    public synchronized void b(){
        System.out.println("B");
    }

    public void c(){
        System.out.println("C");
    }
}
```
### 8.5 增加两个静态同步方法，只有一个对象
```java
public class EightLock {
    public static void main(String[] args) throws InterruptedException {
        // 输出：A B
        Data data = new Data();
        Data data1 = new Data();
        new Thread(()->{
            try {
                data.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            data.b();
        }).start();
    }
}
class Data {
    // 静态方法在类加载时就被加载，锁的是Class对象，Class对象全局唯一
    public static synchronized void a() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("A");
    }
    public static synchronized void b(){
        System.out.println("B");
    }

    public void c(){
        System.out.println("C");
    }
}
```
### 8.6 两个对象，两个静态同步方法
```java
public class EightLock {
    public static void main(String[] args) throws InterruptedException {
        // 输出：A B
        Data data = new Data();
        Data data1 = new Data();
        new Thread(()->{
            try {
                data.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            data1.b();
        }).start();
    }
}
```
### 8.7 一个静态同步方法，一个普通同步方法，一个对象
```java
public class EightLock {
    public static void main(String[] args) throws InterruptedException {
        // 输出：B A
        Data data = new Data();
        Data data1 = new Data();
        new Thread(()->{
            try {
                data.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            data.b();
        }).start();
    }
}
class Data {
    public static synchronized void a() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("A");
    }
    public synchronized void b(){
        System.out.println("B");
    }

    public void c(){
        System.out.println("C");
    }
}
```
### 8.8 一个静态同步方法，一个普通同步方法，两个对象
```java
public class EightLock {
    public static void main(String[] args) throws InterruptedException {
        // 输出：B A
        Data data = new Data();
        Data data1 = new Data();
        new Thread(()->{
            try {
                data.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            data1.b();
        }).start();
    }
}
class Data {
    public static synchronized void a() throws InterruptedException {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("A");
    }
    public synchronized void b(){
        System.out.println("B");
    }

    public void c(){
        System.out.println("C");
    }
}
```
# 9.常用辅助类
### 9.1 CountDownLatch
>CountDownLatch用给定的计数初始化。 await方法阻塞，直到由于countDown()方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的await 调用立即返回。 这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用CyclicBarrier 。 
```java
public class Utils {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for (int i = 0; i < 5; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"run");
                // 数量减一
                countDownLatch.countDown();
            },String.valueOf(i)).start();
        }
        // 等待计数器归零，再向下执行
        countDownLatch.await();
        System.out.println("all Thread Run");
    }
}
```
### 9.2 CyclicBarrier
>允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。 
```java
public class Utils {
    public static void main(String[] args) throws InterruptedException {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5,()->{
            System.out.println("all Thread runn");
        });
        for (int i = 0; i < 5; i++) {
            // lambda表达式中不能直接访问i
            int finalI = i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"run");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```
### 9.3 Semaphore
>一个计数信号量。 在概念上，信号量维持一组许可证。 如果有必要，每个acquire()都会阻塞，直到许可证可用，然后才能使用它。 每个release()添加许可证，潜在地释放阻塞获取方。 但是，没有使用实际的许可证对象; Semaphore只保留可用数量的计数，并相应地执行。 
信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源。 例如，这是一个使用信号量来控制对一个项目池的访问的类
==此类的构造函数可选择接受公平参数。 当设置为false时，此类不会保证线程获取许可的顺序。==
```java
public class Utils {
    public static void main(String[] args) throws InterruptedException {
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 6; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"get the position");
                    Thread.sleep(3000);
                    System.out.println(Thread.currentThread().getName()+"leave the position");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}
```
# 10.读写锁
>ReadWriteLock维护一对关联的locks ，一个用于只读操作，一个用于写入。 read lock可以由多个阅读器线程同时进行，只要没有作者。 write lock是独家的。
```java
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        Cache cache = new Cache();
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(()->{
                cache.put(""+ finalI,""+ finalI);
            },String.valueOf(i)).start();
        }
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(()->{
                cache.read(""+ finalI);
            },String.valueOf(i)).start();
        }
    }
}
class Cache{
    private volatile HashMap<String, String> hashMap=new HashMap<>();
    // 自定义公平性
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);

    public void put(String key,String value){
        // 写锁
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"写入"+key);
            hashMap.put(key, value);
            System.out.println(Thread.currentThread().getName()+"写入完成");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            // 放开写锁
            readWriteLock.writeLock().unlock();
        }
    }

    public void read(String key){
        // 读锁
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"读取"+key);
            System.out.println(hashMap.get(key));
            System.out.println(Thread.currentThread().getName()+"读取完成");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            // 放开读锁
            readWriteLock.readLock().unlock();
        }
    }
}
```
# 11.阻塞队列
==写入：如果队列满了，就必须阻塞等待==
==取：如果队列为空，就必须阻塞等待生产==
阻塞队列使用场景：==多线程并发、线程池==
### 11.1 阻塞队列的四组API

| 方式         | 抛出异常  | 有返回值，不抛出异常 | 阻塞、等待 | 超时等待                                |
| ------------ | --------- | -------------------- | ---------- | --------------------------------------- |
| 添加         | add()     | offer()              | put()      | offer(E e, long timeout, TimeUnit unit) |
| 移除         | remove()  | poll()               | take()     | poll(long timeout, TimeUnit unit)       |
| 获取队首元素 | element() | peek()               | -          | -                                       |

1. 抛出异常
```java
ArrayBlockingQueue<Object> objects = new ArrayBlockingQueue<>(5);
for (int i = 0; i < 5; i++) {
//            队列满会报异常
    System.out.println(objects.add(i));
}
System.out.println("=========================");
for (int i = 0; i < 5; i++) {
//            队列空会报异常
    System.out.println(objects.remove());
}
// 获取队首元素，队空则异常
System.out.println(objects.element());
```
2. 有返回值，不抛异常
```java
ArrayBlockingQueue<Object> objects = new ArrayBlockingQueue<>(5);
for (int i = 0; i < 6; i++) {
    // 队满返回false
    System.out.println(objects.offer(i));
}
System.out.println("=========================");
for (int i = 0; i < 6; i++) {
    // 队空返回null
    System.out.println(objects.poll());
}
// 队空返回null
System.out.println(objects.peek());
```
3. 阻塞等待
```java
ArrayBlockingQueue<Object> objects = new ArrayBlockingQueue<>(5);
for (int i = 0; i < 6; i++) {
    // 队满，则一直等待
    objects.put(i);
}
System.out.println("=========================");
for (int i = 0; i < 6; i++) {
    // 队空，则一直等待
    System.out.println(objects.take());
}
```
4. 超时等待
```java
ArrayBlockingQueue<Object> objects = new ArrayBlockingQueue<>(5);
for (int i = 0; i < 6; i++) {
    // 队满，则等待到指定时间后退出
    System.out.println(objects.offer(i, 3, TimeUnit.SECONDS));
}
System.out.println("=========================");
for (int i = 0; i < 6; i++) {
    // 队空，则等待到指定时间后退出
    System.out.println(objects.poll(3, TimeUnit.SECONDS));
}
```
### 11.2 SynchronousQueue同步队列
>其中每个插入操作必须等待另一个线程相应的删除操作，反之亦然。 同步队列没有任何内部容量，甚至没有一个容量。
==添加元素后，必须先取出才能继续添加==

仍然可以使用之前的offer、poll等方法，但是offer和poll只能实时
```java
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        SynchronousQueue<String> strings = new SynchronousQueue<>(true);
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName()+"放入了第"+i+"个元素");
                try {
                    strings.put(i + "");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        },"线程一").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    TimeUnit.SECONDS.sleep(3);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"获取了第"+i+"个元素");
                try {
                    System.out.println(strings.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"线程二").start();
    }
}
```

# 12.ForkJoin
==ForkJoin特点：工作窃取==
>工作窃取，即每个线程负责一个任务队列，部分线程可能会较先完成自己队列中的任务，此时这个线程会从其他未完成的队列中偷走一个任务执行，任务队列使用双端队列
### 12.1 ForkJoinPool
>ForkJoinPool实现了ExecutorService接口，提供非ForkJoinTask客户ForkJoinPool的入场点，以及管理和监控操作。线程池中的所有线程都企图找到并执行提交给线程池的任务。当在构造方法中设置==asyncMode为true==的时候这种处理更加高效。
### 12.2 ForkJoinTask
>在ForkJoinPool内运行的任务的==抽象基类==。ForkJoinTask是一个线程实体，其重量比普通线程轻得多。

![ForkJoin继承体系](/多线程/ForkJoinPool继承体系.png)
- 直接子类
1. CountedCompleter
无返回值任务，完成任务后可以触发回调
2. RecursiveTask
一个递归有结果的ForkJoinTask（有返回值）
3. RecursiveAction
一个递归无结果的ForkJoinTask（没有返回值）
### 12.3 使用ForkJoin进行计算
- 创建一个执行任务的类，并继承ForkJoinTask或其子类并重写compute()方法
```java
class ForkJoinCalculate extends RecursiveTask<Long>{

    private long start;
    private long end;
    private long temp=10000L;

    public ForkJoinCalculate(long start, long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if ((end-start)<temp){
            long sum=0L;
            for (long i=start;i<end;i++){
                sum+=i;
            }
            return sum;
        }else {
            long mid=(start+end)/2;
            ForkJoinCalculate forkJoinCalculate = new ForkJoinCalculate(start, mid);
            // 调用fork方法提交任务，在当前任务正在运行的池中异步执行此任务
            // 如果是ForkJoinWorkerThread运行过程中fork()，则直接加入到它的工作队列中，否则，重新提交任务。(见ForkJoinWorkerThread)
            forkJoinCalculate.fork();
            ForkJoinCalculate forkJoinCalculate1 = new ForkJoinCalculate(mid, end);
            forkJoinCalculate1.fork();
            // 调用join方法返回计算结果
            // 异常完成导致RuntimeException或Error 
            // get方法异常完成会导致ExecutionException
            return forkJoinCalculate.join()+forkJoinCalculate1.join();
        }
    }
}
```
- 创建ForkJoinPool
```java
ForkJoinPool forkJoinPool = new ForkJoinPool();
ForkJoinPool forkJoinPool = new ForkJoinPool(2, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);
// 参数一：parallelism - 并行级别。 对于默认值，请使用Runtime.availableProcessors() 
// 参数二：factory - 创建新线程的工厂。 默认值为defaultForkJoinWorkerThreadFactory 。
// 参数三：handler - 由于执行任务时遇到不可恢复的错误而终止的内部工作线程的处理程序。 默认值为null 。
// 参数四：asyncMode - 如果为true，请为从未连接的分叉任务建立本地先进先出调度模式。 在工作线程仅处理事件式异步任务的应用程序中，此模式可能比默认的基于本地堆栈的模式更合适。 默认值为false 。 
```
- 向ForkJoinPool提交任务
```java
// submit有返回值
// execute没有返回值
ForkJoinTask<Long> submit = forkJoinPool.submit(new ForkJoinCalculate(0L,100_0000_0000L));
```
- 获取结果
```java
Long sum = submit.get();
```
# 13.异步回调(Ajax)
```java
public class CompletableFuture<T>
```
### 简单使用
- 无返回值
```java
CompletableFuture<Void> completableFuture=CompletableFuture.runAsync(()->{
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(Thread.currentThread().getName());
});
completableFuture.get();
```
- 有返回值
```java
CompletableFuture<Integer> completableFuture=CompletableFuture.supplyAsync(()->{
    int a=10/0;
    return 777;
});

System.out.println(completableFuture.whenComplete((integer, throwable) -> {
    // 正常结果
    System.out.println(integer);
    // 错误信息
    System.out.println(throwable.getMessage());
}).exceptionally(throwable -> {
    System.out.println(throwable.getMessage());
    // 出现异常返回值
    return 123;
}).get());
```
# 14.JMM与volatile
### 14.1 什么是JMM
>JMM即为JAVA**内存模型**（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。
### 14.2 内存划分
>JMM规定了内存主要划分为**主内存**和**工作内存**两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，==主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。==
>JVM在设计时候考虑到，如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，==工作内存中的变量是主内存中的一份拷贝==，线程对变量的读取和写入，直接在**工作内存**中操作，而不能直接去操作主内存中的变量。但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因为JMM制定了一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。
### 14.3 八种内存操作
1. lock（锁定）：作用于**主内存**的变量，把一个变量标识为线程独占状态
2. unlock（解锁）：作用于**主内存**的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3. read（读取）：作用于**主内存**变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
4. load（载入）：作用于**工作内存**的变量，它把read操作从主存中变量放入工作内存中
5. use（使用）：作用于**工作内存**中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
6. assign（赋值）：作用于**工作内存**中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
7. store（存储）：作用于**主内存**中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
8. write（写入）：作用于**主内存**中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中
### 14.4 JMM对八大内存操作的规则
1. 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write(==必须成对==)
1. 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
不允许一个线程将没有assign的数据从工作内存同步回主内存
1. 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
1. 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
1. 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
1. 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
1. 对一个变量进行unlock操作之前，必须把此变量同步回主内存
### 14.5 JMM模型特征
##### 14.5.1 原子性
>例如上面八项操作，在操作系统里面是不可分割的单元。被synchronized关键字或其他锁包裹起来的操作也可以认为是原子的。从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作。
##### 14.5.2 可见性
>每个工作线程都有自己的工作内存，所以当某个线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改。volatile关键字要求被修改之后的变量要求立即更新到主内存，每次使用前从主内存处进行读取。因此volatile可以保证可见性。除了volatile以外，synchronized和final也能实现可见性。synchronized保证unlock之前必须先把变量刷新回主内存。final修饰的字段在构造器中一旦完成初始化，并且构造器没有this逸出，那么其他线程就能看到final字段的值。
##### 14.5.3 有序性
>java的有序性跟线程相关。如果在线程内部观察，会发现当前线程的一切操作都是有序的。如果在线程的外部来观察的话，会发现线程的所有操作都是无序的。因为JMM的工作内存和主内存之间存在延迟，而且java会对一些指令进行重新排序。volatile和synchronized可以保证程序的有序性，很多程序员只理解这两个关键字的执行互斥，而没有很好的理解到volatile和synchronized也能保证指令不进行重排序。
### 14.6 Happen-Before（先行发生规则）
>在常规的开发中，如果我们通过上述规则来分析一个并发程序是否安全，估计脑壳会很疼。因为更多时候，我们是分析一个并发程序是否安全，其实都依赖Happen-Before原则进行分析。Happen-Before被翻译成先行发生原则，意思就是当A操作先行发生于B操作，则在发生B操作的时候，操作A产生的影响能被B观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等。
1. **程序次序规则（Program Order Rule）**：在一个线程内，程序的执行规则跟程序的书写规则是一致的，从上往下执行。
2. **管程锁定规则（Monitor Lock Rule）**：一个Unlock的操作肯定先于下一次Lock的操作。这里必须是同一个锁。同理我们可以认为在synchronized同步同一个锁的时候，锁内先行执行的代码，对后续同步该锁的线程来说是完全可见的。
3. **volatile变量规则（volatile Variable Rule）**：对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作
4. **线程启动规则（Thread Start Rule）**：Thread对象的start()方法先行发生于此线程的没一个动作
5. **线程中止规则（Thread Termination Rule）**：Thread对象的中止检测（如：Thread.join()，Thread.isAlive()等）操作，必行晚于线程中所有操作
6. **线程中断规则（Thread Interruption Rule）**：对线程的interruption（）调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生
7. **对象中止规则（Finalizer Rule）**：一个对象的初始化方法先于一个方法执行Finalizer()方法
8. **传递性（Transitivity）**：如果操作A先于操作B、操作B先于操作C,则操作A先于操作C
### 14.7 volatile
>volatile是Java虚拟机提供的轻量级同步机制
- volatile特性：
==保证可见性==
==不保证原子性==
==禁止指令重排==
##### 14.7.1 保证可见性
以下代码如果不使用volatile关键字，第一个线程将会不停循环，程序无法终止
```java
public class VolatileDemo {
    private volatile static boolean flag=true;

    public static void main(String[] args) {
        new Thread(()->{
            // 这个线程对主存中flag的值的变化不知道
            while (flag){
            }
        }).start();
        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            flag=false;
        }).start();
    }
}
```
##### 14.7.2 不保证原子性
以下代码不论是否在变量前使用volatile，最后结果都不会始终是5000
```java
public class VolatileDemo {
    private volatile static int num=0;

    private static void incr(){
        ++num;
    }
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                for (int j = 0; j < 500; j++) {
                    incr();
                }
            }).start();
        }
        while (Thread.activeCount()>2){
            Thread.yield();
        }
        // 理论结果应该是5000
        System.out.println(num);
    }
}
```
- 使用原子类解决原子性问题(java.util.concurrent.atomic)

```text
![原子包装类](/多线程/原子包装类.jpg)
![AtomicInteger的基本方法](/多线程/AtomicInteger的基本方法.jpg)
```

以下代码结果始终是5000
```java
public class VolatileDemo {

    private static AtomicInteger integer=new AtomicInteger(0);
    private static void incr(){
        integer.getAndIncrement();
    }
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                for (int j = 0; j < 500; j++) {
                    incr();
                }
            }).start();
        }
        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(integer.get());
    }
}
```
##### 14.7.3 禁止指令重排
# 15.深入单例模式
### 15.1 饿汉式
```java
public class Hungry {

//    饿汉式，开始时就分配全部空间，可能浪费空间
    byte[][] bytes = new byte[1024][1024];


    private Hungry(){

    }
    private static final Hungry HUNGRY =new Hungry();

    public static Hungry getInstance(){
        return HUNGRY;
    }
}
```
### 15.2 懒汉式
1. 普通懒汉式未实现线程安全
```java
public class LazyMan {

    private LazyMan(){
        System.out.println(Thread.currentThread().getName()+" run");
    }

    private static LazyMan lazyMan;

    public static LazyMan getInstance(){
        if (lazyMan==null){
            lazyMan=new LazyMan();
        }
        return lazyMan;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                LazyMan.getInstance();
            }).start();
        }
    }
}
```
2. 双重检测的懒汉式(DCL)
- 存在指令重排可能的代码
```java
public class LazyMan {

    private LazyMan(){
        System.out.println(Thread.currentThread().getName()+" run");
    }

    private static LazyMan lazyMan;

    public static LazyMan getInstance(){
        if (lazyMan==null){
            synchronized (LazyMan.class){
                if (lazyMan==null){
                    lazyMan=new LazyMan();//非原子性操作
                    // 1.分配内存空间
                    // 2.执行构造方法
                    // 3.把结果赋值给这个引用
                    // 期望执行顺序：1 2 3
                    // 现在有一个线程A，由于指令重排，导致1 3 2
                    // 此时有一个线程B，在A执行完1 3后进入，由于引用已被赋值
                    // 线程B会直接返回还没有被创建的对象引用
                }
            }
        }

        return lazyMan;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                LazyMan.getInstance();
            }).start();
        }
    }
}
```
- 使用volatile消除指令重排
```java
private volatile static LazyMan lazyMan;
```
3. 静态内部类
```java
public class Holder {
    private Holder(){

    }
    public static Holder getInstance(){
        return InnerClass.holder;
    }
    public static class InnerClass{
        private static Holder holder=new Holder();
    }
}
```
4. 反射导致单例失效
5. 枚举类
枚举类可以禁止使用反射创建实例
```java
public enum EnumDemo {

    INSTANCE;

    private EnumDemo getInstance(){
        return INSTANCE;
    }

}
class Test{
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        EnumDemo instance = EnumDemo.INSTANCE;
        System.out.println(instance.hashCode());
        Class<EnumDemo> enumDemoClass = EnumDemo.class;
        // 通过jad反编译获取真实的构造器
        Constructor<EnumDemo> declaredConstructor = enumDemoClass.getDeclaredConstructor(String.class, int.class);
        declaredConstructor.setAccessible(true);
        // Cannot reflectively create enum objects
        EnumDemo enumDemo = declaredConstructor.newInstance();
    }
}
```
# 16.CAS(乐观锁)
### 16.1 什么是CAS
>==Compare And Swap==
CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。
### 16.2 JDK中的实例
AtomicInteger类中自增方法
```java
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```
Unsafe类
```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        // 不断获取内存中的值，C++实现
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```
### 16.3 应用示例
```java
public class AtomicDemo {

    private static AtomicInteger num = new AtomicInteger(0);

    private static void incr(){
        num.getAndIncrement();
    }

    public static void main(String[] args) throws InterruptedException {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                Runtime.getRuntime().availableProcessors(),
                10,
                5L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(5),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardPolicy());

        for (int i = 0; i < 10; i++) {
            threadPoolExecutor.execute(()->{
                for (int j = 0; j < 5000; j++) {
                    incr();
                }
            });
        }

        threadPoolExecutor.shutdown();

        while (threadPoolExecutor.isTerminating()){
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println(num);
    }
}
```
# 17.原子引用
### 17.1 ABA问题
### 17.2 使用原子引用解决ABA问题
```java
public class AtomicReferenceDemo {

    private static final AtomicStampedReference<Integer> atomicStampedReference=new AtomicStampedReference<>(0,1);

    public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                Runtime.getRuntime().availableProcessors(),
                10,
                5,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardPolicy()
        );
        System.out.println(atomicStampedReference.compareAndSet(0, 1, 1, 2));
        threadPoolExecutor.execute(()->{
            System.out.println(atomicStampedReference.compareAndSet(1, 0, 2, 3));
        });
        threadPoolExecutor.shutdown();
        while (threadPoolExecutor.isTerminating()){
            Thread.yield();
        }
        // 由于记录戳被修改，这条语句会返回false，最终结果是0
        // 如果不使用原子引用，这里将修改成功
        System.out.println(atomicStampedReference.compareAndSet(0, 5, 2, 3));

        System.out.println(atomicStampedReference.getReference().intValue());
    }
}
```
### 17.3 关于IntegerCache
>如果Integer值在-128~127之间，Integer对象在IntegerCache.cache中产生，这个区间中的Integer对象可以直接通过==进行判断，这个区间以外的所有数据都会在堆上产生，并不会复用已有对象，要是用equals方法判断
- 考虑如下代码
```java
public class IntegerDemo {
    public static void main(String[] args) {
        Integer a=100;
        Integer b=100;
        Integer c=1000;
        Integer d=1000;
//        true
        System.out.println(a==b);
//        false
        System.out.println(c==d);
//        true
        System.out.println(a.equals(b));
//        true
        System.out.println(c.equals(d));
    }
}
```
# 18.可重入锁、自旋锁
### 18.1 可重入锁(递归锁)
>synchronized
在如下代码中，synchronized锁的是方法调用者即home对象，在执行完doorA方法前，这个锁不会释放，所以始终是A线程执行完两个方法后，B线程才开始执行
```java
public class LocksDemo {
    public static void main(String[] args) {
        Home home = new Home();
        new Thread(()->{
            try {
                home.doorA();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"A").start();

        new Thread(()->{
            try {
                home.doorA();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"B").start();
    }
}
class Home{
    public synchronized void doorA() throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+" enter doorA");
        TimeUnit.SECONDS.sleep(3);
        doorB();
    }
    public synchronized void doorB(){
        System.out.println(Thread.currentThread().getName()+" enter doorB");
    }
}
```
>ReentrantLock
如下代码中，线程A执行完doorA方法后释放锁去获得doorB的锁，此时B线程可以获取doorA的锁并执行
==lock与unlock必须成对出现，否则会出现程序无法继续执行==
```java
public class LocksDemo {
    public static void main(String[] args) {
        Home home = new Home();
        new Thread(()->{
            try {
                home.doorA();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"A").start();

        new Thread(()->{
            try {
                home.doorA();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"B").start();
    }
}
class Home{

    private static final ReentrantLock lock = new ReentrantLock(true);

    public void doorA() throws InterruptedException {
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName()+" enter doorA");
            TimeUnit.SECONDS.sleep(3);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
        doorB();
    }

    public void doorB(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName()+" enter doorB");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }
}
```
### 18.2 自旋锁
>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
- 自旋锁示例
```java
public class SpinLock {

    private static final AtomicStampedReference<Integer> REFERENCE =new AtomicStampedReference<>(0,1);

    public static void main(String[] args) {
        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(10);
                REFERENCE.compareAndSet(0,1,1,2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"A").start();

        new Thread(()->{
            // 未满足条件前，线程B将会循环等待
            while (!REFERENCE.compareAndSet(1,2,2,3)){
                try {
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println(Thread.currentThread().getName()+" is waiting");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(REFERENCE.getReference().intValue());
    }
}
```
