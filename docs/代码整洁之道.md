# 代码整洁之道

**稍后等于永不。**

## 整洁代码

### 何谓整洁代码？

- 逻辑直截了当，依赖关系少，错误处理完善，性能调整最优。
- 力求集中，每个函数、每个类和每个模块都全身贯注在一件事上。
- 可由作者之外的开发者阅读和修改。
- 应当有单元测试和验收测试。
- 作者全身心投入编写的代码。
- …………

## 有意义的命名

### 名副其实

- 名字应当能够回答大部分问题，包括：它为什么存在、做什么事、应该怎么用，名称不应当再需要注释来补充解释，如果一旦发现更合适的名称就替换掉。

### 避免误导

- 程序员必须避免留下掩藏代码本意的错误线索。应当避免使用与本意相悖的词。例如不应当使用一些系统中的专有名词，除非真的是List否则不要将变量取名xxxList。
- 新起名字不要和原有的名字太过相似，不容易区分。
- 相似的名称按字母顺序放在一起就会很明显。
- 注意大写字母O和小写字母l与数字0、1的区别，不要随意使用。

### 做有意义的区分

- 同一作用域中，名称需要区分时应当使用有意义的命名区分，不能简单地添加数字后缀。
- 杜绝没有意义的区分，例如一个类叫ProductInfo，另一个叫ProductData，没有本质上的意义区别。

### 使用读得出来的名称

- 不应当随意将单词缩写然后拼接在一起，常识性缩写除外，无法所写的应当全部拼写。

### 使用可搜索的名称

- 不使用单字母和数字，容易漏掉。

### 避免使用编码

- 不要再使用无意义的前缀和后缀，哪怕它们曾经是主流。

### 避免思维映射

- 起名字不应当让他人阅读时翻译成他们熟悉的名字,**明确是王道**。

### 类名

- 类名和对象名应该是名词或名词短语，不应当是动词。

### 方法名

- 方法名应当是动词或动词短语，getter、setter应当按照Java Bean标准命名。
- 重载构造器时，使用描述了参数的静态工厂方法名，通常比直接调用构造器要好，所以可以将构造器设为私有，强制使用这种方法。

```java
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
Complex fulcrumPoint = new Complex(23.0);
```

### 名字不要开玩笑

- 不要使用俗语、俚语。
- **言到意到，意到言到**。

### 每个概念对应一个词

- 给每个抽象概念选一个词并且一以贯之，一致性越强可维护性越高。

### 别用双关语

- 一个单词应当只应用在一个概念中，一词一意，例如加法和连接方法名都有add，那么增加操作就应当命名为insert或append而不应当继续使用add。

### 使用解决方案领域名称

- 尽管使用计算机科学中的术语、算法名、模式名等。

### 使用源自所涉问题领域的名称

- 如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称。

### 添加有意义的语境

- 很少有变量可以通过名称自我说明，存在多个变量时，为它们创建一个单独的类更加合适。

### 不要添加没用的语境

- 只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。

## 函数

### 短小

- 函数不应该大到足以容纳嵌套结构。
- 函数的缩进层级不该多于一层或两层。

### 只做一件事

- 要判断函数是否不止做了一件事，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现。
- 只做一件事的函数无法被合理地切分为多个区段。

### 每个函数一个抽象层级

- 保证同一个函数中的方法抽象程度的相近，从高度抽象慢慢向下到具体实现，这样就能实现代码自顶向下阅读。

### switch语句

### 使用描述性的名称

- 名称不必担心太长，要使名称中的多个单词容易读。
- 函数名应当是动词名词的形式，解释函数的作用。
- 命名方式要保持一致，近义词选定一个就不应再使用其它。

### 函数参数

- 参数列表不宜过长。
- 参数越多测试越复杂。
- 如果一个函数的逻辑收到参数中某个标志的影响，那么应当拆分这个函数，去掉这个标记。
- 多元函数要注意参数的顺序，或者想方法变回一元函数。
- 当函数的参数过多时，应当考虑将参数封装成对象。

### 无副作用

- 函数的实际行为应当与名字描述的一致，不应当有其他行为。
- 如果一个函数必须要改变一下东西，那么就修改它所拥有的属性即可。

### 分隔指令与询问

- 一个函数要么做什么事，要么回答什么事，不要既回答（返回值）又去做事（修改），这回导致歧义。

### 使用异常替代返回错误码

- 当遇到错误时，不应当立即在逻辑中处理，抛出异常在异常处理中集中处理，将错误处理代码从主路径代码中抽离出来。
- try、catch代码块可以从一个函数中提取出来单独组成一个函数。
- 使用异常可以避免使用错误枚举类，在扩展时只要扩展异常类即可。

### 别重复自己

- 当一个算法在多个方法中都被使用时，如果需要修改算法就需要修改多个方法，应当将重复的部分抽离出来。

### 其它

- goto只有在大函数中才有意义，小函数避免使用。
- 不必试图在最开始就将所有代码设计的完美无缺，编写完后再仔细打磨。

## 注释

- 与其花费更多时间在编写注释上，不如多思考如何能够使代码更加整洁、更能体现其意义。
- 如果代码本身的意义足够清晰明了就没有必要再去编写无意义的注释。
- 注释不要说谎。
- 法律信息、著作权声明等。
- 使用注释来说明方法返回值、参数等，但是这可以使用良好的命名来解决。
- 使用注释来阐明某种写法的目的或者解决方案。
- 使用注释将某些复杂的、不易理解的值翻译为某种更加可读的形式。
- 通过注释警告什么时候该使用这段代码或者是这段代码存在何种问题。
- 添加TODO注释对这段代码的未来功能规划作出解释。
- 注释可以用来放大某种看来不合理之物的重要性。
- 注释要让他人轻松的看明白，注释要和它所阐述的代码有紧密关系。
- 注释不应当不如阅读代码清晰，也就是多余。
- 注释必须准确的描述代码的实际行为，误导的注释是有害的。
- 没有必要一定要为每个变量、每个方法都增加Java doc注释。
- 杜绝日志式注释。
- 对于显而易见的问题没有必要添加注释，这将看起来像是废话。
- 没必要保留的代码应当删除而不是注释。
- 注释中的信息不宜过多。

## 格式

### 格式的目的

- 代码也是一种沟通，好的格式能让沟通更加顺畅。

### 垂直格式

- 源文件要像报纸文章那样，名称简单且一目了然，最上方给出概念和算法，细节向下逐次展开。
- 使用空白行将不同思路、逻辑的代码区分隔开。
- 紧密相关的代码行应该互相靠近，相关性越强就越近，中间不应出现空行或注释等分隔。
- 变量声明应当尽量靠近使用处。
- 实体变量应该声明在类的顶部。
- 如果两个函数出现了相互调用，那么他们应当放到一起，且调用者应当尽可能放在被调用者的上面。

### 横向格式

- 一行代码不应过长。
- 相关性较弱的内容应当远离，例如运算符的两个操作数和符号间应该分别有一个空格，而函数名和左括号应当不加空格。
- 对齐？。
- 合理的缩进。
- while、if等语句如果没有代码体依然应当加上括号，不要只在末尾添加一个分号。

### 团队规则

- 每个成员应当采用同一种格式风格。

## 对象和数据结构

### 数据抽象

- 代码不应当暴露实现，通过提供更加抽象的形态表述数据。

### 数据、对象的反对称性

- 过程式代码难以添加新的数据结构，因为需要修改所有函数。
- 面向对象代码难以添加新函数，因为必须修改所有类。

### 迪米特法则

- 迪米特法则：模块不应了解它所操作对象的内部情形。
- 对象不应通过存取器暴露内部结构。
- 如果是数据结构，那么其中的变量自然会暴露内部结构，迪米特法则也就不适用了。

### 数据传送对象：只有公共变量、没有函数的类DTO

- 这类数据结构不应该被塞入业务规则方法。

### 总结

- 对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。
- 数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。
- 在任何系统中，我们有时会希望能够灵活地添加新数据类型，所以更喜欢在这部分使用对象。
- 另外一些时候，我们希望能灵活地添加新行为，这时我们更喜欢使用数据类型和过程。

## 错误处理

### 使用异常而非返回码

如果使用返回码供检查错误，它们会扰乱调用者的代码，调用者必须在调用之后立刻检查错误，所以遇到错误时，最好抛出一个异常，调用者的代码不会被扰乱。

### 先写 Try-Catch-Finally 语句

try 代码块表明是可以随时取消执行的，并在 catch 语句中接续。try 代码块就像是事务。catch 代码块将程序维持在一种持续状态，无论 try 代码块中发生了什么，这能定义代码的用户应该期待什么。

### 使用不可控异常

可控异常：每个方法的签名都列出它可能传递给调用者的异常。

可控异常违背了开放-封闭原则，如果在一个方法中抛出了可控异常，将影响到较高层级的方法签名，修改好的模块必须重新构建。

如果是编写一套关键代码库，则可控异常有时也会有用：必须捕获异常。但对于一般的应用开发，其依赖成本要高于收益。

### 给出异常发生的环境说明

抛出的每个异常都应当提供足够的环境说明，以便判断错误的来源和出处。

### 依调用者需要定义异常类

处理异常时可能出现很多重复代码，需要对每个异常单独处理，可以对所有的异常进行打包成一个类，根据异常的信息区分不同的错误，如果是将第三方API打包，可以降低与这个代码库的耦合度。

### 定义常规流程

异常如果打断了业务逻辑，可以使用*特例模式*，创建一个类或配置一个对象用来处理特例，异常行为被封装到特例对象中。

### 别返回 null 值

如果返回了 null 值，在调用这个方法的时候必须时刻注意 null 值的判断，一旦忘记进行捕获，可能造成影响。在没有必要返回 null 值的时候，可以返回值为空的对象。

### 别传递 null 值

除非 API 要求向它传递 null 值，否则就要尽量避免传递 null 值。

### 小结

整洁代码是可读的，但也要强固。可读与强固并不冲突。如果将错误处理隔离看待，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它，也极大地提升了代码的可维护性。

## 边界

### 使用第三方代码

在使用第三方代码的时候，可能出现需要类型转换的问题，转换过程应当封装在一个类中，在系统中不应该有类型转换的传递。

### 浏览和学习的边界

学习第三方代码时，不要在生产代码中试验新东西，而是编写测试来关注第三方代码提供的 API 所能提供的东西。

可以考虑使用适配器实现边界的编码。

## 单元测试

### TDD 三定律

- 定律一：在编写不能通过的单元测试前，不可编写生产代码。
- 定律二：只可编写刚好无法通过的单元测试，不能编译也算。
- 定律三：只可编写刚好足以通过当前失败测试的生产代码。

### 整洁的测试

整洁测试要具有可读性，明确、简洁、有表达力。

三个环节：构造测试数据——操作测试数据——检验操作结果。

### 每个测试一个断言

在每个测试方法中使用断言语句可以将测试归结为一个可快速方便地理解的结论。

每个测试方法只测试一个含义。

### F.I.R.S.T

- F：测试应该够快。
- I：测试应该相互独立，某个测试不应为下一个测试设定条件。
- R：测试应当可以在任何环境中重复通过。
- S：测试应该有布尔值输出，测试应该自足验证。
- T：测试应该及时编写，恰好在其通过的生产代码之前编写。

## 类

### 类的组织

类应该从一组变量列表开始，如果有公共静态常亮，应该先出现，然后是私有静态变量以及私有实体变量。

### 类应该短小

类的长度应当以*权责*来衡量。

如果无法为某个类用精确的名称命名，或者类名中包括含义模糊的词，往往说明权责划分不到位。

遵循单一职责原则。

### 为了修改而组织

隔离修改。

将类组织为符合单一职责原则，每个类只有一个修改的理由。

具体类包含实现细节，抽象类只呈现概念，当细节改变时就会有风险，可以通过依赖倒转原则隔离这些细节带来的影响。

## 系统

### 将系统的构造与使用分开

软件系统应将起始过程和之后的运行时逻辑分离开。

依赖倒转。

## 并发编程

### 关于并发

- 并发会在性能和编写额外代码上增加一些开销。
- 正确的并发是复杂的，即便对于简单地问题也是如此。
- 并发缺陷并非总能重现，所以常被看作偶发事件而忽略。
- 并发常常需要对设计策略进行根本性修改。

### 并发防御原则

- 单一职权原则：分离并发相关代码与其他代码。
    - 并发相关代码有自己的开发、修改和调优生命周期。
    - 并发相关代码有自己要对付的挑战，和非并发相关代码不同，往往更加困难。
    - 写的不好的并发代码可能的出错方式数量也足具挑战。
- 限制数据作用域：严格限制共享数据的访问。
- 使用数据复本：？
- 线程尽可能独立：减少与其他线程共享数据的可能。

### 测试线程代码

编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行，如果测试失败，跟踪错误。

- 将伪失败看作可能的线程问题。
- 先使非线程代码可工作。
- 编写可插拔的线程代码（可在数个配置环境下运行的线程代码）。
- 编写可调整的线程代码（允许线程数量可调整和变动）。
- 运行多于处理器数量的线程（为了促使任务切换的发生）。
- 在不同平台上运行。
- 调整代码并强迫错误发生。
- 不要同时追踪非线程错误和线程错误。
