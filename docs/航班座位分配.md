# 项目描述

此项目是软件工程概论实验大作业，原题目为[中国软件杯航班座位分配系统](http://www.cnsoftbei.com/plus/view.php?aid=356)，这里由于只是结课作业，遂降低要求，移除了部分功能，保留了偏好设置、座位分配、邮件提醒、航班查询、公告系统等主体功能，使用Vue+SpringBoot前后端分离开发

# 数据库设计

使用MySQL：共计6张表：乘客表、飞机表、航班表、订单表、操作记录表、算法准确度表

使用MongoDB：存储一个公告表

### 乘客表

| 字段            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| id              | 主键                                                         |
| name            | 用户昵称                                                     |
| password        | 密码                                                         |
| sex             | 性别                                                         |
| is_admin        | 是否管理员                                                   |
| identity_number | 身份证号(虽然作为一个大作业无法去验证身份证号，此处只是作为模拟) |
| mail_address    | 邮箱                                                         |
| birthday        | 出生日期                                                     |
| preference      | 偏好设置                                                     |
| last_view_date  | 最后一次查看公告时间                                         |

```sql
create table passenger
(
    id              int auto_increment
        primary key,
    name            varchar(100)      null,
    password        varchar(100)      null,
    sex             varchar(100)      null,
    is_admin        tinyint default 0 null,
    identity_number varchar(100)      null,
    mail_address    varchar(100)      null,
    birthday        date              null,
    preference      varchar(100)      null,
    last_view_date  datetime          null,
    constraint passenger_identity_number_uindex
        unique (identity_number),
    constraint passenger_mail_address_uindex
        unique (mail_address)
);
```

### 飞机表

| 字段           | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| id             | 主键                                                         |
| type           | 型号                                                         |
| first_class    | 头等舱信息，值为拼接字符串，例如00 00,00 00；空格表示过道，逗号表示下一排 |
| business_class | 商务舱信息                                                   |
| economy_class  | 经济舱信息                                                   |

```sql
create table plane_info
(
    id             int auto_increment
        primary key,
    type           varchar(100)  null,
    first_class    varchar(1000) null,
    business_class varchar(1000) null,
    economy_class  varchar(1000) null,
    constraint plane_info_type_uindex
        unique (type)
);
```

### 航班表

| 字段           | 描述                                                   |
| -------------- | ------------------------------------------------------ |
| id             | 主键                                                   |
| plane_type     | 机型                                                   |
| flight         | 航班编号                                               |
| first_class    | 头等舱票务信息，与飞机表类似，将0替换为1表示座位已卖出 |
| business_class | 商务舱票务信息                                         |
| economy_class  | 经济舱票务信息                                         |
| departure      | 出发地                                                 |
| destination    | 目的地                                                 |
| date           | 出发时间                                               |
| always         | 航班是否始终可用，这将在每日进行航班增加时起判断作用   |
| available      | 航班是否可用                                           |

```sql
create table ticket
(
    id             int auto_increment
        primary key,
    plane_type     varchar(100)      null,
    flight         varchar(100)      null,
    first_class    varchar(1000)     null,
    business_class varchar(1000)     null,
    economy_class  varchar(1000)     null,
    departure      varchar(100)      null,
    destination    varchar(100)      null,
    date           datetime          null,
    always         tinyint default 1 null,
    available      tinyint default 1 null,
    constraint ticket_plane_info_type_fk
        foreign key (plane_type) references plane_info (type)
);
```

### 订单表

| 字段                      | 描述         |
| ------------------------- | ------------ |
| order_id                  | 主键         |
| passenger_identity_number | 乘客身份证号 |
| passenger_mail_address    | 乘客电子邮箱 |
| flight                    | 航班号       |
| seat_number               | 座号         |
| flight_date               | 航班起飞时间 |
| satisfaction              | 满意度       |
| plane_type                | 飞机型号     |
| departure                 | 出发地       |
| destination               | 目的地       |
| class_type                | 机舱类型     |
| canceled                  | 是否取消     |
| order_date                | 购票时间     |

```sql
create table order_record
(
    order_id                  int auto_increment
        primary key,
    passenger_identity_number varchar(100)      null,
    passenger_mail_address    varchar(100)      null,
    flight                    varchar(100)      null,
    seat_number               varchar(100)      null,
    flight_date               datetime          null,
    satisfaction              int               null,
    plane_type                varchar(100)      null,
    departure                 varchar(100)      null,
    destination               varchar(100)      null,
    class_type                varchar(100)      null,
    canceled                  tinyint default 0 null,
    order_date                datetime          null,
    constraint order_record_passenger_identity_number_fk
        foreign key (passenger_identity_number) references passenger (identity_number),
    constraint order_record_passenger_mail_address_fk
        foreign key (passenger_mail_address) references passenger (mail_address)
);
```

### 操作记录表

| 字段      | 描述       |
| --------- | ---------- |
| id        | 主键       |
| date      | 操作日期   |
| account   | 操作员账号 |
| name      | 操作员姓名 |
| operation | 操作描述   |

```sql
create table operation_record
(
    id        int auto_increment
        primary key,
    date      datetime     null,
    account   varchar(100) null,
    name      varchar(100) null,
    operation varchar(500) null,
    constraint operation_record_passenger_mail_address_fk
        foreign key (account) references passenger (mail_address)
);
```

### 算法准确度表

| 字段        | 描述               |
| ----------- | ------------------ |
| id          | 主键               |
| flight      | 航班号             |
| date        | 航班起飞时间       |
| molecular   | 分子               |
| denominator | 分母               |
| already     | 是否以起飞         |
| result      | 算法准确率加权结果 |

```sql
create table calculate
(
    id          int auto_increment
        primary key,
    flight      varchar(100)         not null,
    date        datetime             not null,
    molecular   double               null,
    denominator int                  null,
    already     tinyint(1) default 0 null,
    result      double               null
);
```

外键及其他约束参见SQL语句

# 后端编码

### 导入依赖

```xml
    <!--Redis依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
	<!--邮件相关依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
	<!--SpringSecurity依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
	<!--SpringBoot web依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
	<!--Mybatis-Plus依赖-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.3.1</version>
</dependency>
	<!--德鲁伊数据源依赖-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.6</version>
</dependency>
	<!--jwt依赖，用于Token验证-->
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>3.17.0</version>
</dependency>
	<!--I/O工具包依赖-->
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.8.0</version>
</dependency>
	<!--解析HTML依赖-->
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.14.1</version>
</dependency>
	<!--SpringBoot热部署依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
	<!--Mysql驱动-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
	<!--SpringBoot配置依赖，可以不引入-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
	<!--lombok依赖-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
	<!--测试相关-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
	<!--测试相关-->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <scope>test</scope>
</dependency>
	<!--测试相关-->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-test</artifactId>
    <scope>test</scope>
</dependency>
	<!--MongoDB依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
	<!--AOP依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

### 编写配置文件

```yaml
server:
    port: 8848
spring:
    application:
        name: SeatAllocation
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        name: defaultDataSource
        username: root
        password: 123456
        url: jdbc:mysql://localhost:3306/seat_allocation?serverTimezone=UTC&useAffectedRows=true
        type: com.alibaba.druid.pool.DruidDataSource
    mail:
        username: *********@qq.com
        password: ************ #此处密码不是QQ邮箱的密码，而是SMTP服务的验证码，要手动开通
        host: smtp.qq.com
        protocol: smtps
        port: 465
    profiles:
        active: mail
    data:
        mongodb:
            uri: mongodb://localhost:27017/mydb
    servlet:
        multipart:
            max-file-size: 10MB
            max-request-size: 20MB
mybatis-plus:
    global-config:
        db-config:
            table-prefix: seat_allocation.
    configuration:
#        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
        map-underscore-to-camel-case: true
```
application-mail.properties：
```properties
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
```

定义host.properties文件，将静态文件URL统一进行设置

```properties
imagePath=/var/www/html/

resourceUrlPrefix=http://localhost:8888/

hostUrlPrefix=http://localhost/sign/
```

定义token.properties文件，统一配置Token密钥及有效期

```properties
secret=OWNSAsa

expireDays=10
```

### 编写实体类

由于使用了Mybatis-Plus，每张表对应一个实体类即可

```java
@Data
@Accessors(chain = true)
@AllArgsConstructor
@NoArgsConstructor
@TableName(value = "passenger",keepGlobalPrefix = true)
public class Passenger {
    /**
     * 用户编号
     */
    @TableId(type = IdType.AUTO)
    private Integer id;
    /**
     * 用户名
     */
    private String name;
    /**
     * 密码
     */
    private String password;
    /**
     * 性别
     */
    private String sex;
    /**
     * 是否是VIP用户
     */
    private Boolean isAdmin;
    /**
     * 出生日期
     */
    private Date birthday;
    /**
     * 邮箱地址
     */
    private String mailAddress;
    /**
     * 身份证号
     */
    private String identityNumber;

    /**
     * 偏好
     */
    private String preference;
    /**
     * 最后一次查看公告时间
     */
    private Date lastViewDate;
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
@TableName(value = "ticket",keepGlobalPrefix = true)
public class Ticket {

    /**
     * 机票ID
     */
    @TableId(type = IdType.AUTO)
    private Integer id;

    /**
     * 飞机型号
     */
    private String planeType;

    /**
     * 航班编号
     */
    private String flight;
    /**
     * 头等舱信息
     */
    private String firstClass;

    /**
     * 商务舱信息
     */
    private String businessClass;

    /**
     * 经济舱信息
     */
    private String economyClass;

    /**
     * 出发地
     */
    private String departure;

    /**
     * 目的地
     */
    private String destination;

    /**
     * 出发日期
     */
    private Date date;

    /**
     * 是否持续
     */
    private Boolean always;

    /**
     * 是否可用
     */
    private Boolean available;
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
@TableName(value = "plane_info",keepGlobalPrefix = true)
public class PlaneInfo {

    /**
     * 飞机ID
     */
    @TableId(type = IdType.AUTO)
    private Integer id;

    /**
     * 飞机型号
     */
    private String type;

    /**
     * 头等舱信息
     */
    private String firstClass;

    /**
     * 商务舱信息
     */
    private String businessClass;

    /**
     * 经济舱信息
     */
    private String economyClass;
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
@TableName(value = "order_record",keepGlobalPrefix = true)
public class OrderRecord {
    /**
     * 订单编号
     */
    @TableId(type = IdType.AUTO)
    private Integer orderId;
    /**
     * 客户身份证号
     */
    private String passengerIdentityNumber;
    /**
     * 客户邮箱
     */
    private String passengerMailAddress;
    /**
     * 航班编号
     */
    private String flight;
    /**
     * 座位号
     */
    private String seatNumber;
    /**
     * 飞机起飞时间
     */
    private Date flightDate;

    /**
     * 下单时间
     */
    private Date orderDate;

    /**
     * 满意度
     */
    private Integer satisfaction;
    /**
     * 飞机类型
     */
    private String planeType;
    /**
     * 出发地
     */
    private String departure;
    /**
     * 目的地
     */
    private String destination;
    /**
     * 机舱类型
     */
    private String classType;
    /**
     * 是否已取消
     */
    private Boolean canceled;
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
@TableName(value = "operation_record",keepGlobalPrefix = true)
public class OperationRecord {

    /**
     * 主键ID
     */
    @TableId(type = IdType.AUTO)
    private Integer id;
    /**
     * 操作时间
     */
    private Date date;
    /**
     * 操作账号
     */
    private String account;
    /**
     * 操作员姓名
     */
    private String name;
    /**
     * 操作描述
     */
    private String operation;
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
@TableName(value = "calculate",keepGlobalPrefix = true)
public class Calculate {

    @TableId(type = IdType.AUTO)
    private Integer id;

    private String flight;

    private Date date;

    private Double molecular;

    private Integer denominator;

    private Boolean already;

    private Double result;
}
```

定义公告实体类，公告存在MongoDB中

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
public class Announcement {

    @MongoId
    private String id;
    private String html;
    private String adminName;
    private String adminAccount;
    private String date;
}
```

定义偏好和机舱类别枚举类

```java
public enum Preference {
    /**
     * 靠窗
     */
    WINDOW,
    /**
     * 靠过道
     */
    AISLE,
    /**
     * 前排
     */
    FRONT,
    /**
     * 后排
     */
    BACK,
    /**
     * 没有要求
     */
    NONE,
    /**
     * 中间座位
     */
    MID

}
```

```java
public enum ClassType {
    /**
     * 商务舱
     */
    BUSINESS,
    /**
     * 头等舱
     */
    FIRST,
    /**
     * 经济舱
     */
    ECONOMY
}
```

### 编写Mapper层：

由于使用了Mybatis-Plus，mapper接口只要继承`BaseMapper`并使用对应的实体类做泛型即可，同时添加`@Mapper`和`@Repository`注解

### 注册相关Bean

```java
@Configuration
public class BeansConfig {
	/**
    * Jackson操作JSON的对象，虽然每次使用new也可以，但是当一个类大量使用的时候个人更喜欢注入
    */
    @Bean
    public ObjectMapper objectMapper(){
        return new ObjectMapper();
    }
	/**
    * 密码编码器
    */
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }
	/**
    * 自定义RedisTemplate，使用JSON序列化
    */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(RedisSerializer.string());
        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer<>(Object.class));
        redisTemplate.setHashKeySerializer(RedisSerializer.string());
        redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer<>(Object.class));
        return redisTemplate;
    }
	/**
    * 定义线程池，发送邮件费时较长，交给线程池处理
    */
    @Bean
    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setCorePoolSize(Runtime.getRuntime().availableProcessors()/2);
        threadPoolTaskExecutor.setMaxPoolSize(Runtime.getRuntime().availableProcessors());
        threadPoolTaskExecutor.setQueueCapacity(10);
        threadPoolTaskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        return threadPoolTaskExecutor;
    }

    /**
    * Mybatis-Plus分页插件
    */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return mybatisPlusInterceptor;
    }
}
```

### 配置SpringSecurity

SpringSecurity配置类要继承`WebSecurityConfigurerAdapter`类，并且需要再配置一个实现`UserDetailsService`接口的实现类用于进行账号密码的验证

```java
@Component
public class UserAuthorityImpl implements UserDetailsService {

    private PassengerMapper passengerMapper;

    private final BCryptPasswordEncoder bCryptPasswordEncoder;

    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    public void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    @Autowired
    public UserAuthorityImpl(BCryptPasswordEncoder bCryptPasswordEncoder) {
        this.bCryptPasswordEncoder = bCryptPasswordEncoder;
    }

    @Autowired
    public void setPassengerMapper(PassengerMapper passengerMapper) {
        this.passengerMapper = passengerMapper;
    }

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        QueryWrapper<Passenger> passengerQueryWrapper = new QueryWrapper<>();
        passengerQueryWrapper.eq("mail_address",s);
        Passenger passenger = passengerMapper.selectOne(passengerQueryWrapper);
        if (passenger==null){
            throw new UsernameNotFoundException("账号不存在");
        }
        redisTemplate.opsForValue().set(s,passenger);//将用户存入缓存
        List<GrantedAuthority> role;
        if (passenger.getIsAdmin()) {
            role = AuthorityUtils.commaSeparatedStringToAuthorityList("passenger,admin");
        }else {
            role = AuthorityUtils.commaSeparatedStringToAuthorityList("passenger");
        }

        return new org.springframework.security.core.userdetails.User(passenger.getMailAddress(),bCryptPasswordEncoder.encode(passenger.getPassword()),role);
    }
}
```

这里要注意，默认情况下`UsernameNotFoundException`是不会被捕获的，需要进行配置：

首先注册Bean

```java
@Bean
public AuthenticationProvider daoAuthenticationProvider(){
    DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
    daoAuthenticationProvider.setUserDetailsService(userDetailsService);
    daoAuthenticationProvider.setPasswordEncoder(bCryptPasswordEncoder());
    daoAuthenticationProvider.setHideUserNotFoundExceptions(false);
    return daoAuthenticationProvider;
}
```

在SpringSecurity配置类中：

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    super.configure(auth);
    auth.authenticationProvider(daoAuthenticationProvider());
}
```

但是上述方法在本项目开发中没有生效，`UsernameNotFoundException`仍然是无法捕获的，但在另一个项目中却是能够捕获的，原因未知

### 编写SpringSecurity配置类

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private UserDetailsService userDetailsService;

    private AuthenticationFailureHandler failureHandler;

    private AuthenticationSuccessHandler successHandler;

    private AuthenticationEntryPoint entryPoint;

    private LogoutSuccessHandler logoutSuccessHandler;

    private BCryptPasswordEncoder passwordEncoder;

    private GlobalFilter globalFilter;

    @Autowired
    public void setGlobalFilter(GlobalFilter globalFilter) {
        this.globalFilter = globalFilter;
    }

    @Autowired
    public void setPasswordEncoder(BCryptPasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
    }

    @Autowired
    public void setFailureHandler(AuthenticationFailureHandler failureHandler) {
        this.failureHandler = failureHandler;
    }

    @Autowired
    public void setSuccessHandler(AuthenticationSuccessHandler successHandler) {
        this.successHandler = successHandler;
    }

    @Autowired
    public void setEntryPoint(AuthenticationEntryPoint entryPoint) {
        this.entryPoint = entryPoint;
    }

    @Autowired
    public void setLogoutSuccessHandler(LogoutSuccessHandler logoutSuccessHandler) {
        this.logoutSuccessHandler = logoutSuccessHandler;
    }

    @Autowired
    public void setUserDetailsService(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService);//配置自己实现的userDetailsService
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        super.configure(web);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();//关闭跨域保护
        http.exceptionHandling()
                .authenticationEntryPoint(entryPoint)//指定如果没有认证就进行访问的处理器，不过此处也可以不写，因为前后端分离，token为唯一认证标准
                .and()
                .formLogin()//默认验证URL：/login
                .usernameParameter("account")//指定登录验证时传来的账号密码字段名
                .passwordParameter("password")
                .successHandler(successHandler)//认证成功处理器
                .failureHandler(failureHandler);//认证失败处理器
        http.addFilterBefore(globalFilter,UsernamePasswordAuthenticationFilter.class);//将自己定义的过滤器置于过滤器链最前

    }
}
```

### 统一返回格式字符串

##### 定义返回状态码枚举类

```java
public enum ResultCode {
    /* 成功 */
    SUCCESS(200, "成功"),

    /* 默认失败 */
    COMMON_FAIL(999, "失败"),

    /* 参数错误：1000～1999 */
    PARAM_NOT_VALID(1001, "无效的参数"),
    PARAM_IS_BLANK(1002, "参数为空"),
    PARAM_TYPE_ERROR(1003, "参数类型错误"),
    PARAM_NOT_COMPLETE(1004, "参数缺失"),

    /* 用户错误 */
    USER_NOT_LOGIN(2001, "用户未登录"),
    USER_ACCOUNT_EXPIRED(2002, "账号已过期"),
    USER_CREDENTIALS_ERROR(2003, "密码错误"),
    USER_CREDENTIALS_EXPIRED(2004, "密码过期"),
    USER_ACCOUNT_DISABLE(2005, "账号不可用"),
    USER_ACCOUNT_LOCKED(2006, "账号被锁定"),
    USER_ACCOUNT_NOT_EXIST(2007, "账号不存在"),
    USER_ACCOUNT_ALREADY_EXIST(2008, "账号已存在"),
    USER_ACCOUNT_USE_BY_OTHERS(2009, "账号下线"),
    USER_TOKEN_INVALID(2010,"token无效"),
    USER_TOKEN_NOTFOUND(2011,"未携带token"),

    /* 业务错误 */
    NO_PERMISSION(3001, "没有权限");
    private Integer code;
    private String message;

    ResultCode(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public static String getMessageByCode(Integer code) {
        for (ResultCode ele : values()) {
            if (ele.getCode().equals(code)) {
                return ele.getMessage();
            }
        }
        return null;
    }
}
```

##### 定义生成返回信息字符串类

```java
@Data
@NoArgsConstructor
public class JsonResult<T> implements Serializable {
    private Boolean success;
    private Integer code;
    private String msg;
    private T data;


    public JsonResult(boolean success) {
        this.success = success;
        this.code = success ? ResultCode.SUCCESS.getCode() : ResultCode.COMMON_FAIL.getCode();
        this.msg = success ? ResultCode.SUCCESS.getMessage() : ResultCode.COMMON_FAIL.getMessage();
    }

    public JsonResult(boolean success, ResultCode resultEnum) {
        this.success = success;
        this.code = success ? ResultCode.SUCCESS.getCode() : (resultEnum == null ? ResultCode.COMMON_FAIL.getCode() : resultEnum.getCode());
        this.msg = success ? ResultCode.SUCCESS.getMessage() : (resultEnum == null ? ResultCode.COMMON_FAIL.getMessage() : resultEnum.getMessage());
    }

    public JsonResult(boolean success, T data) {
        this.success = success;
        this.code = success ? ResultCode.SUCCESS.getCode() : ResultCode.COMMON_FAIL.getCode();
        this.msg = success ? ResultCode.SUCCESS.getMessage() : ResultCode.COMMON_FAIL.getMessage();
        this.data = data;
    }

    public JsonResult(boolean success, ResultCode resultEnum, T data) {
        this.success = success;
        this.code = success ? ResultCode.SUCCESS.getCode() : (resultEnum == null ? ResultCode.COMMON_FAIL.getCode() : resultEnum.getCode());
        this.msg = success ? ResultCode.SUCCESS.getMessage() : (resultEnum == null ? ResultCode.COMMON_FAIL.getMessage() : resultEnum.getMessage());
        this.data = data;
    }
}
```

##### 定义生成返回字符串工具类

```java
public class ResultTool {
    public static JsonResult success() {
        return new JsonResult(true);
    }

    public static <T> JsonResult<T> success(T data) {
        return new JsonResult(true, data);
    }

    public static JsonResult fail() {
        return new JsonResult(false);
    }

    public static JsonResult fail(ResultCode resultEnum) {
        return new JsonResult(false, resultEnum);
    }
}
```

### 编写Token工具类

```java
public class TokenUtil {

    public static String generateToken(String data,String secret,int expireDays){
        String token;
        try {
            //过期时间
            Date date = new Date(System.currentTimeMillis()+ (long) expireDays*24*3600*1000);
            //秘钥及加密算法
            Algorithm algorithm = Algorithm.HMAC256(secret);
            //设置头部信息
            Map<String,Object> header = new HashMap<>();
            header.put("typ","JWT");
            header.put("alg","HS256");
            //携带信息，生成签名
            token = JWT.create()
                    .withHeader(header)
                    .withClaim("data",data)
                    .withExpiresAt(date)
                    .sign(algorithm);
        }catch (Exception e){
            e.printStackTrace();
            return  null;
        }
        return token;
    }

    public static boolean verify(String token,String secret){//验证token
        try {
            Algorithm algorithm = Algorithm.HMAC256(secret);
            JWTVerifier verifier = JWT.require(algorithm).build();
            verifier.verify(token);
            return true;
        }catch (Exception e){
            return  false;
        }
    }

    public static String parseToken(String token,String secret){//解析token
        try {
            Algorithm algorithm = Algorithm.HMAC256(secret);
            JWTVerifier verifier = JWT.require(algorithm).build();
            DecodedJWT jwt = verifier.verify(token);
            return jwt.getClaim("data").toString();
        }catch (Exception e){

            return  null;
        }
    }
}
```

### 编写SpringSecurity中配置的处理器

##### 验证成功处理器

```java
@Component
@PropertySource("classpath:token.properties")
public class SuccessHandler implements AuthenticationSuccessHandler {

    @Value("${secret}")
    private String secret;//获取配置文件中的密钥

    private StringRedisTemplate stringRedisTemplate;

    @Value("${expireDays}")//获取配置文件中的过期时间
    private int expireDays;

    @Autowired
    public void setStringRedisTemplate(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException {
        List<String> authorities = authentication.getAuthorities()
                .stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList());
        String authority;
        //赋予权限
        if (authorities.contains("admin")){
            authority="admin";
        }else {
            authority="passenger";
        }
        ObjectMapper objectMapper = new ObjectMapper();
        HashMap<String, Object> data = new HashMap<>();
        data.put("account",authentication.getName());
        data.put("authority",authority);
        //生成token
        String token = TokenUtil.generateToken(objectMapper.writeValueAsString(data), secret, expireDays);
        String s = stringRedisTemplate.opsForValue().get(authentication.getName());
        Passenger passenger = objectMapper.readValue(s, Passenger.class);
        data.clear();
        data.put("token",token);//放入Token
        passenger.setPassword(null);//隐藏密码
        data.put("passenger",passenger);//放入乘客信息
        JsonResult<HashMap<String, Object>> success = ResultTool.success(data);//生成相应字符串
        httpServletResponse.setStatus(HttpServletResponse.SC_ACCEPTED);
        httpServletResponse.setContentType("application/json; charset=UTF-8");//设置响应头
        httpServletResponse.getWriter().write(new ObjectMapper().writeValueAsString(success));//传回
    }
}
```

##### 验证失败处理器

```java
@Component
public class FailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {
        //返回json数据
        JsonResult result;
        if (e instanceof AccountExpiredException) {
            //账号过期
            result = ResultTool.fail(ResultCode.USER_ACCOUNT_EXPIRED);
        } else if (e instanceof BadCredentialsException) {
            //密码错误
            result = ResultTool.fail(ResultCode.USER_CREDENTIALS_ERROR);
        } else if (e instanceof CredentialsExpiredException) {
            //密码过期
            result = ResultTool.fail(ResultCode.USER_CREDENTIALS_EXPIRED);
        } else if (e instanceof DisabledException) {
            //账号不可用
            result = ResultTool.fail(ResultCode.USER_ACCOUNT_DISABLE);
        } else if (e instanceof LockedException) {
            //账号锁定
            result = ResultTool.fail(ResultCode.USER_ACCOUNT_LOCKED);
        } else if (e instanceof UsernameNotFoundException) {
            //用户不存在
            result = ResultTool.fail(ResultCode.USER_ACCOUNT_NOT_EXIST);
        }else{
            //其他错误
            result = ResultTool.fail(ResultCode.COMMON_FAIL);
        }
        httpServletResponse.setContentType("text/json;charset=utf-8");
        httpServletResponse.getWriter().write(new ObjectMapper().writeValueAsString(result));
    }
}
```

##### 未登录异常处理器

由于是前后端分离，实际上这个可以没有

```java
@Component
public class UserAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException {
        httpServletResponse.setContentType("application/json; charset=UTF-8");
        JsonResult fail = ResultTool.fail(ResultCode.USER_NOT_LOGIN);
        httpServletResponse.getWriter().write(new ObjectMapper().writeValueAsString(fail));
    }
}
```

### 编写过滤器

```java
@Component
@PropertySource("classpath:token.properties")
public class GlobalFilter implements Filter {

    @Value("${secret}")
    private String secret;
	//不需要Token的URL列表
    private static final LinkedList<String> NO_NEED_TOKEN_PATH_LIST=new LinkedList<>();

    static {
        NO_NEED_TOKEN_PATH_LIST.add("/login");
        NO_NEED_TOKEN_PATH_LIST.add("/passenger/checkToken");
        NO_NEED_TOKEN_PATH_LIST.add("/passenger/signUp");
        NO_NEED_TOKEN_PATH_LIST.add("/passenger/signUpCheck");
        NO_NEED_TOKEN_PATH_LIST.add("/passenger/forgetPassword");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        //获取请求头中的Token字段
        String header = request.getHeader("EY-token");
        //如果请求路径无需Token则直接放行
        if (NO_NEED_TOKEN_PATH_LIST.contains(request.getServletPath())){
            filterChain.doFilter(servletRequest,servletResponse);
            return;
        }
		//如果请求头token字段为空则返回403状态
        if (header==null||"".equals(header)){
            JsonResult fail = ResultTool.fail(ResultCode.USER_TOKEN_NOTFOUND);
            response.setContentType("application/json; charset=UTF-8");
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write(new ObjectMapper().writeValueAsString(fail));
        }else {
            //如果token认证失败就返回403状态
            if (!TokenUtil.verify(header,secret)) {
                JsonResult fail = ResultTool.fail(ResultCode.USER_TOKEN_INVALID);
                response.setContentType("application/json; charset=UTF-8");
                response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                response.getWriter().write(new ObjectMapper().writeValueAsString(fail));
            }else if (Arrays.asList(request.getServletPath().split("/")).contains("admin")){//如果请求的是管理员路径
                String s = TokenUtil.parseToken(header, secret);//解析Token
                if (s == null) {//如果解析无结果就返回403状态
                    JsonResult fail = ResultTool.fail(ResultCode.USER_TOKEN_INVALID);
                    response.setContentType("application/json; charset=UTF-8");
                    response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                    response.getWriter().write(new ObjectMapper().writeValueAsString(fail));
                }else {
                    s=s.replaceAll("\\\\","");
                    s=s.substring(1,s.length()-1);
                    ObjectMapper objectMapper = new ObjectMapper();
                    JsonNode jsonNode = objectMapper.readTree(s);
                    if ("admin".equals(jsonNode.get("authority").asText())) {//如果成功解析且Token中权限信息为admin就放行
                        filterChain.doFilter(servletRequest,servletResponse);
                    }else {//否则返回403
                        JsonResult fail = ResultTool.fail(ResultCode.NO_PERMISSION);
                        response.setContentType("application/json; charset=UTF-8");
                        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                        response.getWriter().write(new ObjectMapper().writeValueAsString(fail));
                    }
                }
            }else {
                //其他正常情况放行
                filterChain.doFilter(servletRequest, servletResponse);
            }
        }
    }
}
```

### 编写业务层接口及实现类

##### 乘客业务

```java
public interface IPassengerService extends IService<Passenger> {

    /**
     * 注册服务
     * @param mailAddress 邮箱地址
     * @param username 用户名
     * @param password 密码
     * @return 处理结果
     * @throws IOException IO异常
     */
    String signUp(String mailAddress,String username,String password) throws IOException;

    /**
     * 注册验证
     * @param uuid 获取到的uuid
     * @return 处理结果
     */
    String signUpCheck(String uuid);

    /**
     * 忘记密码
     * @param mailAddress 邮箱地址
     * @return 处理结果
     * @throws IOException IO异常
     * @throws MessagingException 邮件发送异常
     */
    String forgetPassword(String mailAddress) throws IOException, MessagingException;

    /**
     * 修改密码
     * @param mailAddress 邮箱
     * @param newPassword 新密码
     * @return 处理结果
     */
    Boolean changePassword(String mailAddress, String newPassword);

    /**
     * 修改密码前验证
     * @param uuid 随机UUID
     * @return 验证结果
     */
    Boolean toChangePassword(String uuid);

    /**
     * 修改个人信息
     * @param preference 偏好
     * @param username 用户名
     * @param sex 性别
     * @param identityNum 身份证号
     * @param birthday 生日
     * @param mailAddress 邮箱地址
     * @return 是否成功
     */
    Boolean changePersonalInfo(String preference, String username, String sex, String identityNum, String birthday, String mailAddress);
}
```

```java
@Service
@PropertySource("classpath:host.properties")
public class PassengerServiceImpl extends ServiceImpl<PassengerMapper, Passenger> implements IPassengerService {

    private StringRedisTemplate stringRedisTemplate;

    private PassengerMapper passengerMapper;

    private SendMail sendMail;

    private ObjectMapper objectMapper;

    @Autowired
    public void setStringRedisTemplate(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Autowired
    public void setPassengerMapper(PassengerMapper passengerMapper) {
        this.passengerMapper = passengerMapper;
    }

    @Autowired
    public void setSendMail(SendMail sendMail) {
        this.sendMail = sendMail;
    }

    @Autowired
    public void setObjectMapper(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public String signUp(String mailAddress, String username, String password) throws IOException {
        QueryWrapper<Passenger> passengerQueryWrapper = new QueryWrapper<>();
        passengerQueryWrapper.eq("mail_address", mailAddress);
        Passenger passenger = passengerMapper.selectOne(passengerQueryWrapper);
        if (passenger != null) {
            return "already";
        } else {
            Passenger passenger1 = new Passenger();
            passenger1.setName(username).setPassword(password).setMailAddress(mailAddress);
            String passengerJson = objectMapper.writeValueAsString(passenger1);
            String uuid = UUID.randomUUID().toString().split("-")[0];
            String html = JsoupUtil.generateCheckMail(uuid, "注册");
            stringRedisTemplate.opsForValue().set(uuid, passengerJson, 5, TimeUnit.MINUTES);
            try {
                sendMail.send(mailAddress, html, "注册验证");
            }catch (Exception e){
                return "addressNotFound";
            }
            return "success";
        }
    }

    @Override
    public String signUpCheck(String uuid) {
        String s = stringRedisTemplate.opsForValue().get(uuid);
        if (s == null) {
            return "expired";
        } else {
            stringRedisTemplate.delete(uuid);
            try {
                Passenger passenger = objectMapper.readValue(s, Passenger.class);
                int insert = passengerMapper.insert(passenger);
                return insert == 1 ? "success" : "failure";
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                return "failure";
            }
        }
    }

    @Override
    public String forgetPassword(String mailAddress) throws IOException, MessagingException {
        QueryWrapper<Passenger> passengerQueryWrapper = new QueryWrapper<>();
        passengerQueryWrapper.eq("mail_address", mailAddress);
        Passenger passenger = passengerMapper.selectOne(passengerQueryWrapper);
        if (passenger == null) {
            return "error";
        } else {
            String s = UUID.randomUUID().toString();
            String checkMail = JsoupUtil.generateCheckMail(s.split("-")[0], "修改密码");
            stringRedisTemplate.opsForValue().set(s, mailAddress, 5, TimeUnit.MINUTES);
            sendMail.send(mailAddress, checkMail, "修改密码");
            return "success";
        }
    }

    @Override
    public Boolean changePassword(String mailAddress, String newPassword) {
        UpdateWrapper<Passenger> passengerUpdateWrapper = new UpdateWrapper<>();
        passengerUpdateWrapper.set("password", newPassword).eq("mail_address", mailAddress);
        return this.update(passengerUpdateWrapper);
    }

    @Override
    public Boolean toChangePassword(String uuid) {
        return stringRedisTemplate.hasKey(uuid);
    }

    @Override
    public Boolean changePersonalInfo(String preference, String name, String sex, String identityNum, String birthday, String mailAddress) {
        UpdateWrapper<Passenger> passengerUpdateWrapper = new UpdateWrapper<>();
        passengerUpdateWrapper.set("preference", preference);
        if (sex != null) {
            passengerUpdateWrapper.set("sex", sex);
        }
        if (name != null) {
            passengerUpdateWrapper.set("name", name);
        }
        if (identityNum != null) {
            passengerUpdateWrapper.set("identity_number", identityNum);
        }
        if (birthday != null) {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
            try {
                Date parse = simpleDateFormat.parse(birthday);
                passengerUpdateWrapper.set("birthday", parse);
            } catch (ParseException e) {
                return false;
            }
        }
        passengerUpdateWrapper.eq("mail_address", mailAddress);
        return this.update(passengerUpdateWrapper);
    }
}
```

##### 机票业务

```java
public interface ITicketService extends IService<Ticket> {
    /**
     * 返回订票座位号
     * @param flight 航班号
     * @param classType 机舱类别
     * @param request 窗/过道偏好
     * @param direction 前后偏好
     * @param date 出发日期
     * @return 座位号
     */
    String getSeatId(String flight, ClassType classType, Preference request, Preference direction, Date date);

    /**
     * 获取剩余座位
     * @param flight 航班号
     * @param date 出发日期
     * @return 座位数
     */
    Integer getRestSeatsNum(String flight,Date date);

    /**
     * 返回航班数量
     * @param availableOnly 是否仅返回可用航班
     * @param includeHistory 是否包含历史记录
     * @return 航班数
     */
    Integer getFlightNumber(boolean availableOnly,boolean includeHistory);

    /**
     * 获取指定机舱的剩余座位数量
     * @param flight 航班号
     * @param classType 机舱类别
     * @param date 出发日期
     * @return 剩余座位数
     */
    Integer getRestSeatsNumByClassType(String flight,ClassType classType,Date date);

    /**
     * 每日00:00同步机票
     */
    void ticketSynchronize();

    /**
     * 获取所有航班信息(当日优先)
     * @param availableOnly 是否只返回可用航班
     * @param includeHistory 是否返回历史记录
     * @return 航班信息
     * @throws JsonProcessingException 转换JSON异常
     */
    String getAllFlightInformation(boolean availableOnly,boolean includeHistory) throws JsonProcessingException;

    /**
     * 根据日期、目的地、出发地获取机票信息
     * @param date 日期
     * @param destination 目的地
     * @param departure 出发地
     * @param availableOnly 是否只返回可用航班
     * @throws ParseException 日期解析异常
     * @throws JsonProcessingException JSON转换异常
     * @return JSON字符串表示的机票信息
     */
    String getFlightInformationByDateOrDestination(String date,String destination,String departure,boolean availableOnly) throws ParseException, JsonProcessingException;

    /**
     * 执行分配算法前进行预处理
     * @param flight 航班号
     * @param classType 机舱类型
     * @param request 窗、过道偏好选择
     * @param direction 前、后偏好选择
     * @param date 日期
     * @return 分配结果
     */
    String beforeGet(String flight, ClassType classType, Preference request, Preference direction, Date date);

    /**
     * 通过分页获取航班
     * @param availableOnly 是否仅返回可用航班
     * @param includeHistory 是否包含历史航班
     * @param page 当前页数
     * @param pageSize 每页记录条数
     * @return JSON字符串
     * @throws JsonProcessingException JSON转换异常
     */
    String getFlightByPage(boolean availableOnly,boolean includeHistory,int page,int pageSize) throws JsonProcessingException;

    /**
     * 根据日期、目的地、出发地、分页获取机票信息
     * @param startDate 开始日期
     * @param endDate 结束日期
     * @param destination 目的地
     * @param departure 出发地
     * @param availableOnly 是否只返回可用航班
     * @param page 页数
     * @param pageSize 每页的记录条数
     * @return JSON字符串
     * @throws JsonProcessingException JSON转换异常
     * @throws ParseException 日期解析异常
     */
    String getFlightInformationByDateOrDestinationAndPage(String startDate,String endDate,String destination,String departure,boolean availableOnly,int page,int pageSize) throws JsonProcessingException, ParseException;

    /**
     * 获取所有目的地
     * @return 目的地数组
     * @throws JsonProcessingException JSON转换异常
     */
    String getDestinations() throws JsonProcessingException;

    /**
     * 获取所有出发地
     * @return 出发地数组
     * @throws JsonProcessingException JSON转换异常
     */
    String getDepartures() throws JsonProcessingException;

    /**
     * 获取指定条件的航班的数量
     * @param availableOnly 是否仅包含可用航班
     * @param startDate 开始日期
     * @param endDate 结束日期
     * @param destination 目的地
     * @param departure 出发地
     * @return 符合条件的航班数量
     * @throws ParseException 日期解析异常
     */
    Integer getFlightNumberByOptions(boolean availableOnly,String startDate,String endDate,String destination,String departure) throws ParseException;
}
```

```java
@Service
@SuppressWarnings("all")
public class TicketServiceImpl extends ServiceImpl<TicketMapper, Ticket> implements ITicketService {

    private PlaneInfoMapper planeInfoMapper;

    private ObjectMapper objectMapper;

    private CalculateMapper calculateMapper;

    @Autowired
    public void setCalculateMapper(CalculateMapper calculateMapper) {
        this.calculateMapper = calculateMapper;
    }

    @Autowired
    public void setPlaneInfoMapper(PlaneInfoMapper planeInfoMapper) {
        this.planeInfoMapper = planeInfoMapper;
    }

    @Autowired
    public void setObjectMapper(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public String getSeatId(String flight, ClassType classType, Preference request, Preference direction, Date date) {
        String seatId;
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.eq("flight", flight).eq("available",true);
        List<Ticket> list = this.list(ticketQueryWrapper);
        Ticket ticket;
        try {
            ticket = list.stream()
                    .filter(t -> t.getDate().getDate() == date.getDate() && t.getDate().after(date))
                    .limit(1)
                    .collect(Collectors.toList())
                    .get(0);
            if (ticket == null) {
                throw new NoAvailableTicketException("没有符合条件的机票");
            }
        } catch (Exception e) {
            return "-1";
        }
        if (this.goOut(ticket, classType)) {
            return "-1";
        }
//        获取之前的共有多少行，方便计算座位号
        String seatString = this.getClass(classType, ticket);
        int all_len = getClassLine(classType,ticket);
        int len = 0;
        int allColumn = this.getLineNumber(classType, ticket);
        String[] seatStringArr;
        if (direction == Preference.BACK) {
            assert seatString != null;
            seatStringArr = new StringBuilder(seatString).reverse().toString().split(",");
        } else {
            seatStringArr = seatString.split(",");
        }
        //是否已经分配座位
        boolean isChange = false;
        int row = 0;
        StringBuilder finalSeatString = new StringBuilder();
        for (int i = 0; i < seatStringArr.length; ++i) {
            if (!isChange) {
                ++len;
            }

            StringBuilder tmp = new StringBuilder(seatStringArr[i]);
            if (!tmp.toString().contains("0") || isChange) {
                finalSeatString.append(tmp);
                if (i != seatStringArr.length - 1) {
                    finalSeatString.append(",");
                }
                continue;
            }
            row = 0;
            if (request == Preference.MID) {
                String[] stringArr = tmp.toString().split(" ");
                tmp = new StringBuilder();
                for (int j = 0; j < stringArr.length; ++j) {
                    String temp = stringArr[j];
                    String tempItem = "";
                    if (temp.length()>2) {
                        tempItem = temp.substring(1, temp.length() - 1);
                    }
                    if (!tempItem.contains("0") || isChange) {
                        tmp.append(temp);
                        if (j != stringArr.length - 1) {
                            tmp.append(" ");
                        }
                        if(!isChange)
                        {
                            row+=temp.length();
                        }
                        continue;
                    }
                    int index = tempItem.indexOf('0');
                    row += index+2;
                    temp = replace0To1(temp,index+1);
                    tmp.append(temp);
                    if (j != stringArr.length - 1) {
                        tmp.append(" ");
                    }
                    isChange = true;

                }
            } else if (request == Preference.WINDOW) {
                if (tmp.charAt(0) == '0') {
                    row = 1;
                    tmp = new StringBuilder(replace0To1(tmp.toString(), 0));
                    isChange = true;
                } else if (tmp.charAt(tmp.length() - 1) == '0') {
                    row = tmp.length()-(tmp.toString().split(" ").length-1);
                    tmp = new StringBuilder(replace0To1(tmp.toString(), tmp.length() - 1));
                    isChange = true;
                }
            } else if (request == Preference.AISLE) {
                String[] stringArr = tmp.toString().split(" ");
                tmp = new StringBuilder();
                for (int j = 0; j < stringArr.length; ++j) {
                    String temp = stringArr[j];
                    if (!temp.contains("0") || isChange) {
                        tmp.append(temp);
                        if (j != stringArr.length - 1) {
                            tmp.append(" ");
                        }
                        if(!isChange)
                        {
                            row+=temp.length();
                        }
                        continue;
                    }
                    if (j == 0) {
                        if (temp.charAt(temp.length() - 1) == '0') {
                            isChange = true;
                            temp = replace0To1(temp, temp.length() - 1);
                            row = temp.length();
                        } else {
                            row += temp.length();
                        }
                    } else if (j == stringArr.length - 1) {
                        if (temp.charAt(0) == '0') {
                            isChange = true;
                            temp = replace0To1(temp, 0);
                            row += 1;
                        } else {
                            row += stringArr[j].length();
                        }
                    } else {
                        if (temp.charAt(0) == '0') {
                            isChange = true;
                            temp = replace0To1(temp, 0);
                            row += 1;
                        } else if (temp.charAt(temp.length() - 1) == '0') {
                            isChange = true;
                            temp = replace0To1(temp, temp.length() - 1);
                            row += stringArr[j].length();
                        } else {
                            row += stringArr[j].length();
                        }
                    }
                    tmp.append(temp);
                    if (j != stringArr.length - 1) {
                        tmp.append(" ");
                    }
                }
            }
            finalSeatString.append(tmp);
            if (i != seatStringArr.length - 1) {
                finalSeatString.append(",");
            }
        }
        if (!isChange) {
            seatId = "-1";
        } else {
//            写入Ticket表，更改航班座位分配情况
            if (direction == Preference.BACK) {
                allColumn += all_len-len+1;
                row =  seatStringArr[len-1].length()-seatStringArr[len-1].split(" ").length-row+2;
                finalSeatString = new StringBuilder(new StringBuilder(finalSeatString.toString()).reverse().toString());
            }
            else
            {
                allColumn += len;
            }
            UpdateWrapper<Ticket> ticketUpdateWrapper = generateUpdateWrapper(classType, finalSeatString.toString(),ticket.getId());
            boolean update = this.update(ticketUpdateWrapper);
            if (!update) {
                return "-1";
            }
            seatId = getId(allColumn, row);
        }
        return seatId;
    }

    /**
     * 返回某个舱的列数
     * @param classType 机舱类型
     * @return 列数
     */
    private int getClassLine(ClassType classType,Ticket ticket) {
        if(classType.equals(ClassType.FIRST))
        {
            return ticket.getFirstClass().split(",").length;
        }
        else if(classType.equals(ClassType.BUSINESS))
        {
            return ticket.getBusinessClass().split(",").length;
        }
        else if(classType.equals(ClassType.ECONOMY))
        {
            return ticket.getEconomyClass().split(",").length;
        }
        return 0;
    }

    /**
     * 执行分配算法前进行预处理
     * @param flight 航班号
     * @param classType 机舱类型
     * @param request 窗、过道偏好选择
     * @param direction 前、后偏好选择
     * @param date 日期
     * @return 分配结果
     */
    @Override
    public String beforeGet(String flight, ClassType classType, Preference request, Preference direction, Date date) {
        if (request == Preference.WINDOW) {
            String seatId = getSeatId(flight, classType, Preference.WINDOW, direction, date);
            if (!"-1".equals(seatId)) {
                return seatId;
            }
            seatId = getSeatId(flight, classType, Preference.MID, direction, date);
            if (!"-1".equals(seatId)) {
                return seatId;
            }
            seatId = getSeatId(flight, classType, Preference.AISLE, direction, date);
            return seatId;
        } else if (request == Preference.NONE){
            String seatId = getSeatId(flight, classType, Preference.MID, direction, date);
            if (!"-1".equals(seatId)) {
                return seatId;
            }
            seatId = getSeatId(flight, classType, Preference.AISLE, direction, date);
            if (!"-1".equals(seatId)) {
                return seatId;
            }
            seatId = getSeatId(flight, classType, Preference.WINDOW, direction, date);
            return seatId;
        }else {
            String seatId = getSeatId(flight, classType, Preference.AISLE, direction, date);
            if (!"-1".equals(seatId)) {
                return seatId;
            }
            seatId = getSeatId(flight, classType, Preference.MID, direction, date);
            if (!"-1".equals(seatId)) {
                return seatId;
            }
            seatId = getSeatId(flight, classType, Preference.WINDOW, direction, date);
            return seatId;
        }
    }

    @Override
    public String getFlightByPage(boolean availableOnly, boolean includeHistory, int page, int pageSize) throws JsonProcessingException {
        Date date = new Date();
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        if (!includeHistory){
            ticketQueryWrapper.ge("date", date);
        }
        if (availableOnly){
            ticketQueryWrapper.eq("available",true);
        }
        Page<Ticket> ticketPage = new Page<>(page, pageSize);
        List<Ticket> tickets = this.page(ticketPage,ticketQueryWrapper)
                .getRecords()
                .stream()
                .filter(ticket -> {
                    if (includeHistory){
                        return true;
                    }else {
                        return ticket.getDate().after(date) || ticket.getDate().equals(date);
                    }
                })
                .sorted(Comparator.comparingLong(o -> o.getDate().getTime()))
                .collect(Collectors.toList());
        LinkedList<HashMap<String, String>> hashMaps = new LinkedList<>();
        for (Ticket ticket : tickets) {
            hashMaps.add(this.jsonPut(ticket));
        }
        return objectMapper.writeValueAsString(this.getCorrectJson("0", "success", hashMaps));
    }

    @Override
    public String getFlightInformationByDateOrDestinationAndPage(String startDate,String endDate, String destination, String departure, boolean availableOnly, int page, int pageSize) throws JsonProcessingException, ParseException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        Date startParse = simpleDateFormat.parse(startDate);
        Date temp = new Date();
        if (temp.getDate() == startParse.getDate()) {
            startParse.setHours(temp.getHours());
            startParse.setMinutes(temp.getMinutes());
            startParse.setSeconds(temp.getSeconds());
        }
        Date endParse = simpleDateFormat.parse(endDate);
        endParse.setDate(endParse.getDate()+1);
        ticketQueryWrapper.eq("destination", destination)
                .le("date",endParse)
                .ge("date",startParse)
                .eq("departure", departure);
        if (availableOnly){
            ticketQueryWrapper.eq("available",true);
        }
        List<Ticket> tickets = this.page(new Page<>(page,pageSize),ticketQueryWrapper)
                .getRecords()
                .stream()
                .sorted(Comparator.comparingLong(o -> o.getDate().getTime()))
                .collect(Collectors.toList());
        LinkedList<HashMap<String, String>> hashMaps = new LinkedList<>();
        for (Ticket ticket : tickets) {
            hashMaps.add(jsonPut(ticket));
        }
        return objectMapper.writeValueAsString(this.getCorrectJson("0", "success", hashMaps));
    }

    @Override
    public String getDestinations() throws JsonProcessingException {
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.select("destination")
                .groupBy("destination");
        LinkedList<HashMap<String, String>> hashMaps = new LinkedList<>();
        this.list(ticketQueryWrapper)
                .stream()
                .map(Ticket::getDestination)
                .forEach((s -> {
                    HashMap<String, String> temp = new HashMap<>();
                    temp.put("value",s);
                    hashMaps.add(temp);
                }));
        return objectMapper.writeValueAsString(hashMaps);
    }

    @Override
    public String getDepartures() throws JsonProcessingException {
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.select("departure")
                .groupBy("departure");
        LinkedList<HashMap<String, String>> hashMaps = new LinkedList<>();
        this.list(ticketQueryWrapper)
                .stream()
                .map(Ticket::getDeparture)
                .forEach(s -> {
                    HashMap<String, String> temp = new HashMap<>();
                    temp.put("value",s);
                    hashMaps.add(temp);
                });
        return objectMapper.writeValueAsString(hashMaps);
    }

    @Override
    public Integer getFlightNumberByOptions(boolean availableOnly, String startDate, String endDate, String destination, String departure) throws ParseException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        Date startParse = simpleDateFormat.parse(startDate);
        Date temp = new Date();
        if (temp.getDate() == startParse.getDate()) {
            startParse.setHours(temp.getHours());
            startParse.setMinutes(temp.getMinutes());
            startParse.setSeconds(temp.getSeconds());
        }
        Date endParse = simpleDateFormat.parse(endDate);
        endParse.setDate(endParse.getDate()+1);
        ticketQueryWrapper.eq("destination", destination)
                .le("date",endParse)
                .ge("date",startParse)
                .eq("departure", departure);
        if (availableOnly){
            ticketQueryWrapper.eq("available",true);
        }
        return this.count(ticketQueryWrapper);
    }


    /**
     * 获取机舱座位信息
     *
     * @param classType 机舱类别
     * @param ticket    ticket对象
     * @return 字符串表示的座位信息
     */
    private String getClass(ClassType classType, Ticket ticket) {
        switch (classType) {
            case FIRST:
                return ticket.getFirstClass();
            case BUSINESS:
                return ticket.getBusinessClass();
            case ECONOMY:
                return ticket.getEconomyClass();
            default:
                return "";
        }
    }

    /**
     * 生成修改SQL
     *
     * @param classType 机舱类别
     * @param str       分配后结果
     * @return UpdateWrapper
     */
    private UpdateWrapper<Ticket> generateUpdateWrapper(ClassType classType, String str,Integer ticketId) {
        UpdateWrapper<Ticket> ticketUpdateWrapper = new UpdateWrapper<>();
        ticketUpdateWrapper.eq("id",ticketId);
        if (classType == ClassType.FIRST) {
            ticketUpdateWrapper.set("first_class", str);
        } else if (classType == ClassType.BUSINESS) {
            ticketUpdateWrapper.set("business_class", str);
        } else {
            ticketUpdateWrapper.set("economy_class", str);
        }
        return ticketUpdateWrapper;
    }

    @Override
    public Integer getRestSeatsNum(String flight, Date date) {
        return this.getRestSeatsNumByClassType(flight, ClassType.FIRST, date)
                + this.getRestSeatsNumByClassType(flight, ClassType.BUSINESS, date)
                + this.getRestSeatsNumByClassType(flight, ClassType.ECONOMY, date);
    }

    @Override
    public Integer getFlightNumber(boolean availableOnly, boolean includeHistory) {
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        if (availableOnly){
            ticketQueryWrapper.eq("available",true);
        }
        if (!includeHistory){
            ticketQueryWrapper.ge("date",new Date());
        }
        return this.count(ticketQueryWrapper);
    }

    @Override
    public Integer getRestSeatsNumByClassType(String flight, ClassType classType, Date date) {
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.eq("flight", flight).ge("date", date).eq("available",true);
        List<Ticket> list = this.list(ticketQueryWrapper);
        if (list == null) {
            return null;
        }
        Ticket ticket = list.stream()
                .filter(t -> t.getDate().getDate() == date.getDate())
                .collect(Collectors.toList())
                .get(0);
        switch (classType) {
            case FIRST:
                String firstClass = ticket.getFirstClass();
                return getInteger(firstClass);
            case BUSINESS:
                String businessClass = ticket.getBusinessClass();
                return getInteger(businessClass);
            case ECONOMY:
                String economyClass = ticket.getEconomyClass();
                return getInteger(economyClass);
            default:
                return null;
        }
    }

    /**
     * 计算一个字符串中0的个数，即空位个数
     * @param str 用0、1表示的机舱座位信息
     * @return 剩余座位个数
     */
    private Integer getInteger(String str) {
        if (str == null) {
            return 0;
        } else {
            String[] split = str.split(",");
            int num = 0;
            for (String s : split) {
                num += countZeroInString(s, '0');
            }
            return num;
        }
    }

    @Override
    @Scheduled(cron = "0 0 0 1/1 * ?")
    public void ticketSynchronize() {
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.groupBy("flight");
        ticketQueryWrapper.select("flight");
        List<String> flights = this.list(ticketQueryWrapper).stream()
                .map(Ticket::getFlight)
                .collect(Collectors.toList());
        for (String flight : flights) {
            ticketQueryWrapper.clear();
            ticketQueryWrapper.eq("flight", flight).eq("always",true);
            ticketQueryWrapper.orderByDesc("date");
            Ticket ticket = this.list(ticketQueryWrapper)
                    .stream()
                    .limit(1)
                    .collect(Collectors.toList())
                    .get(0);
            QueryWrapper<PlaneInfo> planeInfoQueryWrapper = new QueryWrapper<>();
            planeInfoQueryWrapper.eq("type", ticket.getPlaneType());
            PlaneInfo planeInfo = planeInfoMapper.selectOne(planeInfoQueryWrapper);
            Date date = new Date(ticket.getDate().getTime());
            Ticket ticket1 = new Ticket();
            date.setDate(date.getDate() + 1);
            ticket1.setFirstClass(planeInfo.getFirstClass())
                    .setBusinessClass(planeInfo.getBusinessClass())
                    .setEconomyClass(planeInfo.getEconomyClass())
                    .setDestination(ticket.getDestination())
                    .setDeparture(ticket.getDeparture())
                    .setFlight(flight)
                    .setDate(date)
                    .setPlaneType(planeInfo.getType());
            this.save(ticket1);
        }
    }

    @Scheduled(cron = "0 0/1 * * * ?")//每天生成一批新航班
    public void calculate(){
        QueryWrapper<Calculate> calculateQueryWrapper = new QueryWrapper<>();
        calculateQueryWrapper.eq("already",false);
        List<Calculate> calculates = calculateMapper.selectList(calculateQueryWrapper);
        List<Calculate> collect = calculates.stream()
                .filter(calculate -> {
                    return new Date().after(calculate.getDate());
                })
                .collect(Collectors.toList());
        for (Calculate calculate : collect) {
            UpdateWrapper<Calculate> calculateUpdateWrapper = new UpdateWrapper<>();
            calculateUpdateWrapper.
                    set("already",true).
                    set("result",calculate.getMolecular()/calculate.getDenominator())
                    .eq("id",calculate.getId());
            calculateMapper.update(null,calculateUpdateWrapper);
        }
    }

    /**
     * 创建航班信息的JSON对应的HashMap
     * @param ticket Ticket对象
     * @return 包含8个键值对的HashMap
     */
    private HashMap<String, String> jsonPut(Ticket ticket) {
        HashMap<String, String> temp = new HashMap<>(10);
        temp.put("flight", ticket.getFlight());
        temp.put("destination", ticket.getDestination());
        temp.put("departure", ticket.getDeparture());
        temp.put("planeType", ticket.getPlaneType());
        temp.put("firstClass", String.valueOf(this.getInteger(ticket.getFirstClass())));
        temp.put("businessClass", String.valueOf(this.getInteger(ticket.getBusinessClass())));
        temp.put("economyClass", String.valueOf(this.getInteger(ticket.getEconomyClass())));
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        temp.put("time", simpleDateFormat.format(ticket.getDate()));
        temp.put("available",String.valueOf(ticket.getAvailable()));
        return temp;
    }

    /**
     * 获取正确格式的JSON对应的HashMap
     * @param code 状态返回码
     * @param msg 信息
     * @param hashMapList 要转换成HashMap的map list对象
     * @return 包含四个键值对的HashMap
     */
    public HashMap<String, Object> getCorrectJson(String code, String msg, List<HashMap<String, String>> hashMapList) {
        HashMap<String, Object> stringObjectHashMap = new HashMap<>(5);
        stringObjectHashMap.put("code", code);
        stringObjectHashMap.put("count", hashMapList.size());
        stringObjectHashMap.put("msg", msg);
        stringObjectHashMap.put("data", hashMapList);
        return stringObjectHashMap;
    }

    @Override
    public String getAllFlightInformation(boolean availableOnly,boolean includeHistory) throws JsonProcessingException {
        Date date = new Date();
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        if (!includeHistory){
            ticketQueryWrapper.ge("date", date);
        }
        if (availableOnly){
            ticketQueryWrapper.eq("available",true);
        }
        List<Ticket> tickets = this.list(ticketQueryWrapper)
                .stream()
                .filter(ticket -> {
                    if (includeHistory){
                        return true;
                    }else {
                        return ticket.getDate().after(date) || ticket.getDate().equals(date);
                    }
                })
                .sorted(Comparator.comparingLong(o -> o.getDate().getTime()))
                .collect(Collectors.toList());
        LinkedList<HashMap<String, String>> hashMaps = new LinkedList<>();
        for (Ticket ticket : tickets) {
            hashMaps.add(this.jsonPut(ticket));
        }
        return objectMapper.writeValueAsString(this.getCorrectJson("0", "success", hashMaps));
    }

    @Override
    public String getFlightInformationByDateOrDestination(String date, String destination, String departure,boolean availableOnly) throws ParseException, JsonProcessingException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date parse = simpleDateFormat.parse(date);
        Date temp = new Date();
        if (temp.getDate() == parse.getDate()) {
            parse.setHours(temp.getHours());
            parse.setMinutes(temp.getMinutes());
            parse.setSeconds(temp.getSeconds());
        }
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.eq("destination", destination)
                .eq("departure", departure);
        if (availableOnly){
            ticketQueryWrapper.eq("available",true);
        }
        List<Ticket> tickets = this.list(ticketQueryWrapper)
                .stream()
                .filter(ticket -> ticket.getDate().getDate() == parse.getDate() && ticket.getDate().after(parse) || ticket.getDate().equals(parse))
                .sorted(Comparator.comparingLong(o -> o.getDate().getTime()))
                .collect(Collectors.toList());
        LinkedList<HashMap<String, String>> hashMaps = new LinkedList<>();
        for (Ticket ticket : tickets) {
            hashMaps.add(jsonPut(ticket));
        }
        return objectMapper.writeValueAsString(this.getCorrectJson("0", "success", hashMaps));
    }

    /**
     * 获取字符串中指定字符的数量
     *
     * @param s 字符串
     * @param x 要统计的字符
     * @return 字符串中字符x的个数
     */
    private int countZeroInString(String s, char x) {
        int num = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == x) {
                ++num;
            }
        }
        return num;
    }

    /**
     * 获得具体的座位号
     *
     * @param allColumn 行数
     * @param row       列号
     * @return 座位号
     */
    private String getId(int allColumn, int row) {
        char c = 'A';
        return String.valueOf((char) ((int) c + row - 1)) + allColumn;
    }

    /**
     * 获取某个舱的共有多少行
     * @param ticket    ticket类对象
     * @param classType 机舱类别
     * @return 行数
     */
    private int getLineNumber(ClassType classType, Ticket ticket) {
        switch (classType) {
            case FIRST:
                return 0;
            case BUSINESS:
                String firstClass = ticket.getFirstClass();
                if (firstClass == null) {
                    return 0;
                } else {
                    return firstClass.split(",").length;
                }
            case ECONOMY:
                String firstClass1 = ticket.getFirstClass();
                String businessClass = ticket.getBusinessClass();
                int a = 0;
                if (firstClass1 == null) {
                    a += 0;
                } else {
                    a += firstClass1.split(",").length;
                }
                if (businessClass != null) {
                    a += businessClass.split(",").length;
                }
                return a;
            default:
                return -1;
        }
    }

    /**
     * 判断是否跳出
     * @param ticket    ticket对象
     * @param classType 机舱类别
     * @return 布尔值，true则跳出
     */
    private boolean goOut(Ticket ticket, ClassType classType) {
        switch (classType) {
            case FIRST:
                return ticket.getFirstClass() == null;
            case BUSINESS:
                return ticket.getBusinessClass() == null;
            case ECONOMY:
                return ticket.getEconomyClass() == null;
            default:
                return true;
        }
    }

    /**
     * 替换指定位置的0为1
     *
     * @param s     字符串
     * @param index 位置
     * @return 替换后的串
     */
    private String replace0To1(String s, int index) {
        return new StringBuilder(s).replace(index, index + 1, "1").toString();
    }
}
```

##### 订单业务

```java
public interface IOrderRecordService extends IService<OrderRecord> {

    /**
     * 判断一个用户是否已经购买了某天的某一班机的票
     * @param flight 航班号
     * @param identityNum 身份证号
     * @param orderDate 日期
     * @return 布尔值，true表示已购买
     */
    Boolean hasBought(String flight, String identityNum, Date orderDate);

    /**
     * 修改满意度，仅限一次
     * @param satisfaction 满意度，使用整型描述，值介于0~100之间
     * @param identityNum 身份证号
     * @param orderDate 日期
     * @param flight 航班号
     * @return 是否更新成功
     */
    Boolean satisfactionChange(int satisfaction,String flight,String identityNum,Date orderDate);

    /**
     * 插入购票记录
     * @param orderRecord 一条记录
     * @return 是否插入成功
     */
    Boolean insertRecord(OrderRecord orderRecord);

    /**
     * 查询一个用户订过的所有的票
     * @param identityNum 身份证号
     * @return 记录
     */
    LinkedList<OrderRecord> queryRecord(String identityNum);

    /**
     * 查询用户某天订购的所有机票
     * @param identityNum 身份证号
     * @param date 日期
     * @return 记录
     */
    LinkedList<OrderRecord> queryRecordByDate(String identityNum,Date date);

    /**
     * 获取单个记录的满意度评价值
     * @param time 时间
     * @param flight 航班
     * @param identityNum 身份证号
     * @return 满意度
     * @throws ParseException 日期解析异常
     */
    Integer getSatisfactionForOneRecord(String time,String flight,String identityNum) throws ParseException;

    /**
     * 退票
     * @param flight 航班号
     * @param date 日期
     * @param identityNum 身份证号
     * @throws ParseException 日期解析异常
     * @throws IOException IO异常
     * @return 是否取消成功
     */
    Boolean cancelTicket(String flight, String date, @Nullable String identityNum) throws ParseException, IOException;

    /**
     * 获取历史记录数量
     * @param identityNumber 身份证号
     * @return 历史记录数量
     */
    Integer getRecordsNumber(String identityNumber);

    /**
     * 通过分页获取历史记录
     * @param identityNumber 身份证号
     * @param page 页数
     * @param pageSize 每一页记录的条数
     * @return 历史记录
     * @throws JsonProcessingException JSON解析异常
     */
    String getRecordsByPage(String identityNumber,int page,int pageSize) throws JsonProcessingException;

}
```

```java
@Service
public class OrderRecordServiceImpl extends ServiceImpl<OrderRecordMapper, OrderRecord> implements IOrderRecordService {

    private static final ReentrantLock LOCK = new ReentrantLock(true);

    private SendMail sendMail;

    private RedisTemplate<String, Object> redisTemplate;

    private ThreadPoolTaskExecutor threadPoolTaskExecutor;

    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    public void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    @Autowired
    public void setStringRedisTemplate(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Autowired
    public void setThreadPoolTaskExecutor(ThreadPoolTaskExecutor threadPoolTaskExecutor) {
        this.threadPoolTaskExecutor = threadPoolTaskExecutor;
    }

    @Autowired
    public void setSendMail(SendMail sendMail) {
        this.sendMail = sendMail;
    }

    @Override
    public Boolean hasBought(String flight, String identityNum, Date orderDate) {
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        orderRecordQueryWrapper.eq("flight", flight)
                .eq("canceled",false)
                .eq("passenger_identity_number", identityNum);
        List<OrderRecord> list = this.list(orderRecordQueryWrapper);
        return list.stream().anyMatch(orderRecord -> orderRecord.getFlightDate().getDate() == orderDate.getDate());
    }

    @Override
    public Boolean satisfactionChange(int satisfaction, String flight, String identityNum, Date orderDate) {
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        orderRecordQueryWrapper
                .eq("flight", flight)
                .eq("passenger_identity_number", identityNum)
                .eq("flight_date", orderDate);
        if (this.getOne(orderRecordQueryWrapper).getSatisfaction() != null) {
            return Boolean.FALSE;
        }
        UpdateWrapper<OrderRecord> orderRecordUpdateWrapper = new UpdateWrapper<>();
        orderRecordUpdateWrapper.set("satisfaction", satisfaction)
                .eq("flight", flight)
                .eq("passenger_identity_number", identityNum)
                .eq("flight_date", orderDate);
        return this.update(orderRecordUpdateWrapper);
    }

    @Override
    public Boolean insertRecord(OrderRecord orderRecord) {
        return this.save(orderRecord);
    }

    @Override
    public LinkedList<OrderRecord> queryRecord(String identityNum) {
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        orderRecordQueryWrapper.eq("passenger_identity_number", identityNum);
        return new LinkedList<>(this.list(orderRecordQueryWrapper));
    }

    @Override
    public LinkedList<OrderRecord> queryRecordByDate(String identityNum, Date date) {
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        orderRecordQueryWrapper.eq("passenger_identity_number", identityNum)
                .eq("order_date", date);
        return new LinkedList<>(this.list(orderRecordQueryWrapper));
    }

    @Override
    public Integer getSatisfactionForOneRecord(String time, String flight, String identityNum) throws ParseException {
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        orderRecordQueryWrapper
                .eq("passenger_identity_number", identityNum)
                .eq("flight", flight)
                .eq("order_date", simpleDateFormat.parse(time));
        OrderRecord one = this.getOne(orderRecordQueryWrapper);
        return one.getSatisfaction();
    }

    @Override
    public Boolean cancelTicket(String flight, String date, String identityNum) throws ParseException, IOException {
        Date parse = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(date);
        if (parse.before(new Date())) {
            return Boolean.FALSE;
        }
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        orderRecordQueryWrapper
                .eq("flight", flight)
                .eq("flight_date", parse);
        List<OrderRecord> list = this.list(orderRecordQueryWrapper);
        List<OrderRecord> orderRecords;
        UpdateWrapper<OrderRecord> orderRecordUpdateWrapper = new UpdateWrapper<>();
        orderRecordUpdateWrapper.set("canceled", true).eq("flight", flight).eq("flight_date", parse);
        if (identityNum != null) {
            orderRecordUpdateWrapper.eq("passenger_identity_number", identityNum);
            orderRecords = list.stream()
                    .filter(orderRecord -> identityNum.equals(orderRecord.getPassengerIdentityNumber()))
                    .limit(1)
                    .collect(Collectors.toList());
        } else {
            orderRecords = new ArrayList<>(list);
        }
        boolean update = this.update(orderRecordUpdateWrapper);
        if (!update) {
            return Boolean.FALSE;
        }
        for (OrderRecord orderRecord : orderRecords) {
            String s = JsoupUtil.generateTicketNotifyMail(date, flight
                    , orderRecord.getDeparture()
                    , orderRecord.getDestination()
                    , orderRecord.getSeatNumber()
                    , "已取消");
            redisTemplate.opsForList().leftPush("canceled", orderRecord);
            threadPoolTaskExecutor.submit(() -> {
                try {
                    sendMail.send(orderRecord.getPassengerMailAddress(), s, "航班取消");
                } catch (MessagingException e) {
                    e.printStackTrace();
                }
            });
        }
        return Boolean.TRUE;
    }

    @Override
    public Integer getRecordsNumber(String identityNumber) {
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        orderRecordQueryWrapper.eq("passenger_identity_number",identityNumber);
        return this.count(orderRecordQueryWrapper);
    }

    @Override
    public String getRecordsByPage(String identityNumber, int page, int pageSize) throws JsonProcessingException {
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        orderRecordQueryWrapper.eq("passenger_identity_number",identityNumber);
        List<OrderRecord> records = this.page(new Page<>(page, pageSize), orderRecordQueryWrapper)
                .getRecords()
                .stream()
                .peek((orderRecord -> {
                    if ("first".equals(orderRecord.getClassType())){
                        orderRecord.setClassType("头等舱");
                    }else if ("business".equals(orderRecord.getClassType())){
                        orderRecord.setClassType("商务舱");
                    }else {
                        orderRecord.setClassType("经济舱");
                    }
                })).collect(Collectors.toList());
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
        return objectMapper.writeValueAsString(records);
    }

    @Scheduled(cron = "0 0/1 * * * ?")
    public void noticeBeforeTakeOff() {
        LOCK.lock();
        Long size = stringRedisTemplate.opsForList().size("canceled");
        List<String> canceled = stringRedisTemplate.opsForList().range("canceled", 0, Objects.requireNonNull(size).intValue());
        LOCK.unlock();
        ObjectMapper objectMapper = new ObjectMapper();
        LinkedList<OrderRecord> cancels = new LinkedList<>();
        for (String s : canceled) {
            try {
                cancels.add(objectMapper.readValue(s, OrderRecord.class));
            } catch (Exception ignored) {
            }
        }
        List<String> canceledFlights = cancels.stream()
                .map(OrderRecord::getFlight)
                .collect(Collectors.toList());
        List<Date> canceledDate = cancels.stream()
                .map(OrderRecord::getFlightDate)
                .collect(Collectors.toList());
        Long orderSize = stringRedisTemplate.opsForList().size("orders");
        LinkedList<OrderRecord> orderRecords = new LinkedList<>();
        ListOperations<String, String> ops = stringRedisTemplate.opsForList();
        for (int i = 0; i < orderSize; i++) {
            try {
                OrderRecord orderRecord = objectMapper.readValue(ops.leftPop("orders"), OrderRecord.class);
                orderRecords.add(orderRecord);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
        }
        List<OrderRecord> collect = orderRecords.stream()
                .sorted(Comparator.comparing(OrderRecord::getFlightDate))
                .filter(orderRecord -> !canceledFlights.contains(orderRecord.getFlight()) || !canceledDate.contains(orderRecord.getFlightDate()))
                .collect(Collectors.toList());
        Date now = new Date();
        for (OrderRecord orderRecord : collect) {
            Date flightDate = orderRecord.getFlightDate();
            long abs = Math.abs(flightDate.getTime() - now.getTime());
            if (abs <= 1800000L) {
                collect.remove(orderRecord);
                threadPoolTaskExecutor.submit(() -> {
                    try {
                        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                        String s = JsoupUtil.generateTicketNotifyMail(simpleDateFormat.format(orderRecord.getFlightDate())
                                , orderRecord.getFlight()
                                , orderRecord.getDeparture()
                                , orderRecord.getDestination()
                                , orderRecord.getSeatNumber()
                                , "将在三十分钟内起飞");
                        sendMail.send(orderRecord.getPassengerMailAddress()
                                , s
                                , "航班提醒");
                    } catch (MessagingException | IOException e) {
                        e.printStackTrace();
                    }
                });
            }
        }
        LOCK.lock();
        for (OrderRecord orderRecord : collect) {
            redisTemplate.opsForList().leftPush("orders", orderRecord);
        }
        LOCK.unlock();
    }
}
```

##### 公告业务

```java
public interface IAnnounceService{
    /**
     * 获取发布的所有公告并更新对应用户最后查看公告的时间
     * @param mailAddress 邮箱地址
     * @return 公告类的链表
     */
    LinkedList<Announcement> getAllAnnounce(String mailAddress);

    /**
     * 未读公告数量
     * @param mailAddress 邮箱地址
     * @return 未读公告的数量
     */
    Long numOfNotViewedAnnounce(String mailAddress);

    /**
     * 获取指定数量的公告
     * @param account 账号
     * @param increment 请求的数量
     * @param nowSize 现有数量
     * @return 公告列表或null
     */
    LinkedList<Announcement> getAnnounceBySize(String account,int increment,int nowSize);
}
```

```java
@Service
public class AnnounceServiceImpl implements IAnnounceService {

    private MongoTemplate mongoTemplate;

    private PassengerMapper passengerMapper;

    @Autowired
    public void setPassengerMapper(PassengerMapper passengerMapper) {
        this.passengerMapper = passengerMapper;
    }

    @Autowired
    public void setMongoTemplate(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    @Override
    public LinkedList<Announcement> getAllAnnounce(String mailAddress) {
        UpdateWrapper<Passenger> passengerUpdateWrapper = new UpdateWrapper<>();
        passengerUpdateWrapper.set("last_view_date",new Date()).eq("mail_address",mailAddress);
        passengerMapper.update(null,passengerUpdateWrapper);
        return new LinkedList<>(mongoTemplate.findAll(Announcement.class));
    }

    @Override
    public Long numOfNotViewedAnnounce(String mailAddress) {
        QueryWrapper<Passenger> passengerQueryWrapper = new QueryWrapper<>();
        passengerQueryWrapper.eq("mail_address",mailAddress);
        Passenger passenger = passengerMapper.selectOne(passengerQueryWrapper);
        if (passenger.getLastViewDate() == null) {
            return mongoTemplate.count(new Query(), Announcement.class);
        }else {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String format = simpleDateFormat.format(passenger.getLastViewDate());
            Query query = new Query();
            query.addCriteria(Criteria.where("date").gte(format));
            return mongoTemplate.count(query, Announcement.class);
        }
    }

    @Override
    public LinkedList<Announcement> getAnnounceBySize(String account, int increment,int nowSize) {
        UpdateWrapper<Passenger> passengerUpdateWrapper = new UpdateWrapper<>();
        passengerUpdateWrapper.set("last_view_date",new Date()).eq("mail_address",account);
        passengerMapper.update(null,passengerUpdateWrapper);
        Query query = new Query();
        query.with(PageRequest.of(nowSize,increment));
        query.with(Sort.by(Sort.Direction.DESC,"date"));
        return new LinkedList<>(mongoTemplate.find(query, Announcement.class, "announcement"));
    }
}
```

##### 管理员业务

```java
public interface IAdminService {

    /**
     * 发布公告
     * @param html 前端传回的带格式文档
     * @param account 账号
     * @param name 名字
     * @return 是否插入成功
     */
    Boolean announce(String html,String account,String name);

    /**
     * 添加航班
     * @param hashMap 参数表
     * @throws ParseException 日期解析异常
     * @return 是否添加成功
     */
    Boolean addFlight(HashMap<String, String> hashMap) throws ParseException;

    /**
     * 停飞航班
     * @param flight 航班号
     * @param date 日期
     * @param always 是否持续
     * @param name 操作员姓名
     * @param account 操作员账号
     * @throws ParseException 日期解析异常
     * @return 操作是否成功
     */
    Boolean stopFlight(String flight,String date,String always,String account,String name) throws ParseException;

    /**
     * 恢复航班
     * @param flight 航班号
     * @param date 日期
     * @param always 是否持续
     * @param account 操作员账号
     * @param name 操作员姓名
     * @param planeType 机型
     * @return 恢复是否成功
     * @throws ParseException 日期解析异常
     */
    Boolean reAvailable(String flight,String date,String always,String account,String name,String planeType) throws ParseException;
}
```

```java
@Service
public class AdminServiceImpl implements IAdminService {

    private MongoTemplate mongoTemplate;

    private TicketMapper ticketMapper;

    private PlaneInfoMapper planeInfoMapper;

    @Autowired
    public void setPlaneInfoMapper(PlaneInfoMapper planeInfoMapper) {
        this.planeInfoMapper = planeInfoMapper;
    }

    @Autowired
    public void setTicketMapper(TicketMapper ticketMapper) {
        this.ticketMapper = ticketMapper;
    }

    @Autowired
    public void setMongoTemplate(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    @Override
    public Boolean announce(String html,String account,String name) {
        Announcement announcement = new Announcement();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        announcement.setAdminAccount(account)
                .setAdminName(name)
                .setHtml(html)
                .setDate(simpleDateFormat.format(new Date()));
        try {
            mongoTemplate.insert(announcement,"announcement");
            return Boolean.TRUE;
        }catch (Exception e){
            return Boolean.FALSE;
        }

    }

    @Override
    public Boolean addFlight(HashMap<String, String> hashMap) throws ParseException {
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.select("flight").groupBy("flight");
        List<String> flights = ticketMapper.selectList(ticketQueryWrapper).stream()
                .map(Ticket::getFlight)
                .collect(Collectors.toList());
        if (flights.contains(hashMap.get("flight"))){
            return Boolean.FALSE;
        }
        QueryWrapper<PlaneInfo> planeInfoQueryWrapper = new QueryWrapper<>();
        planeInfoQueryWrapper.eq("type",hashMap.get("planeType"));
        PlaneInfo planeInfo = planeInfoMapper.selectOne(planeInfoQueryWrapper);
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Ticket ticket = new Ticket();
        ticket.setFlight(hashMap.get("flight"))
                .setDeparture(hashMap.get("departure"))
                .setDestination(hashMap.get("destination"))
                .setPlaneType(hashMap.get("planeType"))
                .setDate(simpleDateFormat.parse(hashMap.get("date")))
                .setFirstClass(planeInfo.getFirstClass())
                .setBusinessClass(planeInfo.getBusinessClass())
                .setEconomyClass(planeInfo.getEconomyClass())
                .setAlways(Boolean.FALSE);
        if (Boolean.parseBoolean(hashMap.get("always"))) {
            ticket.setAlways(Boolean.TRUE);
        }
        return ticketMapper.insert(ticket)>0?Boolean.TRUE:Boolean.FALSE;
    }

    @Override
    public Boolean stopFlight(String flight, String date, String always,String account,String name) throws ParseException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date parse = simpleDateFormat.parse(date);
        UpdateWrapper<Ticket> ticketUpdateWrapper = new UpdateWrapper<>();
        ticketUpdateWrapper.eq("flight",flight).set("available",false);
        if (Boolean.parseBoolean(always)){
            ticketUpdateWrapper.ge("date",parse).set("always",false);
        }else {
            ticketUpdateWrapper.eq("date",parse);
        }
        return ticketMapper.update(null, ticketUpdateWrapper)>0?Boolean.TRUE:Boolean.FALSE;
    }

    @Override
    public Boolean reAvailable(String flight, String date, String always,String account,String name,String planeType) throws ParseException {
        QueryWrapper<PlaneInfo> planeInfoQueryWrapper = new QueryWrapper<>();
        planeInfoQueryWrapper.eq("type",planeType);
        PlaneInfo planeInfo = planeInfoMapper.selectOne(planeInfoQueryWrapper);
        UpdateWrapper<Ticket> ticketUpdateWrapper = new UpdateWrapper<>();
        ticketUpdateWrapper.set("available",true)
                .set("first_class",planeInfo.getFirstClass())
                .set("business_class",planeInfo.getBusinessClass())
                .set("economy_class",planeInfo.getEconomyClass())
                .eq("flight",flight);
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        if (Boolean.parseBoolean(always)){
            ticketUpdateWrapper.ge("date",simpleDateFormat.parse(date))
                    .set("always",true);
        }else {
            ticketUpdateWrapper.eq("date",simpleDateFormat.parse(date));
        }
        return ticketMapper.update(null, ticketUpdateWrapper)>0?Boolean.TRUE:Boolean.FALSE;
    }

}
```

##### 操作记录业务

```java
public interface IOperationRecordService extends IService<OperationRecord> {
    /**
     * 添加一条操作记录
     * @param account 账号
     * @param name 操作员姓名
     * @param operation 操作描述
     * @return 是否插入成功
     */
    Boolean addRecord(String account,String name,String operation);
}
```

```java
@Service
public class OperationRecordServiceImpl extends ServiceImpl<OperationRecordMapper, OperationRecord> implements IOperationRecordService {
    @Override
    public Boolean addRecord(String account, String name, String operation) {
        OperationRecord operationRecord = new OperationRecord();
        operationRecord.setName(name)
                .setAccount(account)
                .setOperation(operation)
                .setDate(new Date());
        return this.save(operationRecord);
    }
}
```

### 编写剩余工具类

##### Map映射工具类

此类用于将字符串与枚举类进行映射

```java
public class MapUtil {
    /**
     * 获取字符串与偏好枚举类的对应map
     * @return map
     */
    public static HashMap<String, Preference> getStringEnumMap(){
        HashMap<String, Preference> stringPreferenceHashMap = new HashMap<>(5);
        stringPreferenceHashMap.put("none", Preference.NONE);
        stringPreferenceHashMap.put("window", Preference.WINDOW);
        stringPreferenceHashMap.put("aisle", Preference.AISLE);
        stringPreferenceHashMap.put("front", Preference.FRONT);
        stringPreferenceHashMap.put("back", Preference.BACK);
        return stringPreferenceHashMap;
    }

    /**
     * 获取字符串与机舱类别对应的map
     * @return map
     */
    public static HashMap<String, ClassType> getClassEnumMap(){
        HashMap<String, ClassType> stringClassTypeHashMap = new HashMap<>(3);
        stringClassTypeHashMap.put("first", ClassType.FIRST);
        stringClassTypeHashMap.put("business", ClassType.BUSINESS);
        stringClassTypeHashMap.put("economy", ClassType.ECONOMY);
        return stringClassTypeHashMap;
    }
}
```

##### 生成邮件模板工具类

```java
public class JsoupUtil {

    public static String generateCheckMail(String verificationCode,String op) throws IOException {
        InputStream resourceAsStream = JsoupUtil.class.getClassLoader().getResourceAsStream("CheckMail.html");
        File checkMail = new File("CheckMail");
        FileUtils.copyInputStreamToFile(Objects.requireNonNull(resourceAsStream),checkMail);
        Document document = Jsoup.parse(FileUtils.readFileToString(checkMail, StandardCharsets.UTF_8));
        Element operation = document.getElementById("operation");
        Element link = document.getElementById("link");
        operation.text(op);
        link.text(verificationCode);
        return document.toString();
    }

    public static String generateTicketNotifyMail(String date,String flight,String departure,String destination,String seat,String status) throws IOException {
        InputStream resourceAsStream = JsoupUtil.class.getClassLoader().getResourceAsStream("TicketNotify.html");
        File ticketNotify = new File("TicketNotify");
        FileUtils.copyInputStreamToFile(Objects.requireNonNull(resourceAsStream),ticketNotify);
        Document document = Jsoup.parse(FileUtils.readFileToString(ticketNotify, StandardCharsets.UTF_8));
        Element info = document.getElementById("info");
        Element status1 = document.getElementById("status");
        status1.text(status);
        info.text(date+"的,出发地为："+departure+",目的地为："+destination+",座号为："+seat+"的"+flight);
        return document.toString();
    }
}
```

##### 结果JSON字符串生成类

```java
public class WriteUtil {
    
    public static String generateCorrectOrderRecordJson(LinkedList<OrderRecord> orderRecords) throws JsonProcessingException {
        List<HashMap<String, Object>> hashMaps = new LinkedList<>();
        for (OrderRecord orderRecord : orderRecords) {
            HashMap<String, Object> stringObjectHashMap = new HashMap<>(10);
            stringObjectHashMap.put("flight", orderRecord.getFlight());
            stringObjectHashMap.put("planeType", orderRecord.getPlaneType());
            stringObjectHashMap.put("departure", orderRecord.getDeparture());
            stringObjectHashMap.put("destination", orderRecord.getDestination());
            stringObjectHashMap.put("seat", orderRecord.getSeatNumber());
            stringObjectHashMap.put("satisfaction", orderRecord.getSatisfaction());
            stringObjectHashMap.put("canceled",orderRecord.getCanceled());
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            stringObjectHashMap.put("orderDate",simpleDateFormat.format(orderRecord.getOrderDate()));
            if ("first".equals(orderRecord.getClassType())){
                stringObjectHashMap.put("class","头等舱");
            }else if ("business".equals(orderRecord.getClassType())){
                stringObjectHashMap.put("class","商务舱");
            }else if("economy".equals(orderRecord.getClassType())){
                stringObjectHashMap.put("class","经济舱");
            }
            stringObjectHashMap.put("seat",orderRecord.getSeatNumber());

            stringObjectHashMap.put("time",simpleDateFormat.format(orderRecord.getFlightDate()));
            hashMaps.add(stringObjectHashMap);
        }
        return generateUniversalJsonForHashMaps(hashMaps);
    }


    public static String generateUniversalJson(List<Object> list) throws JsonProcessingException {
        HashMap<String, Object> hashmap = new HashMap<>(5);
        hashmap.put("code",0);
        hashmap.put("count",list.size());
        hashmap.put("msg","success");
        hashmap.put("data",list);
        ObjectMapper objectMapper = new ObjectMapper();
        return objectMapper.writeValueAsString(hashmap);
    }

    public static String generateUniversalJsonForHashMaps(List<HashMap<String, Object>> hashMaps) throws JsonProcessingException {
        HashMap<Object, Object> hashmap = new HashMap<>(5);
        hashmap.put("code",0);
        hashmap.put("count",hashMaps.size());
        hashmap.put("msg","success");
        hashmap.put("data",hashMaps);
        ObjectMapper objectMapper = new ObjectMapper();
        return objectMapper.writeValueAsString(hashmap);
    }
}
```

##### 邮件发送工具类

```java
@Component
public class SendMail {

    private final JavaMailSender javaMailSender;

    @Autowired
    public SendMail(JavaMailSender javaMailSender) {
        this.javaMailSender = javaMailSender;
    }

    public void send(String mail, String text, String subject) throws MessagingException {
        MimeMessage mimeMessage = javaMailSender.createMimeMessage();
        MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage,true,"UTF-8");
        mimeMessageHelper.setSubject(subject);
        mimeMessageHelper.setFrom("201632404@qq.com");
        mimeMessageHelper.setText(text,true);
        mimeMessageHelper.setTo(mail);
        javaMailSender.send(mimeMessage);
    }
}
```

### 编写AOP切面类

此类主要用于购票后进行通知、记录分配情况供后续分析计算、记录管理员操作等功能

```java
@Component
@Aspect
public class PointCutUtil {

    private OrderRecordServiceImpl orderRecordService;

    private TicketMapper ticketMapper;

    private CalculateMapper calculateMapper;

    private OrderRecordMapper orderRecordMapper;

    @Autowired
    public void setOrderRecordMapper(OrderRecordMapper orderRecordMapper) {
        this.orderRecordMapper = orderRecordMapper;
    }

    @Autowired
    public void setCalculateMapper(CalculateMapper calculateMapper) {
        this.calculateMapper = calculateMapper;
    }

    private SendMail sendMail;

    private ThreadPoolTaskExecutor threadPoolTaskExecutor;

    @Autowired
    public void setTicketMapper(TicketMapper ticketMapper) {
        this.ticketMapper = ticketMapper;
    }

    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    public void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    @Autowired
    public void setThreadPoolTaskExecutor(ThreadPoolTaskExecutor threadPoolTaskExecutor) {
        this.threadPoolTaskExecutor = threadPoolTaskExecutor;
    }

    @Autowired
    public void setSendMail(SendMail sendMail) {
        this.sendMail = sendMail;
    }

    @Autowired
    public void setOrderRecordService(OrderRecordServiceImpl orderRecordService) {
        this.orderRecordService = orderRecordService;
    }

    private OperationRecordServiceImpl operationRecordService;

    @Autowired
    public void setOperationRecordService(OperationRecordServiceImpl operationRecordService) {
        this.operationRecordService = operationRecordService;
    }

    @Pointcut("execution(Boolean edu.sdust.seatallocation.service.serviceimpl.AdminServiceImpl.*(..))")
    public void adminServicePointCut(){

    }

    @Around("adminServicePointCut()")
    public Object addOperationRecord(ProceedingJoinPoint pjp) throws Throwable {
        Boolean proceed = (Boolean) pjp.proceed();
        if (proceed){
            HashMap<String, Object> map = getArgs(pjp);
            OperationRecord operationRecord = new OperationRecord();
            operationRecord.setDate(new Date());
            if ("announce".equals(pjp.getSignature().getName())){
                operationRecord.setAccount((String) map.get("account"))
                        .setName((String) map.get("name"))
                        .setOperation("添加公告");
            }else if("addFlight".equals(pjp.getSignature().getName())){
                HashMap<String, String> hashMap = (HashMap<String, String>) map.get("hashMap");
                operationRecord.setName(hashMap.get("name"))
                        .setAccount(hashMap.get("account"))
                        .setOperation("添加了航班," +
                                "航班号为："+hashMap.get("flight")+"," +
                                "机型为："+hashMap.get("planeType")+"," +
                                "起飞时间为："+hashMap.get("date")+"," +
                                "出发地为："+hashMap.get("departure")+"," +
                                "目的地为："+hashMap.get("destination")+"," +
                                "航班是否持续："+hashMap.get("always"));
            }else if ("stopFlight".equals(pjp.getSignature().getName())){
                operationRecord.setName(((String) map.get("name")))
                        .setAccount(((String) map.get("account")))
                        .setOperation("停飞了航班," +
                                "航班号为："+map.get("flight")+"," +
                                "停飞日期为："+map.get("date")+"," +
                                "是否持续："+map.get("always"));
                orderRecordService.cancelTicket(((String) map.get("flight")), ((String) map.get("date")),null);
            }else if ("reAvailable".equals(pjp.getSignature().getName())){
                operationRecord.setName(((String) map.get("name")))
                        .setAccount(((String) map.get("account")))
                        .setOperation("复航了航班," +
                                "航班号为："+map.get("flight")+"," +
                                "复飞日期为："+map.get("date")+"," +
                                "是否持续："+map.get("always"));
            }
            operationRecordService.save(operationRecord);
        }
        return proceed;
    }

    @Around("execution(Boolean edu.sdust.seatallocation.service.serviceimpl.OrderRecordServiceImpl.insertRecord(..))")
    public Object notificationOfSuccessfulTicketPurchase(ProceedingJoinPoint pjp) throws Throwable {
        Object proceed = pjp.proceed();
        if (((Boolean) proceed)){
            threadPoolTaskExecutor.submit(()->{
                HashMap<String, Object> args = getArgs(pjp);
                OrderRecord orderRecord = (OrderRecord) args.get("orderRecord");
                SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                String s = null;
                try {
                    s = JsoupUtil.generateTicketNotifyMail(
                            simpleDateFormat.format(orderRecord.getFlightDate())
                            , orderRecord.getFlight()
                            , orderRecord.getDeparture()
                            , orderRecord.getDestination()
                            , orderRecord.getSeatNumber()
                            , "购票成功");
                    redisTemplate.opsForList().leftPush("orders",orderRecord);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                try {
                    sendMail.send(orderRecord.getPassengerMailAddress(),s,"购票成功");
                } catch (MessagingException e) {
                    e.printStackTrace();
                }
            });
        }
        return proceed;
    }

    private HashMap<String, Object> getArgs(ProceedingJoinPoint pjp) {
        HashMap<String, Object> map = new HashMap<>(10);
        Object[] args = pjp.getArgs();
        String[] parameterNames = ((CodeSignature) pjp.getSignature()).getParameterNames();
        for (int i = 0; i < parameterNames.length; i++) {
            map.put(parameterNames[i], args[i]);
        }
        return map;
    }

    @Around("execution(String edu.sdust.seatallocation.service.serviceimpl.TicketServiceImpl.beforeGet(..))")
    public Object calculateTheWeight(ProceedingJoinPoint pjp) throws Throwable {
        String proceed = (String) pjp.proceed();
        HashMap<String, Object> args = getArgs(pjp);
        if("-1".equals(proceed))
        {
            updateSatisfaction(0.0,(String)args.get("flight"),(Date) args.get("date"));
            return proceed;
        }
        QueryWrapper<Calculate> calculateQueryWrapper = new QueryWrapper<>();
        calculateQueryWrapper.eq("flight",args.get("flight")).eq("date",args.get("date"));
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.eq("flight",args.get("flight"));
        Ticket ticket = ticketMapper.selectList(ticketQueryWrapper).get(0);
        String seatString = "";
        ClassType temp = (ClassType) args.get("classType");
        int row = Integer.parseInt(proceed.substring(1));
        if(temp==ClassType.FIRST)
        {
            seatString = ticket.getFirstClass();
        }
        else if(temp == ClassType.BUSINESS)
        {
            seatString = ticket.getBusinessClass();
            if (ticket.getFirstClass() != null) {
                row-=ticket.getFirstClass().split(",").length;
            }
        }
        else if(temp == ClassType.ECONOMY)
        {
            seatString = ticket.getEconomyClass();
            if (ticket.getFirstClass() != null) {
                row-=ticket.getFirstClass().split(",").length;
            }
            if (ticket.getBusinessClass() != null) {
                row-=ticket.getBusinessClass().split(",").length;
            }
        }
        String[] seatArr = seatString.split(",");
        int col = Integer.parseInt(String.valueOf(proceed.substring(0,1).charAt(0)-'A'));

        String seatRow = seatArr[row-1];
        final Preference request = (Preference) args.get("request");
        if(request==Preference.NONE)
        {
            updateSatisfaction(1.0,(String)args.get("flight"),(Date) args.get("date"));
        }
        else if(request==Preference.WINDOW)
        {
            int allCount = 0;
            for(int i = 0;i<seatRow.length();++i)
            {
                if(seatRow.charAt(i)!=' ')
                {
                    ++allCount;
                }
            }
            col = min(col,allCount-col-1);
            updateSatisfaction(1.0-col/10.0,(String)args.get("flight"),(Date) args.get("date"));
        }
        else if(request==Preference.AISLE)
        {
            String[] s = seatRow.split(" ");
            int allCount = 0;
            for (String value : s) {
                if (allCount + value.length() >= col) {
                    col = min(col - allCount, allCount + value.length() - col -1);
                    updateSatisfaction(1.0 - col / 10.0, (String) args.get("flight"), (Date) args.get("date"));
                    break;
                }
            }
        }
        return proceed;
    }

    private void updateSatisfaction(double weights,String flight,Date date) {
        QueryWrapper<Calculate> calculateQueryWrapper = new QueryWrapper<>();
        calculateQueryWrapper.eq("flight",flight).eq("date",date);
        final Integer integer = calculateMapper.selectCount(calculateQueryWrapper);
        if(integer==0)
        {
            Calculate calculate = new Calculate();
            calculate.setDate(date);
            calculate.setFlight(flight);
            calculate.setMolecular(weights);
            calculate.setDenominator(1);
            calculateMapper.insert(calculate);
        }
        else
        {
            Calculate temp = calculateMapper.selectList(calculateQueryWrapper).get(0);
            UpdateWrapper<Calculate> calculateUpdateWrapper = new UpdateWrapper<>();
            calculateUpdateWrapper.eq("flight",flight).eq("date",date);
            Calculate calculate = new Calculate();
            calculate.setMolecular(temp.getMolecular()+weights);
            calculate.setDenominator(temp.getDenominator()+1);
            calculateMapper.update(calculate,calculateUpdateWrapper);
        }
    }

    @Around("execution(Boolean edu.sdust.seatallocation.service.serviceimpl.OrderRecordServiceImpl.cancelTicket(..))")
    public Object restoreTicket(ProceedingJoinPoint pjp) throws Throwable {
        Boolean proceed = (Boolean) pjp.proceed();
        if (!proceed) {
            System.out.println("false");
            return false;
        }
        HashMap<String, Object> args = getArgs(pjp);
        QueryWrapper<OrderRecord> orderRecordQueryWrapper = new QueryWrapper<>();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date date = simpleDateFormat.parse(((String) args.get("date")));
        orderRecordQueryWrapper.eq("flight",args.get("flight")).eq("flight_date",date).eq("passenger_identity_number",args.get("identityNum"));
        System.out.println(orderRecordQueryWrapper.getTargetSql());
        OrderRecord orderRecord = orderRecordMapper.selectList(orderRecordQueryWrapper).get(0);
        String seatId = orderRecord.getSeatNumber();
        String classType = orderRecord.getClassType();
        int row = Integer.parseInt(seatId.substring(1));
        int col = Integer.parseInt(String.valueOf(seatId.substring(0,1).charAt(0)-'A'));
        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
        ticketQueryWrapper.eq("flight",args.get("flight")).eq("date",date);
        Ticket ticket = ticketMapper.selectList(ticketQueryWrapper).get(0);
        String seatString="";
        HashMap<String, ClassType> classEnumMap = MapUtil.getClassEnumMap();
        if(classEnumMap.get(classType).equals(ClassType.BUSINESS))
        {
            seatString = ticket.getBusinessClass();
        }
        else if(classEnumMap.get(classType).equals(ClassType.FIRST)){
            seatString = ticket.getFirstClass();
        }
        else if(classEnumMap.get(classType).equals(ClassType.ECONOMY)){
            seatString = ticket.getEconomyClass();
        }
        String[] split = seatString.split(",");
        StringBuilder finalString= new StringBuilder();
        for(int i = 0;i<split.length;++i)
        {
            if(i==row-1)
            {
                StringBuilder stringBuilder = new StringBuilder(split[i]);
                int allCount = 0;
                for(int j = 0;j<split[i].length();++j){
                    if(col==allCount)
                    {
                        stringBuilder.replace(j,j+1,"0");
                        break;
                    }
                    if(split[i].charAt(j)!=' ')
                    {
                       ++allCount;
                    }

                }
                finalString.append(stringBuilder);
            }
            else {
                finalString.append(split[i]);
            }
            if(i!=split.length-1)
            {
                finalString.append(",");
            }

        }
        UpdateWrapper<Ticket> ticketUpdateWrapper = new UpdateWrapper<>();
        ticketUpdateWrapper.eq("flight",args.get("flight")).eq("date",date);
        if(classEnumMap.get(classType).equals(ClassType.BUSINESS))
        {
            ticket.setBusinessClass(finalString.toString());
        }
        else if(classEnumMap.get(classType).equals(ClassType.FIRST)){
            ticket.setFirstClass(finalString.toString());
        }
        else if(classEnumMap.get(classType).equals(ClassType.ECONOMY)){
            ticket.setEconomyClass(finalString.toString());
        }
        ticketMapper.update(ticket,ticketUpdateWrapper);
        return true;
    }
}
```

### 编写controller

##### 乘客相关URL

```java
@RestController
@RequestMapping("/passenger")
@PropertySource("classpath:token.properties")
public class PassengerController {

    private PassengerServiceImpl passengerService;

    @Value("${secret}")
    private String secret;

    @Autowired
    public void setPassengerService(PassengerServiceImpl passengerService) {
        this.passengerService = passengerService;
    }


    @PostMapping("/signUp")
    public String signUp(@RequestBody String info) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode jsonNode = objectMapper.readTree(info).get("data");

        String mailAddress = jsonNode.get("account").textValue();
        String password = jsonNode.get("password").textValue();
        String name = jsonNode.get("username").textValue();
        String data = passengerService.signUp(mailAddress, name, password);
        return objectMapper.writeValueAsString(ResultTool.success(data));
    }

    @PostMapping("/signUpCheck")
    public String signUpCheck(@RequestBody String data) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode jsonNode = objectMapper.readTree(data).get("data");
        String result = passengerService.signUpCheck(jsonNode.get("verificationCode").textValue());
        return objectMapper.writeValueAsString(ResultTool.success(result));
    }


    @PostMapping("/forgetPassword")
    public String forgetPassword(HttpServletRequest request) throws IOException, MessagingException {
        String email = request.getParameter("email");
        return passengerService.forgetPassword(email);
    }


    @PostMapping("/changePassengerInfo")
    public String changePassengerInfo(
            @RequestParam(value = "preference",required = false) String preference,
            @RequestParam(value = "name",required = false)String name,
            @RequestParam(value = "sex",required = false)String sex,
            @RequestParam(value = "identityNumber",required = false)String identityNumber,
            @RequestParam(value = "birthday",required = false)String birthday,
            @RequestParam("mailAddress")String mailAddress) {
        if (passengerService.changePersonalInfo(preference, name, sex, identityNumber, birthday, mailAddress)) {
            return "success";
        }
        return "error";
    }

    @GetMapping("/checkToken")
    public String checkToken(@RequestParam("token") String token) throws JsonProcessingException {
        String s = TokenUtil.parseToken(token, secret);
        if (s != null) {
            JsonResult success = ResultTool.success();
            return new ObjectMapper().writeValueAsString(success);
        } else {
            JsonResult fail = ResultTool.fail(ResultCode.USER_TOKEN_INVALID);
            return new ObjectMapper().writeValueAsString(fail);
        }
    }
}
```

##### 飞机信息URL

```java
@RestController
@RequestMapping("/planeInfo")
public class PlaneInfoController {

    private PlaneInfoMapper planeInfoMapper;

    @Autowired
    public void setPlaneInfoMapper(PlaneInfoMapper planeInfoMapper) {
        this.planeInfoMapper = planeInfoMapper;
    }

    @GetMapping("/getAllPlaneType")
    public String getAllPlaneInfo() throws JsonProcessingException {
        List<String> collect = planeInfoMapper.selectList(null)
                .stream()
                .map(PlaneInfo::getType)
                .collect(Collectors.toList());
        ObjectMapper objectMapper = new ObjectMapper();
        return objectMapper.writeValueAsString(collect);
    }
}
```

##### 机票相关URL

```java
@RestController
@RequestMapping("/ticket")
public class TicketController {

    private TicketServiceImpl ticketService;

    private OrderRecordServiceImpl orderRecordService;

    private TicketMapper ticketMapper;

    @Autowired
    public void setTicketMapper(TicketMapper ticketMapper) {
        this.ticketMapper = ticketMapper;
    }

    @Autowired
    public void setTicketService(TicketServiceImpl ticketService) {
        this.ticketService = ticketService;
    }

    @Autowired
    public void setOrderRecordService(OrderRecordServiceImpl orderRecordService) {
        this.orderRecordService = orderRecordService;
    }

    private final ReentrantLock reentrantLock = new ReentrantLock(true);

    @GetMapping("/applyForTicketAllocation")
    public String getSeatId(
            @RequestParam("direction")String direction,
            @RequestParam("position")String position,
            @RequestParam("flight")String flight,
            @RequestParam("identityNumber")String identityNumber,
            @RequestParam("date")String dateParam,
            @RequestParam("mailAddress")String mailAddress,
            @RequestParam("classType")String classType) throws ParseException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date date = simpleDateFormat.parse(dateParam.split(" ")[0]);
        Boolean hasBought = orderRecordService.hasBought(flight, identityNumber, date);
        if (hasBought) {
            return "0";
        }
        String[] split = position.split(",");
        String[] split1 = direction.split(",");
        HashMap<String, Preference> map = MapUtil.getStringEnumMap();
        HashMap<String, ClassType> classEnumMap = MapUtil.getClassEnumMap();
        for (String s : split) {
            for (String s1 : split1) {
                reentrantLock.lock();

                try {
                    String seatId = ticketService.beforeGet(flight, classEnumMap.get(classType), map.get(s), map.get(s1), date);
                    if (!"-1".equals(seatId)) {
                        OrderRecord orderRecord = new OrderRecord();
                        SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                        Date parse = simpleDateFormat1.parse(dateParam);
                        QueryWrapper<Ticket> ticketQueryWrapper = new QueryWrapper<>();
                        ticketQueryWrapper.eq("flight", flight);
                        List<Ticket> tickets = ticketMapper.selectList(ticketQueryWrapper);
                        Ticket ticket = tickets.stream()
                                .limit(1)
                                .collect(Collectors.toList())
                                .get(0);
                        orderRecord.setFlightDate(parse)
                                .setOrderDate(new Date())
                                .setFlight(flight)
                                .setPlaneType(ticket.getPlaneType())
                                .setDeparture(ticket.getDeparture())
                                .setDestination(ticket.getDestination())
                                .setSeatNumber(seatId)
                                .setClassType(classType)
                                .setPassengerIdentityNumber(identityNumber)
                                .setPassengerMailAddress(mailAddress);
                        orderRecordService.insertRecord(orderRecord);
                        return seatId;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    reentrantLock.unlock();
                }
            }
        }
        return "-1";
    }

    @RequestMapping(value = "/getFlightInformation", method = {RequestMethod.GET, RequestMethod.POST})
    public String getAllFlightInformation(HttpServletRequest request) throws JsonProcessingException, ParseException {
        String date = request.getParameter("date");
        String destination = request.getParameter("destination");
        String departure = request.getParameter("departure");
        if (date != null && destination != null && departure != null) {
            return ticketService.getFlightInformationByDateOrDestination(date, destination, departure, true);
        }
        return ticketService.getAllFlightInformation(true, false);
    }

    @GetMapping("/getFlightNum")
    public int getFlightNum() {
        return ticketService.getFlightNumber(true, false);
    }

    @GetMapping("/getFlightInformationByPage")
    public String getFlightInformationByPage(@RequestParam("page") int page, @RequestParam("pageSize") int pageSize) throws JsonProcessingException {
        return ticketService.getFlightByPage(true, false, page, pageSize);
    }

    @GetMapping("/getFlightNumByOptions")
    public int getFlightNumByOptions(
            @RequestParam("startDate") String startDate
            , @RequestParam("endDate") String endDate
            , @RequestParam("destination") String destination
            , @RequestParam("departure") String departure) throws ParseException {
        return ticketService.getFlightNumberByOptions(true, startDate, endDate, destination, departure);
    }

    @GetMapping("/getFlightInformationByPageAndOptions")
    public String getFlightInformationByPageAndOptions(
            @RequestParam("page") int page
            , @RequestParam("pageSize") int pageSize
            , @RequestParam("startDate") String startDate
            , @RequestParam("endDate") String endDate
            , @RequestParam("destination") String destination
            , @RequestParam("departure") String departure) throws ParseException, JsonProcessingException {
        return ticketService.getFlightInformationByDateOrDestinationAndPage(startDate, endDate, destination, departure, true, page, pageSize);
    }

    @GetMapping("/getAllDestinations")
    public String getAllDestinations() throws JsonProcessingException {
        return ticketService.getDestinations();
    }

    @GetMapping("/getAllDepartures")
    public String getAllDepartures() throws JsonProcessingException {
        return ticketService.getDepartures();
    }
}
```

##### 订单相关URL

```java
@RestController
@RequestMapping("/record")
public class OrderRecordController {

    private OrderRecordServiceImpl orderRecordService;

    @Autowired
    public void setOrderRecordService(OrderRecordServiceImpl orderRecordService) {
        this.orderRecordService = orderRecordService;
    }

    @GetMapping("/getAllOrderRecord")
    public String getAllOrderRecord(HttpServletRequest request) throws JsonProcessingException {
        String identityNum = request.getParameter("identityNum");
        LinkedList<OrderRecord> orderRecords = orderRecordService.queryRecord(identityNum);
        return WriteUtil.generateCorrectOrderRecordJson(orderRecords);
    }

    @PostMapping("/modifiedSatisfaction")
    public String modifiedSatisfaction(
            @RequestParam("flight")String flight,
            @RequestParam("identityNum")String identityNum,
            @RequestParam("time")String time,
            @RequestParam("satisfaction")String satisfaction) throws ParseException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date parse = simpleDateFormat.parse(time);
        return orderRecordService.
                satisfactionChange(Integer.parseInt(satisfaction)
                        , flight
                        , identityNum
                        , parse) ? "success" : "error";
    }

    @GetMapping("/getSatisfactionForOneRecord")
    public Integer getSatisfactionForOneRecord(
            @RequestParam("time") String time,
            @RequestParam("flight") String flight,
            @RequestParam("identityNumber") String identityNumber) throws ParseException {
        return orderRecordService.getSatisfactionForOneRecord(time, flight, identityNumber);
    }

    @PostMapping("/cancelTicket")
    public String cancelTicket(
            @RequestParam("identityNumber")String identityNumber,
            @RequestParam("flight")String flight,
            @RequestParam("date")String date) throws ParseException, IOException {

        Boolean aBoolean = orderRecordService.cancelTicket(flight, date, identityNumber);

        return aBoolean ? "success" : "failure";
    }

    @GetMapping("/getRecordsNumber")
    public int getRecordsNumber(@RequestParam("identityNumber") String identityNumber) {
        return orderRecordService.getRecordsNumber(identityNumber);
    }

    @GetMapping("/getRecordsByPage")
    public String getRecordsByPage(@RequestParam("identityNumber") String identityNumber, @RequestParam("page") int page, @RequestParam("pageSize") int pageSize) throws JsonProcessingException {
        return orderRecordService.getRecordsByPage(identityNumber, page, pageSize);
    }
}
```

##### 公告相关URL

```java
@RestController
@RequestMapping("/announce")
public class AnnounceController {



    private ObjectMapper objectMapper;

    private IAnnounceService announceService;

    @Autowired
    public void setAnnounceService(IAnnounceService announceService) {
        this.announceService = announceService;
    }

    @Autowired
    public void setObjectMapper(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @GetMapping("/getAllAnnounce")
    public String getAllAnnounce(@RequestParam("mailAddress")String mailAddress) throws JsonProcessingException {
        return objectMapper.writeValueAsString(announceService.getAllAnnounce(mailAddress));
    }



    @GetMapping("/getNumOfNotViewed")
    public Long getNumOfNotViewed(@RequestParam("mailAddress")String mailAddress){
        return announceService.numOfNotViewedAnnounce(mailAddress);
    }

    @GetMapping("/getAnnounceBySize")
    public String getAnnounceBySize(
            @RequestParam("increment")int increment,
            @RequestParam("account")String account,
            @RequestParam("nowSize")int nowSize) throws JsonProcessingException {
        LinkedList<Announcement> announcements = announceService.getAnnounceBySize(account, increment,nowSize);
        if (announcements == null||announcements.size()==0) {
            return "";
        }else {
            return objectMapper.writeValueAsString(announcements);
        }
    }
}
```

管理员相关URL

```java
@RestController
@RequestMapping("/admin")
@PropertySource("classpath:host.properties")
public class AdminController {

    @Value("${imagePath}")
    private String imagePath;

    @Value("${resourceUrlPrefix}")
    private String resourceUrlPrefix;

    private AdminServiceImpl adminService;

    private TicketServiceImpl ticketService;

    @Autowired
    public void setTicketService(TicketServiceImpl ticketService) {
        this.ticketService = ticketService;
    }

    @Autowired
    public void setAdminService(AdminServiceImpl adminService) {
        this.adminService = adminService;
    }

    @PostMapping("/announce")
    public String announce(@RequestBody String data) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode jsonNode = objectMapper.readTree(data);
        return adminService.announce(
                jsonNode.get("html").asText(),
                jsonNode.get("account").asText(),
                jsonNode.get("name").asText())?"success":"failure";
    }

    @PostMapping("/uploadImage")
    public String uploadImage(HttpServletRequest request) {
        StandardMultipartHttpServletRequest standardMultipartHttpServletRequest = new StandardMultipartHttpServletRequest(request);
        MultipartFile image = standardMultipartHttpServletRequest.getFile("edit");
        if (image == null) {
            System.out.println("null");
            return "failure";
        }
        try {
            ArrayList<String> strings = new ArrayList<>(Arrays.asList(Objects.requireNonNull(image.getOriginalFilename()).split("\\.")));
            String jpg = strings.get(strings.size() - 1);
            String name = UUID.randomUUID().toString().split("-")[0] + "." + jpg;
            image.transferTo(new File(imagePath, name));
            return resourceUrlPrefix +name;
        } catch (IOException e) {
            return "failure";
        }
    }
    @PostMapping("/addFlight")
    public String addFlight(HttpServletRequest request) throws ParseException {
        HashMap<String, String> hashMap = new HashMap<>(10);
        hashMap.put("flight",request.getParameter("flight"));
        hashMap.put("date",request.getParameter("date"));
        hashMap.put("always",request.getParameter("always"));
        hashMap.put("departure",request.getParameter("departure"));
        hashMap.put("destination",request.getParameter("destination"));
        hashMap.put("planeType",request.getParameter("planeType"));
        hashMap.put("account",request.getParameter("account"));
        hashMap.put("name",request.getParameter("name"));
        return adminService.addFlight(hashMap)?"success":"failure";
    }

    @PostMapping("/stopFlight")
    public String stopFlight(HttpServletRequest request) throws ParseException {
        String flight = request.getParameter("flight");
        String date = request.getParameter("date");
        String always = request.getParameter("always");
        String account = request.getParameter("account");
        String name = request.getParameter("name");
        return adminService.stopFlight(flight, date, always,account,name)?"success":"failure";
    }

    @GetMapping("/getAllFlightInfo")
    public String getAllFlightInfo(HttpServletRequest request) throws ParseException, JsonProcessingException {
        String date = request.getParameter("date");
        String destination = request.getParameter("destination");
        String departure = request.getParameter("departure");
        String includeHistory = request.getParameter("includeHistory");
        String availableOnly = request.getParameter("availableOnly");
        if (date != null && destination != null && departure != null) {
            return ticketService.getFlightInformationByDateOrDestination(date, destination, departure,Boolean.parseBoolean(availableOnly));
        }
        return ticketService.getAllFlightInformation(Boolean.parseBoolean(availableOnly),Boolean.parseBoolean(includeHistory));
    }

    @PostMapping("/reAvailable")
    public String reAvailable(HttpServletRequest request) throws ParseException {
        String date = request.getParameter("date");
        String flight = request.getParameter("flight");
        String planeType = request.getParameter("planeType");
        String always = request.getParameter("always");
        String account = request.getParameter("account");
        String name = request.getParameter("name");
        return adminService.reAvailable(flight,date,always,account,name,planeType)?"success":"failure";
    }
}
```

### 编写启动类

```java
@SpringBootApplication
@EnableWebSecurity
@EnableScheduling
@EnableAspectJAutoProxy
public class SeatAllocationApplication {

    public static void main(String[] args) {
        SpringApplication.run(SeatAllocationApplication.class, args);
    }

}
```

# 前端编码











































# 服务器部署

